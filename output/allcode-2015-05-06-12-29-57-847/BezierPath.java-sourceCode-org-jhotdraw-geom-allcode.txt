org jhotdraw geom import awt * import awt geom * import util * bezier path list< bezier path node> implements shape { C1_MASK = 1 C2_MASK = 2 C1C2_MASK = C1_MASK | C2_MASK private transient general path general path private outer = -1 private closed node implements cloneable { mask = 0 = new 3 = new 3 keep colinear = node { mask = 1 } node node that { set to that } set to node that { this mask = that mask this keep colinear = that keep colinear arraycopy that 0 this 0 3 arraycopy that 0 this 0 3 } node point2 c0 { this mask = 0 0 = c0 0 = c0 1 = c0 1 = c0 2 = c0 2 = c0 } node mask point2 c0 point2 c1 point2 c2 { this mask = mask 0 = c0 0 = c0 1 = c1 1 = c1 2 = c2 2 = c2 } node x0 y0 { this mask = 0 0 = x0 0 = y0 1 = x0 1 = y0 2 = x0 2 = y0 } node mask x0 y0 x1 y1 x2 y2 { this mask = mask 0 = x0 0 = y0 1 = x1 1 = y1 2 = x2 2 = y2 } get mask { mask } set mask new value { mask = new value } set control point index point2 { index = index = } point2 get control point index { new point2 index index } move to point2 { move by - 0 - 0 } move to { move by - this 0 - this 0 } move by dx dy { for i=0 < 3 i++ { += dx += dy } } clone { try { node that = node super clone that = this clone that = this clone that } catch clone not supported { internal = new internal init cause } } to { builder buf = new builder buf append ' ' for i=0 < 3 i++ { if != 0 { if mask == { buf append ' ' } else { continue } } buf append 'x' buf append buf append '=' buf append buf append buf append buf append '=' buf append } buf append ' ' buf to } } bezier path { } add point2 c0 { add new node 0 c0 c0 c0 } add point { add new node 0 } add mask point2 c0 point2 c1 point2 c2 { add new node mask c0 c1 c2 } set index coord point2 { node = get index coord = coord = } point2 get index coord { node = get index new point2 coord coord } invalidate path { general path = outer = -1 } validate path { if general path == { general path = to general path } } general path to general path { general path gp = new general path gp set winding rule general path WIND_EVEN_ODD if size == 0 { gp move to 0 0 gp line to 0 0 + 1 } else if size == 1 { node current = get 0 gp move to float current 0 float current 0 gp line to float current 0 float current 0 + 1 } else { node previous node current previous = current = get 0 gp move to float current 0 float current 0 for i=1 = size < i++ { previous = current current = get if previous mask C2_MASK == 0 { if current mask C1_MASK == 0 { gp line to float current 0 float current 0 } else { gp quad to float current 1 float current 1 float current 0 float current 0 } } else { if current mask C1_MASK == 0 { gp quad to float previous 2 float previous 2 float current 0 float current 0 } else { gp curve to float previous 2 float previous 2 float current 1 float current 1 float current 0 float current 0 } } } if closed { if size > 1 { previous = get size - 1 current = get 0 if previous mask C2_MASK == 0 { if current mask C1_MASK == 0 { gp line to float current 0 float current 0 } else { gp quad to float current 1 float current 1 float current 0 float current 0 } } else { if current mask C1_MASK == 0 { gp quad to float previous 2 float previous 2 float current 0 float current 0 } else { gp curve to float previous 2 float previous 2 float current 1 float current 1 float current 0 float current 0 } } } gp close path } } gp } contains point2 { validate path general path contains } outline contains point2 tolerance { validate path path iterator = general path get path iterator new affine transform tolerance coords = new 6 type = current segment coords prev = coords 0 prev = coords 1 next while ! done { current segment coords if geom line contains point prev prev coords 0 coords 1 tolerance { } prev = coords 0 prev = coords 1 next } } intersects rectangle2 { validate path general path intersects } path iterator get path iterator affine transform { validate path general path get path iterator } contains rectangle2 { validate path general path contains } path iterator get path iterator affine transform flatness { validate path general path get path iterator flatness } intersects { validate path general path intersects } rectangle2 get bounds2 { validate path general path get bounds2 } rectangle2 get bounds2 { validate path rectangle2 = general path get bounds2 if instanceof rectangle2 { rectangle2 } else { new rectangle2 get get get width get height } } rectangle get bounds { validate path general path get bounds } contains { validate path general path contains } contains { validate path general path contains } set closed new value { if closed != new value { closed = new value invalidate path } } closed { closed } clone { bezier path that = bezier path super clone for i=0 = this size < i++ { that set node this get clone } that } transform affine transform tx { point2 = new point2 for node cp this { for i=0 < 3 i++ { = cp = cp tx transform cp = cp = } } invalidate path } set to bezier path that { while that size < size { remove size - 1 } for i=0 = size < i++ { get set to that get } while size < that size { add node that get size clone } } point2 get center { sx = 0 = 0 for node this { sx += 0 += 0 } = size new point2 sx / / } point2 chop point2 { validate path geom chop general path } index of outermost node { if outer == -1 { point2 ctr = get center outer = 0 dist = 0 for = 0 = size < i++ { node cp = get = geom length2 ctr ctr cp 0 cp 0 if > dist { dist = outer = } } } outer } point2 get point path relative flatness { if size == 0 { } else if size == 1 { get 0 get control point 0 } if relative <= 0 { get 0 get control point 0 } else if relative >= 1 { get size - 1 get control point 0 } validate path len = 0 path iterator = general path get path iterator new affine transform flatness coords = new 6 type = current segment coords prev = coords 0 prev = coords 1 next for ! done next { current segment coords len += geom length prev prev coords 0 coords 1 prev = coords 0 prev = coords 1 } relative len = len * relative pos = 0 = general path get path iterator new affine transform flatness type = current segment coords prev = coords 0 prev = coords 1 next for ! done next { current segment coords seg len = geom length prev prev coords 0 coords 1 if pos + seg len >= relative len { factor = relative len - pos / seg len new point2 prev * 1 - factor + coords 0 * factor prev * 1 - factor + coords 1 * factor } pos += seg len prev = coords 0 prev = coords 1 } new internal we should never get here } find segment point2 find float tolerance { node v1 v2 bezier path temp path = new bezier path node t1 t2 temp path add t1 = new node temp path add t2 = new node for = 0 = size -1 < i++ { v1 = get v2 = get i+1 if v1 mask == 0 v2 mask == 0 { if geom line contains point v1 0 v1 0 v2 0 v2 0 find find tolerance { } } else { t1 set to v1 t2 set to v2 temp path invalidate path if temp path outline contains find tolerance { } } } if closed size > 1 { v1 = get size - 1 v2 = get 0 if v1 mask == 0 v2 mask == 0 { if geom line contains point v1 0 v1 0 v2 0 v2 0 find find tolerance { size - 1 } } else { t1 set to v1 t2 set to v2 temp path invalidate path if temp path outline contains find tolerance { size - 1 } } } -1 } join segments point2 join float tolerance { for i=0 < size i++ { node = get if geom length 0 0 join join < tolerance { remove } } -1 } split segment point2 split float tolerance { = find segment split tolerance next = + 1 % size if != -1 { if get mask C2_MASK == C2_MASK get next mask C1_MASK == 0 { add + 1 new node C2_MASK split split split } else if get mask C2_MASK == 0 get next mask C1_MASK == C1_MASK { add + 1 new node C2_MASK split split split } else if get mask C2_MASK == C2_MASK get next mask C1_MASK == C2_MASK { add + 1 new node C1_MASK | C2_MASK split split split } else { add + 1 new node split } } i+1 } move to x1 y1 { if size != 0 { new illegal path state move to only allowed when empty } add new node x1 y1 } line to x1 y1 { if size == 0 { new illegal path state line to only allowed when not empty } add new node x1 y1 } quad to x1 y1 x2 y2 { if size == 0 { new illegal path state quad to only allowed when not empty } add new node C1_MASK x2 y2 x1 y1 x2 y2 } curve to x1 y1 x2 y2 x3 y3 { if size == 0 { new illegal path state curve to only allowed when not empty } node last point = get size - 1 last point mask |= C2_MASK last point 2 = x1 last point 2 = y1 add new node C1_MASK x3 y3 x2 y2 x3 y3 } point2 to polygon { point2 points = new point2 size for i=0 = size < i++ { points = new point2 get 0 get 0 } points } } 