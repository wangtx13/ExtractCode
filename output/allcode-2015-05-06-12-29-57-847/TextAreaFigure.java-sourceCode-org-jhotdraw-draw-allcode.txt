org jhotdraw draw import org jhotdraw util * import awt * import awt font * import awt geom * import text * import util * import * import org jhotdraw draw attribute keys * import org jhotdraw geom * import org jhotdraw xml dom input import org jhotdraw xml dom output text area figure attributed figure implements text holder { private rectangle2 bounds = new rectangle2 private editable = private basic stroke dashes = new basic stroke 1f basic stroke CAP_BUTT basic stroke JOIN_BEVEL 0f new float {4f 4f} 0f transient private text layout text layout text area figure { this text } text area figure text { set text text } get text { get attribute } set text new text { set attribute new text } basic set bounds point2 anchor point2 { bounds = math min anchor bounds = math min anchor bounds width = math max 1 math - anchor bounds height = math max 1 math - anchor text layout = } basic transform affine transform tx { point2 anchor = get start point point2 = get point basic set bounds point2 tx transform anchor anchor point2 tx transform } contains point2 { bounds contains } insets2 get insets { sw = math ceil STROKE_WIDTH get this / 2 insets2 insets = new insets2 4 4 4 4 new insets2 insets top+sw insets left+sw insets bottom+sw insets right+sw } get tab size { 8 } draw text graphics2 { if get text != || editable { font font = get font underlined = FONT_UNDERLINED get this insets2 insets = get insets rectangle2 text rect = new rectangle2 bounds + insets left bounds + insets top bounds width - insets left - insets right bounds height - insets top - insets bottom float left margin = float text rect float right margin = float math max left margin + 1 text rect + text rect width float vertical pos = float text rect if left margin < right margin { float tab width = float get tab size * get font metrics font char width 'm' float tab stops = new float text rect width / tab width for i=0 < tab stops length i++ { tab stops = float text rect + tab width * + 1 } if get text != { shape saved clip area = get clip clip text rect paragraphs = get text split \n for = 0 < paragraphs length i++ { if paragraphs length == 0 paragraphs = attributed = new attributed paragraphs add attribute text attribute font if underlined { add attribute text attribute text attribute UNDERLINE_LOW_ONE_PIXEL } tab count = new tokenizer paragraphs \t count tokens - 1 vertical pos = draw paragraph get iterator vertical pos left margin right margin tab stops tab count if vertical pos > text rect + text rect height { break } } set clip saved clip area } } if left margin >= right margin || vertical pos > text rect + text rect height { set color color red set stroke dashes draw new line2 text rect text rect + text rect height - 1 text rect + text rect width - 1 text rect + text rect height - 1 } } } private float draw paragraph graphics2 attributed character iterator styled text float vertical pos float left margin float right margin float tab stops tab count { tab locations = new tab count+1 = 0 for char = styled text first != styled text = styled text next { if == '\t' { tab locations i++ = styled text get index } } tab locations tab count = styled text get index - 1 line break measurer measurer = new line break measurer styled text get font render context current tab = 0 while measurer get position < styled text get index { line contains text = line complete = float max ascent = 0 max descent = 0 float horizontal pos = left margin linked list< text layout> layouts = new linked list< text layout> linked list< float> pen positions = new linked list< float> while !line complete { float wrapping width = right margin - horizontal pos text layout layout = layout = measurer next layout wrapping width tab locations current tab +1 line contains text if layout != { layouts add layout pen positions add horizontal pos horizontal pos += layout get advance max ascent = math max max ascent layout get ascent max descent = math max max descent layout get descent + layout get leading } else { line complete = } line contains text = if measurer get position == tab locations current tab +1 { current tab++ } if measurer get position == styled text get index line complete = else if tab stops length == 0 || horizontal pos >= tab stops tab stops length-1 line complete = if !line complete { for j=0 horizontal pos >= tab stops j++ {} horizontal pos = tab stops } } vertical pos += max ascent iterator< text layout> layout enum = layouts iterator iterator< float> position enum = pen positions iterator while layout enum has next { text layout next layout = layout enum next float next position = position enum next next layout draw next position vertical pos } vertical pos += max descent } vertical pos } draw fill graphics2 { fill bounds } draw stroke graphics2 { draw bounds } rectangle2 get bounds { rectangle2 bounds get bounds2 } collection< handle> create handles detail level { linked list< handle> handles = linked list< handle> super create handles detail level if detail level == 0 { handles add new font size handle this } handles } validate { super validate text layout = } editable { editable } set editable { this editable = } get text columns { get text == ? 4 math max get text length 4 } tool get tool point2 { editable contains ? new text area tool this } read bounds dom input { bounds = get attribute 0d bounds = get attribute 0d bounds width = get attribute 0d bounds height = get attribute 0d } write bounds dom output out { out add attribute bounds out add attribute bounds out add attribute bounds width out add attribute bounds height } read dom input { read bounds read attributes text layout = } write dom output out { write bounds out write attributes out } text area figure clone { text area figure that = text area figure super clone that bounds = rectangle2 this bounds clone that } text holder get label for { this } restore to geometry { rectangle2 = rectangle2 geometry bounds = bounds = bounds width = width bounds height = height } get restore data { bounds clone } font get font { attribute keys get font this } color get text color { TEXT_COLOR get this } color get fill color { FILL_COLOR get this } set font size float size { FONT_SIZE set this new size } float get font size { FONT_SIZE get this float value } } 