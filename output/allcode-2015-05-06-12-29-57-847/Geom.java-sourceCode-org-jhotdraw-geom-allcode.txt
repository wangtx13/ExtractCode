org jhotdraw geom import awt * import awt geom * geom { private geom {} line contains point x1 y1 x2 y2 px py { line contains point x1 y1 x2 y2 px py 3d } line contains point x1 y1 x2 y2 px py tolerance { rectangle = new rectangle new point x1 y1 add x2 y2 grow math max 2 math ceil tolerance math max 2 math ceil tolerance if ! contains px py { } if x1 == x2 { math px - x1 <= tolerance } if y1 == y2 { math py - y1 <= tolerance } = y1 - y2 / x1 - x2 = y1 - * x1 = py - / = * px + math min math - px math - py <= tolerance } line contains point x1 y1 x2 y2 px py tolerance { rectangle2 = new rectangle2 x1 y1 0 0 add x2 y2 grow = math max 2 math ceil tolerance -= grow -= grow width += grow * 2 height += grow * 2 if ! contains px py { } if x1 == x2 { math px - x1 <= tolerance } if y1 == y2 { math py - y1 <= tolerance } = y1 - y2 / x1 - x2 = y1 - * x1 = py - / = * px + math min math - px math - py <= tolerance } OUT_TOP = rectangle2 OUT_TOP OUT_BOTTOM = rectangle2 OUT_BOTTOM OUT_LEFT = rectangle2 OUT_LEFT OUT_RIGHT = rectangle2 OUT_RIGHT direction x1 y1 x2 y2 { direction = 0 vx = x2 - x1 vy = y2 - y1 if vy < vx vx > -vy { direction = OUT_RIGHT } else if vy > vx vy > -vx { direction = OUT_TOP } else if vx < vy vx < -vy { direction = OUT_LEFT } else { direction = OUT_BOTTOM } direction } direction x1 y1 x2 y2 { direction = 0 vx = x2 - x1 vy = y2 - y1 if vy < vx vx > -vy { direction = OUT_RIGHT } else if vy > vx vy > -vx { direction = OUT_TOP } else if vx < vy vx < -vy { direction = OUT_LEFT } else { direction = OUT_BOTTOM } direction } outcode rectangle r1 rectangle r2 { outcode = 0 if r2 > r1 + r1 width outcode = OUT_RIGHT else if r2 + r2 width < r1 outcode = OUT_LEFT if r2 > r1 + r1 height outcode |= OUT_BOTTOM else if r2 + r2 height < r1 outcode |= OUT_TOP outcode } outcode rectangle2 r1 rectangle2 r2 { outcode = 0 if r2 > r1 + r1 width outcode = OUT_RIGHT else if r2 + r2 width < r1 outcode = OUT_LEFT if r2 > r1 + r1 height outcode |= OUT_BOTTOM else if r2 + r2 height < r1 outcode |= OUT_TOP outcode } point south rectangle { new point + width /2 + height } point2 south rectangle2 { new point2 + width /2 + height } point center rectangle { new point + width /2 + height/2 } point2 center rectangle2 { new point2 + width /2 + height/2 } point2 chop shape shape point2 { rectangle2 bounds = shape get bounds2 point2 ctr = new point2 bounds get center bounds get center cx = -1 cy = -1 len = MAX_VALUE path iterator = shape get path iterator new affine transform 1 coords = new 6 type = current segment coords prev = coords 0 prev = coords 1 move to = prev move to = prev next for ! done next { switch current segment coords { case path iterator SEG_MOVETO move to = coords 0 move to = coords 1 break case path iterator SEG_CLOSE coords 0 = move to coords 1 = move to break } point2 chop = geom intersect prev prev coords 0 coords 1 ctr ctr if chop != { = geom length2 chop chop if < len { len = cx = chop cy = chop } } prev = coords 0 prev = coords 1 } if len == MAX_VALUE { = shape get path iterator new affine transform 1 for ! done next { current segment coords = geom length2 ctr ctr coords 0 coords 1 if < len { len = cx = coords 0 cy = coords 1 } } } new point2 cx cy } point west rectangle { new point + height/ 2 } point2 west rectangle2 { new point2 + height/ 2 } point east rectangle { new point x+r width + height/ 2 } point2 east rectangle2 { new point2 x+r width + height/ 2 } point north rectangle { new point x+r width/2 } point2 north rectangle2 { new point2 x+r width/2 } range min max value { if value < min { value = min } if value > max { value = max } value } range min max value { if value < min { value = min } if value > max { value = max } value } long length2 x1 y1 x2 y2 { x2-x1 * x2-x1 + y2-y1 * y2-y1 } long length x1 y1 x2 y2 { long math sqrt length2 x1 y1 x2 y2 } length2 x1 y1 x2 y2 { x2-x1 * x2-x1 + y2-y1 * y2-y1 } length x1 y1 x2 y2 { math sqrt length2 x1 y1 x2 y2 } length point2 p1 point2 p2 { math sqrt length2 p1 p1 p2 p2 } point2 cap point2 p1 point2 p2 radius { angle = math i/2 - math atan2 p2 - p1 p2 - p1 point2 p3 = new point2 p2 + radius * math cos angle p2 + radius * math sin angle p3 } point to angle rectangle point { px = - + width/2 py = - + height/2 math atan2 py*r width px*r height } point to angle rectangle2 point2 { px = - + width/2 py = - + height/2 math atan2 py*r width px*r height } angle x1 y1 x2 y2 { math atan2 y2 - y1 x2 - x1 } point angle to point rectangle angle { = math sin angle = math cos angle = 0 0001 x= 0 y= 0 if math > { x= 1 0 + co/ math /2 0 * width x= range 0 width } else if >= 0 0 { x= width } if math > { y= 1 0 + si/ math /2 0 * height y= range 0 height } else if >= 0 0 { y= height } new point + + } point2 angle to point rectangle2 angle { = math sin angle = math cos angle = 0 0001 x= 0 = 0 if math > { x= 1 0 + co/ math /2 0 * width = range 0 width } else if >= 0 0 { = width } if math > { = 1 0 + si/ math /2 0 * height = range 0 height } else if >= 0 0 { = height } new point2 + + } point polar to point angle fx fy { = math sin angle = math cos angle new point fx*co+0 5 fy*si+0 5 } point2 polar to point2 angle fx fy { = math sin angle = math cos angle new point2 fx*co+0 5 fy*si+0 5 } point oval angle to point rectangle angle { point center = geom center point = geom polar to point angle width/2 height/2 new point center + center + } point2 oval angle to point rectangle2 angle { point2 center = geom center point2 = geom polar to point2 angle width/2 height/2 new point2 center + center + } point intersect xa ya xb yb yc xd yd { denom = xb - xa * yd - yc - yb - ya * xd - rnum = ya - yc * xd - - xa - * yd - yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < || xb < xd || xa > xb xb > || xb > xd { new point xb yb } else { new point xa ya } } else { } } = rnum / denom snum = ya - yc * xb - xa - xa - * yb - ya = snum / denom if 0 0 <= <= 1 0 0 0 <= <= 1 0 { px = xa + xb - xa * py = ya + yb - ya * new point px py } else { } } point2 intersect xa ya xb yb yc xd yd { denom = xb - xa * yd - yc - yb - ya * xd - rnum = ya - yc * xd - - xa - * yd - yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < || xb < xd || xa > xb xb > || xb > xd { new point2 xb yb } else { new point2 xa ya } } else { } } = rnum / denom snum = ya - yc * xb - xa - xa - * yb - ya = snum / denom if 0 0 <= <= 1 0 0 0 <= <= 1 0 { px = xa + xb - xa * py = ya + yb - ya * new point2 px py } else { } } point2 intersect xa ya xb yb yc xd yd limit { denom = xb - xa * yd - yc - yb - ya * xd - rnum = ya - yc * xd - - xa - * yd - yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < || xb < xd || xa > xb xb > || xb > xd { new point2 xb yb } else { new point2 xa ya } } else { } } = rnum / denom snum = ya - yc * xb - xa - xa - * yb - ya = snum / denom if 0 0 <= <= 1 0 0 0 <= <= 1 0 { px = xa + xb - xa * py = ya + yb - ya * new point2 px py } else { px = xa + xb - xa * py = ya + yb - ya * if length xa ya px py <= limit || length xb yb px py <= limit || length yc px py <= limit || length xd yd px py <= limit { new point2 px py } } } distance from line xa ya xb yb yc { xdiff = xb - xa ydiff = yb - ya long l2 = xdiff * xdiff + ydiff * ydiff if l2 == 0 { geom length xa ya yc } rnum = ya - yc * ya - yb - xa - * xb - xa = rnum / l2 if < 0 0 || > 1 0 { MAX_VALUE } = xa + * xdiff yi = ya + * ydiff xd = - yd = yc - yi math sqrt xd * xd + yd * yd } grow rectangle2 { -= -= width += * 2d height += * 2d } } 