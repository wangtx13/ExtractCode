nanoxml import * import util * xml element { long serial uid = 6685035139346394777 NANOXML_MAJOR_VERSION = 2 NANOXML_MINOR_VERSION = 2 private hash map attributes private list children private private contents private hash map entities private line nr private ignore case private ignore whitespace private char char read too much private reader reader private parser line nr private encode unicode characters = xml element { this new hash map } xml element hash map entities { this entities } xml element skip leading whitespace { this new hash map skip leading whitespace } xml element hash map entities skip leading whitespace { this entities skip leading whitespace } xml element hash map entities skip leading whitespace ignore case { this entities skip leading whitespace ignore case } xml element hash map entities skip leading whitespace fill basic conversion table ignore case { this entities skip leading whitespace fill basic conversion table ignore case } xml element hash map entities skip leading whitespace fill basic conversion table ignore case encode unicode characters { this ignore whitespace = skip leading whitespace this ignore case = ignore case this = this contents = this attributes = new hash map this children = new list this entities = entities this line nr = 0 this encode unicode characters = encode unicode characters iterator iter = this entities key set iterator while iter has next { key = iter next value = this entities get key if value instanceof { value = value to char this entities put key value } } if fill basic conversion table { this entities put amp new char { ' ' } this entities put new char { ' ' } this entities put apos new char { '\'' } this entities put lt new char { '<' } this entities put new char { '>' } } } add child xml element child { this children add child } set attribute value { if this ignore case { = to upper case } this attributes put value to } set attribute value { if this ignore case { = to upper case } this attributes put integer to value } set attribute value { if this ignore case { = to upper case } this attributes put to value } count children { this children size } iterator enumerate attribute names { this attributes key set iterator } iterator iterate children { this children iterator } list get children { try { list this children clone } catch { } } get content { this contents } get line nr { this line nr } get attribute { this get attribute } get attribute default value { if this ignore case { = to upper case } value = this attributes get if value == { value = default value } value } get attribute map value set default key allow literals { if this ignore case { = to upper case } key = this attributes get result if key == { key = default key } result = value set get key if result == { if allow literals { result = key } else { this invalid value key } } result } get attribute { this get attribute } get attribute default value { this get attribute default value } get attribute hash map value set default key allow literals { this get attribute value set default key allow literals } get attribute { this get attribute 0 } get attribute default value { if this ignore case { = to upper case } value = this attributes get if value == { default value } else { try { integer parse value } catch number format { this invalid value value } } } get attribute min max default value { = get attribute default value if < min min if > max max } get attribute hash map value set default key allow literal numbers { if this ignore case { = to upper case } key = this attributes get integer result if key == { key = default key } try { result = integer value set get key } catch cast { this invalid value set } if result == { if ! allow literal numbers { this invalid value key } try { result = integer value of key } catch number format { this invalid value key } } result value } get attribute { this get attribute 0 } get attribute default value { if this ignore case { = to upper case } value = this attributes get if value == { default value } else { try { value of value value } catch number format { this invalid value value } } } get attribute hash map value set default key allow literal numbers { if this ignore case { = to upper case } key = this attributes get result if key == { key = default key } try { result = value set get key } catch cast { this invalid value set } if result == { if ! allow literal numbers { this invalid value key } try { result = value of key } catch number format { this invalid value key } } result value } get attribute value value default value { if this ignore case { = to upper case } value = this attributes get if value == { default value } else if value equals value { } else if value equals value { } else { this invalid value value } } get attribute default value { get attribute default value } get { this } parse from reader reader reader xml parse { this parse from reader reader 1 } parse from reader reader reader starting line nr xml parse { this = this contents = this attributes = new hash map this children = new list this char read too much = '\0' this reader = reader this parser line nr = starting line nr for { char ch = this scan whitespace if ch != '<' { this expected input < } ch = this read char if ch == '!' || ch == '?' { this skip special tag 0 } else { this unread char ch this scan element this } } } parse xml parse { try { this parse from reader new reader 1 } catch { } } parse offset xml parse { this parse substring offset } parse offset xml parse { this parse substring offset } parse offset starting line nr xml parse { = substring offset try { this parse from reader new reader starting line nr } catch { } } parse char char input offset xml parse { this parse char input offset 1 } parse char char input offset starting line nr xml parse { try { reader reader = new char reader input offset this parse from reader reader starting line nr } catch { } } remove child xml element child { this children remove child } remove attribute { if this ignore case { = to upper case } this attributes remove } xml element create element { xml element elem = create element elem set elem } xml element create element { new xml element this entities this ignore whitespace this ignore case this encode unicode characters } set content content { this contents = content } set { this = } to { try { byte output stream out = new byte output stream output stream writer writer = new output stream writer out this write writer writer flush new out to byte } catch { super to } } write writer writer { if this == { this write encoded writer this contents } writer write '<' writer write this if ! this attributes empty { iterator iter = this attributes key set iterator while iter has next { writer write ' ' key = iter next value = this attributes get key writer write key writer write '=' writer write ' ' this write encoded writer value writer write ' ' } } if this contents != this contents length > 0 { writer write '>' this write encoded writer this contents writer write '<' writer write '/' writer write this writer write '>' } else if this children empty { writer write '/' writer write '>' } else { writer write '>' iterator iter = this iterate children while iter has next { xml element child = xml element iter next child write writer } writer write '<' writer write '/' writer write this writer write '>' } } writer writer { writer 0 } writer writer indent { try { if this == { this write encoded writer this contents } char spaces = new char indent * 2 arrays fill spaces ' ' writer write spaces writer write '<' writer write this if ! this attributes empty { iterator enm = this attributes key set iterator while enm has next { writer write ' ' key = enm next value = this attributes get key writer write key writer write '=' writer write ' ' this write encoded writer value writer write ' ' } } if this contents != this contents length > 0 { writer write '>' this write encoded writer this contents writer write '<' writer write '/' writer write this writer write '>' } else if this children empty { writer write '/' writer write '>' } else { writer write '>' writer write '\n' iterator enm = this get children iterator while enm has next { xml element child = xml element enm next child writer indent + 1 } writer write spaces writer write '<' writer write '/' writer write this writer write '>' } writer write '\n' } catch { internal = new internal get message init cause } } write encoded writer writer { for = 0 < length += 1 { char ch = char switch ch { case '<' writer write ' ' writer write 'l' writer write 't' writer write ' ' break case '>' writer write ' ' writer write 'g' writer write 't' writer write ' ' break case ' ' writer write ' ' writer write 'a' writer write 'm' writer write 'p' writer write ' ' break case ' ' writer write ' ' writer write 'q' writer write 'u' writer write 'o' writer write 't' writer write ' ' break case '\'' writer write ' ' writer write 'a' writer write 'p' writer write 'o' writer write 's' writer write ' ' break default unicode = ch if unicode < 32 || encode unicode characters unicode > 126 { writer write ' ' writer write '#' writer write 'x' writer write integer to unicode 16 writer write ' ' } else { writer write ch } } } } scan identifier buffer result { for { char ch = this read char if ch < ' a' || ch > ' z' ch < 'a' || ch > 'z' ch < '0' || ch > '9' ch != '_' ch != ' ' ch != ' ' ch != '-' ch <= '\u007 e' { this unread char ch } result append ch } } char scan whitespace { for { char ch = this read char switch ch { case ' ' case '\t' case '\n' case '\r' break default ch } } } char scan whitespace buffer result { for { char ch = this read char switch ch { case ' ' case '\t' case '\n' result append ch case '\r' break default ch } } } scan buffer { char delimiter = this read char if delimiter != '\'' delimiter != ' ' { this expected input ' \ } for { char ch = this read char if ch == delimiter { } else if ch == ' ' { this resolve entity } else { append ch } } } scan data buffer data { for { char ch = this read char if ch == '<' { ch = this read char if ch == '!' { this check data } else { this unread char ch } } else if ch == ' ' { this resolve entity data } else { data append ch } } } check buffer buf { char ch = this read char if ch != ' ' { this unread char ch this skip special tag 0 } else if ! this check literal { this skip special tag 1 } else { delimiter chars skipped = 0 while delimiter chars skipped < 3 { ch = this read char switch ch { case ' ' if delimiter chars skipped < 2 { delimiter chars skipped += 1 } else { buf append ' ' buf append ' ' delimiter chars skipped = 0 } break case '>' if delimiter chars skipped < 2 { for = 0 < delimiter chars skipped i++ { buf append ' ' } delimiter chars skipped = 0 buf append '>' } else { delimiter chars skipped = 3 } break default for = 0 < delimiter chars skipped += 1 { buf append ' ' } buf append ch delimiter chars skipped = 0 } } } } skip comment { dashes to read = 2 while dashes to read > 0 { char ch = this read char if ch == '-' { dashes to read -= 1 } else { dashes to read = 2 } } if this read char != '>' { this expected input > } } skip special tag bracket level { tag level = 1 char delimiter = '\0' if bracket level == 0 { char ch = this read char if ch == ' ' { bracket level += 1 } else if ch == '-' { ch = this read char if ch == ' ' { bracket level += 1 } else if ch == ' ' { bracket level -= 1 } else if ch == '-' { this skip comment } } } while tag level > 0 { char ch = this read char if delimiter == '\0' { if ch == ' ' || ch == '\'' { delimiter = ch } else if bracket level <= 0 { if ch == '<' { tag level += 1 } else if ch == '>' { tag level -= 1 } } if ch == ' ' { bracket level += 1 } else if ch == ' ' { bracket level -= 1 } } else { if ch == delimiter { delimiter = '\0' } } } } check literal literal { length = literal length for = 0 < length += 1 { if this read char != literal char { } } } char read char { if this char read too much != '\0' { char ch = this char read too much this char read too much = '\0' ch } else { = this reader read if < 0 { this unexpected of data } else if == 10 { this parser line nr += 1 '\n' } else { char } } } scan element xml element elt { buffer buf = new buffer this scan identifier buf = buf to elt set char ch = this scan whitespace while ch != '>' ch != '/' { buf set length 0 this unread char ch this scan identifier buf key = buf to ch = this scan whitespace if ch != '=' { this expected input = } this unread char this scan whitespace buf set length 0 this scan buf elt set attribute key buf ch = this scan whitespace } if ch == '/' { ch = this read char if ch != '>' { this expected input > } } buf set length 0 ch = this scan whitespace buf if ch != '<' { this unread char ch this scan data buf } else { for { ch = this read char if ch == '!' { if this check buf { this scan data buf break } else { ch = this scan whitespace buf if ch != '<' { this unread char ch this scan data buf break } } } else { if ch != '/' || this ignore whitespace { buf set length 0 } if ch == '/' { this unread char ch } break } } } if buf length == 0 { while ch != '/' { if ch == '!' { ch = this read char if ch != '-' { this expected input comment element } ch = this read char if ch != '-' { this expected input comment element } this skip comment } else { this unread char ch xml element child = this create element this scan element child elt add child child } ch = this scan whitespace if ch != '<' { this expected input < } ch = this read char } this unread char ch } else { if this ignore whitespace { elt set content buf to trim } else { elt set content buf to } } ch = this read char if ch != '/' { this expected input / } this unread char this scan whitespace if ! this check literal { this expected input } if this scan whitespace != '>' { this expected input > } } resolve entity buffer buf { char ch = '\0' buffer key buf = new buffer for { ch = this read char if ch == ' ' { break } key buf append ch } key = key buf to if key char 0 == '#' { try { if key char 1 == 'x' { ch = char integer parse key substring 2 16 } else { ch = char integer parse key substring 1 10 } } catch number format { this unknown entity key } buf append ch } else { char value = char this entities get key if value == { this unknown entity key } buf append value } } unread char char ch { this char read too much = ch } xml parse invalid value set { msg = invalid value set entity = \ + + \ new xml parse this get this parser line nr msg } xml parse invalid value value { msg = attribute \ + + \ does not contain valid + value \ + value + \ new xml parse this get this parser line nr msg } xml parse unexpected of data { msg = unexpected of data reached new xml parse this get this parser line nr msg } xml parse syntax context { msg = syntax while parsing + context new xml parse this get this parser line nr msg } xml parse expected input char set { msg = expected + char set new xml parse this get this parser line nr msg } xml parse unknown entity { msg = unknown invalid entity + + new xml parse this get this parser line nr msg } } 