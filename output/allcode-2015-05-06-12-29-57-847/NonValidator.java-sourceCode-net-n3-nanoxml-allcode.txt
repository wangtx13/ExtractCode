net n3 nanoxml import reader import import reader import util enumeration import util hashtable import util properties import util stack non validator implements xml validator { xml entity resolver entity resolver hashtable attribute default values stack current elements non validator { this attribute default values = new hashtable this current elements = new stack this entity resolver = new xml entity resolver } finalize throwable { this entity resolver = this attribute default values clear this attribute default values = this current elements clear this current elements = super finalize } set entity resolver xml entity resolver resolver { this entity resolver = resolver } xml entity resolver get entity resolver { this entity resolver } parse publicid xml reader reader xml entity resolver entity resolver external { xml util skip whitespace reader orig level = reader get stream level for { = xml util read reader '%' char ch = char 0 if ch == '%' { xml util process entity reader this entity resolver continue } else if ch == '<' { this process element reader entity resolver } else if ch == ' ' { } else { xml util invalid input reader get systemid reader get line nr } { ch = reader read if external reader get stream level < orig level { reader unread ch } } while ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r' reader unread ch } } process element xml reader reader xml entity resolver entity resolver { = xml util read reader '%' char ch = char 0 if ch != '!' { xml util skip tag reader } = xml util read reader '%' ch = char 0 switch ch { case '-' xml util skip comment reader break case ' ' this process conditional section reader entity resolver break case ' e' this process entity reader entity resolver break case ' a' this process att list reader entity resolver break default xml util skip tag reader } } process conditional section xml reader reader xml entity resolver entity resolver { xml util skip whitespace reader = xml util read reader '%' char ch = char 0 if ch != ' i' { xml util skip tag reader } = xml util read reader '%' ch = char 0 switch ch { case ' g' this process ignore section reader entity resolver case ' n' break default xml util skip tag reader } if ! xml util check literal reader { xml util skip tag reader } xml util skip whitespace reader = xml util read reader '%' ch = char 0 if ch != ' ' { xml util skip tag reader } reader subreader = new reader reader buffer buf = new buffer 1024 for { ch2 = subreader read if ch2 < 0 { break } buf append char ch2 } subreader close reader start new stream new reader buf to } process ignore section xml reader reader xml entity resolver entity resolver { if ! xml util check literal reader { xml util skip tag reader } xml util skip whitespace reader = xml util read reader '%' char ch = char 0 if ch != ' ' { xml util skip tag reader } reader subreader = new reader reader subreader close } process att list xml reader reader xml entity resolver entity resolver { if ! xml util check literal reader { xml util skip tag reader } xml util skip whitespace reader = xml util read reader '%' char ch = char 0 while ch == '%' { xml util process entity reader this entity resolver = xml util read reader '%' ch = char 0 } reader unread ch element = xml util scan identifier reader xml util skip whitespace reader = xml util read reader '%' ch = char 0 while ch == '%' { xml util process entity reader this entity resolver = xml util read reader '%' ch = char 0 } properties props = new properties while ch != '>' { reader unread ch att = xml util scan identifier reader xml util skip whitespace reader = xml util read reader '%' ch = char 0 while ch == '%' { xml util process entity reader this entity resolver = xml util read reader '%' ch = char 0 } if ch == ' ' { while ch != ' ' { = xml util read reader '%' ch = char 0 while ch == '%' { xml util process entity reader this entity resolver = xml util read reader '%' ch = char 0 } } } else { reader unread ch xml util scan identifier reader } xml util skip whitespace reader = xml util read reader '%' ch = char 0 while ch == '%' { xml util process entity reader this entity resolver = xml util read reader '%' ch = char 0 } if ch == '#' { = xml util scan identifier reader xml util skip whitespace reader if ! equals { xml util skip whitespace reader = xml util read reader '%' ch = char 0 while ch == '%' { xml util process entity reader this entity resolver = xml util read reader '%' ch = char 0 } continue } } else { reader unread ch } value = xml util scan reader '%' this entity resolver props put att value xml util skip whitespace reader = xml util read reader '%' ch = char 0 while ch == '%' { xml util process entity reader this entity resolver = xml util read reader '%' ch = char 0 } } if ! props empty { this attribute default values put element props } } process entity xml reader reader xml entity resolver entity resolver { if ! xml util check literal reader { xml util skip tag reader } xml util skip whitespace reader char ch = xml util read char reader '\0' if ch == '%' { xml util skip whitespace reader entity resolver = this entity resolver } else { reader unread ch } key = xml util scan identifier reader xml util skip whitespace reader ch = xml util read char reader '%' systemid = publicid = switch ch { case ' p' if ! xml util check literal reader { xml util skip tag reader } xml util skip whitespace reader publicid = xml util scan reader '%' this entity resolver xml util skip whitespace reader systemid = xml util scan reader '%' this entity resolver xml util skip whitespace reader xml util read char reader '%' break case ' s' if ! xml util check literal reader { xml util skip tag reader } xml util skip whitespace reader systemid = xml util scan reader '%' this entity resolver xml util skip whitespace reader xml util read char reader '%' break case ' ' case '\'' reader unread ch value = xml util scan reader '%' this entity resolver entity resolver add internal entity key value xml util skip whitespace reader xml util read char reader '%' break default xml util skip tag reader } if systemid != { entity resolver add external entity key publicid systemid } } element started line nr { properties attribs = properties this attribute default values get if attribs == { attribs = new properties } else { attribs = properties attribs clone } this current elements push attribs } element ended line nr { } element attributes processed properties extra attributes line nr { properties props = properties this current elements pop enumeration enm = props keys while enm has more elements { key = enm next element extra attributes put key props get key } } attribute added key value line nr { properties props = properties this current elements peek if props contains key key { props remove key } } data added line nr { } } 