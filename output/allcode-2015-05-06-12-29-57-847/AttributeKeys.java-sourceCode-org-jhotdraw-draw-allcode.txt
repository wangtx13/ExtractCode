org jhotdraw draw import awt * import util * import org jhotdraw geom * attribute keys { attribute key< color> FILL_COLOR = new attribute key< color> fill color color white enum winding rule { EVEN_ODD NON_ZERO } attribute key< winding rule> WINDING_RULE = new attribute key< winding rule> winding rule winding rule EVEN_ODD enum underfill { } attribute key< underfill> FILL_UNDER_STROKE = new attribute key< underfill> fill under stroke underfill attribute key< color> STROKE_COLOR = new attribute key< color> stroke color color black attribute key< double> STROKE_WIDTH = new attribute key< double> stroke width 1d attribute key< double> STROKE_INNER_WIDTH_FACTOR = new attribute key< double> inner stroke width factor 2d attribute key< integer> STROKE_JOIN = new attribute key< integer> stroke join basic stroke JOIN_MITER attribute key< integer> STROKE_CAP = new attribute key< integer> stroke cap basic stroke CAP_BUTT attribute key< double> STROKE_MITER_LIMIT_FACTOR = new attribute key< double> stroke miter limit factor 3d attribute key<double > STROKE_DASHES = new attribute key<double > stroke dashes attribute key< double> STROKE_DASH_PHASE = new attribute key< double> stroke dash phase 0d attribute key< double> STROKE_DASH_FACTOR = new attribute key< double> stroke dash factor enum stroke type { } attribute key< stroke type> STROKE_TYPE = new attribute key< stroke type> stroke type stroke type enum stroke placement { sid sid } attribute key< stroke placement> STROKE_PLACEMENT = new attribute key< stroke placement> stroke placement stroke placement attribute key< string> = new attribute key< string> text attribute key< color> TEXT_COLOR = new attribute key< color> text color color black attribute key< color> TEXT_SHADOW_COLOR = new attribute key< color> text shadow color attribute key< dimension2 double> TEXT_SHADOW_OFFSET = new attribute key< dimension2 double> text shadow offset new dimension2 1d 1d attribute key< font> FONT_FACE = new attribute key< font> font new font font 10 attribute key< double> FONT_SIZE = new attribute key< double> font size 12d attribute key< boolean> FONT_BOLD = new attribute key< boolean> font bold attribute key< boolean> FONT_ITALIC = new attribute key< boolean> font italic attribute key< boolean> FONT_UNDERLINED = new attribute key< boolean> font underlined attribute key< liner> BEZIER_PATH_LAYOUTER = new attribute key< liner> bezier path layouter attribute key< line decoration> END_DECORATION = new attribute key< line decoration> decoration attribute key< line decoration> START_DECORATION = new attribute key< line decoration> start decoration attribute key< insets2 double> DECORATOR_INSETS = new attribute key< insets2 double> decorator insets new insets2 0 0 0 0 attribute key< insets2 double> LAYOUT_INSETS = new attribute key< insets2 double> border insets new insets2 0 0 0 0 enum orientation { NORTH_EAST SOUTH_EAST SOUTH_WEST NORTH_WEST } attribute key< orientation> = new attribute key< orientation> orientation orientation set< attribute key> supported attributes map< attribute key> supported attribute map { hash set< attribute key> = new hash set< attribute key> add all arrays list new attribute key { FILL_COLOR FILL_UNDER_STROKE STROKE_COLOR STROKE_WIDTH STROKE_INNER_WIDTH_FACTOR STROKE_JOIN STROKE_CAP STROKE_MITER_LIMIT_FACTOR STROKE_DASHES STROKE_DASH_PHASE STROKE_TYPE STROKE_PLACEMENT TEXT_COLOR TEXT_SHADOW_COLOR TEXT_SHADOW_OFFSET FONT_FACE FONT_SIZE FONT_BOLD FONT_ITALIC FONT_UNDERLINED BEZIER_PATH_LAYOUTER END_DECORATION START_DECORATION DECORATOR_INSETS WINDING_RULE } supported attributes = collections unmodifiable set hash map< attribute key> = new hash map< attribute key> for attribute key { put get key } supported attribute map = collections unmodifiable map } get stroke total width figure { switch STROKE_TYPE get { case default STROKE_WIDTH get case STROKE_WIDTH get * 1d + STROKE_INNER_WIDTH_FACTOR get } } stroke get stroke figure { stroke width = STROKE_WIDTH get dash factor = STROKE_DASH_FACTOR get != ? STROKE_DASH_FACTOR get stroke width ddashes = STROKE_DASHES get float dashes = if ddashes != { dashes = new float ddashes length for i=0 < dashes length i++ { dashes = float ddashes * dash factor } } switch STROKE_TYPE get { case default new basic stroke float stroke width basic stroke CAP_BUTT STROKE_JOIN get math max 1f float STROKE_MITER_LIMIT_FACTOR get * stroke width dashes float STROKE_DASH_PHASE get * dash factor case new stroke float STROKE_INNER_WIDTH_FACTOR get * stroke width float stroke width basic stroke CAP_BUTT STROKE_JOIN get math max 1f float STROKE_MITER_LIMIT_FACTOR get * stroke width dashes float STROKE_DASH_PHASE get float value * dash factor } } font get font figure { font prototype = FONT_FACE get if prototype == { } if get font style != font { prototype derive font get font style FONT_SIZE get float value } else { prototype derive font FONT_SIZE get float value } } get font style figure { style = font if FONT_BOLD get style |= font if FONT_ITALIC get style |= font style } get perpendicular fill growth figure { grow stroke width = attribute keys get stroke total width stroke placement placement = STROKE_PLACEMENT get switch FILL_UNDER_STROKE get { case switch placement { case sid grow = 0f break case sid grow = stroke width break case default grow = stroke width / 2d break } break case switch placement { case sid grow = -stroke width break case sid grow = 0f break case default grow = stroke width / -2d break } break case default switch placement { case sid grow = stroke width / -2d break case sid grow = stroke width / 2d break case default grow = 0d break } break } grow } get perpendicular draw growth figure { grow stroke width = attribute keys get stroke total width stroke placement placement = STROKE_PLACEMENT get switch placement { case sid grow = stroke width / -2d break case sid grow = stroke width / 2d break case default grow = 0f break } grow } get perpendicular hit growth figure { grow if STROKE_COLOR get == { grow = get perpendicular fill growth } else { stroke width = attribute keys get stroke total width grow = get perpendicular draw growth + stroke width / 2d } grow } } 