net n3 nanoxml import IOException import OutputStream output stream import PrintWriter writer import writer import util iterator import util vector XMLWriter xml writer { private PrintWriter writer writer XMLWriter xml writer writer writer { if writer instanceof PrintWriter writer { this writer = PrintWriter writer writer } else { this writer = new PrintWriter writer writer } } XMLWriter xml writer OutputStream output stream stream { this writer = new PrintWriter writer stream } finalize throwable { this writer = super finalize } write IXMLElement xml element xml IOException { this write xml 0 } write IXMLElement xml element xml prettyPrint pretty IOException { this write xml prettyPrint pretty 0 } write IXMLElement xml element xml prettyPrint pretty indent IOException { this write xml prettyPrint pretty indent } write IXMLElement xml element xml prettyPrint pretty indent collapseEmptyElements collapse empty elements IOException { if prettyPrint pretty { for = 0 < indent i++ { this writer ' ' } } if xml getName get == { if xml getContent get content != { if prettyPrint pretty { this writeEncoded write encoded xml getContent get content trim writer } else { this writeEncoded write encoded xml getContent get content } } } else { this writer '<' this writer xml getFullName get full vector nsprefixes = new vector if xml getNamespace get namespace != { if xml getName get equals xml getFullName get full { this writer xmlns=\ + xml getNamespace get namespace + ' ' } else { prefix = xml getFullName get full prefix = prefix substring 0 prefix indexOf index of ' ' nsprefixes addElement add element prefix this writer xmlns + prefix this writer =\ + xml getNamespace get namespace + \ } } iterator enm = xml iterateAttributeNames iterate attribute names while enm hasNext has next { key = enm next index = key indexOf index of ' ' if index >= 0 { namespace = xml getAttributeNamespace get attribute namespace key if namespace != { prefix = key substring 0 index if ! nsprefixes contains prefix { this writer xmlns + prefix this writer =\ + namespace + ' ' nsprefixes addElement add element prefix } } } } enm = xml iterateAttributeNames iterate attribute names while enm hasNext has next { key = enm next value = xml getAttribute get attribute key this writer + key + =\ this writeEncoded write encoded value this writer ' ' } if xml getContent get content != xml getContent get content length > 0 { writer '>' this writeEncoded write encoded xml getContent get content writer </ + xml getFullName get full + '>' if prettyPrint pretty { writer } } else if xml hasChildren has children || ! collapseEmptyElements collapse empty elements { writer '>' if prettyPrint pretty { writer } enm = xml iterateChildren iterate children while enm hasNext has next { IXMLElement xml element child = IXMLElement xml element enm next this write child prettyPrint pretty indent + 4 collapseEmptyElements collapse empty elements } if prettyPrint pretty { for = 0 < indent i++ { this writer ' ' } } this writer </ + xml getFullName get full + > if prettyPrint pretty { writer } } else { this writer /> if prettyPrint pretty { writer } } } this writer flush } private writeEncoded write encoded { for = 0 < length i++ { char = charAt char switch { case 0x0A 0x0 this writer break case '<' this writer lt break case '>' this writer break case ' ' this writer amp break case '\'' this writer apos break case ' ' this writer break default if < ' ' || > 0x7E 0x7 { this writer #x this writer integer toString to 16 this writer ' ' } else { this writer } } } } } 