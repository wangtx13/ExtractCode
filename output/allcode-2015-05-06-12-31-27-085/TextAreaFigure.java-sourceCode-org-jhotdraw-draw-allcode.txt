org jhotdraw draw import org jhotdraw util * import awt * import awt font * import awt geom * import text * import util * import * import org jhotdraw draw AttributeKeys attribute keys * import org jhotdraw geom * import org jhotdraw xml DOMInput dom input import org jhotdraw xml DOMOutput dom output TextAreaFigure text area figure AttributedFigure attributed figure implements TextHolder text holder { private Rectangle2D rectangle2 bounds = new Rectangle2D rectangle2 private editable = private BasicStroke basic stroke dashes = new BasicStroke basic stroke 1f BasicStroke basic stroke CAP_BUTT BasicStroke basic stroke JOIN_BEVEL 0f new float {4f 4f} 0f transient private TextLayout text layout textLayout text layout TextAreaFigure text area figure { this text } TextAreaFigure text area figure text { setText set text text } getText get text { getAttribute get attribute TEXT } setText set text newText new text { setAttribute set attribute TEXT newText new text } basicSetBounds basic set bounds Point2D point2 anchor Point2D point2 { bounds = math min anchor bounds = math min anchor bounds width = math max 1 math - anchor bounds height = math max 1 math - anchor textLayout text layout = } basicTransform basic transform AffineTransform affine transform tx { Point2D point2 anchor = getStartPoint get start point Point2D point2 = getEndPoint get point basicSetBounds basic set bounds Point2D point2 tx transform anchor anchor Point2D point2 tx transform } contains Point2D point2 { bounds contains } Insets2DDouble insets2 getInsets get insets { sw = math ceil STROKE_WIDTH get this / 2 Insets2DDouble insets2 insets = new Insets2DDouble insets2 4 4 4 4 new Insets2DDouble insets2 insets top+sw insets left+sw insets bottom+sw insets right+sw } getTabSize get tab size { 8 } drawText draw text Graphics2D graphics2 { if getText get text != || isEditable editable { font font = getFont get font isUnderlined underlined = FONT_UNDERLINED get this Insets2DDouble insets2 insets = getInsets get insets Rectangle2D rectangle2 textRect text rect = new Rectangle2D rectangle2 bounds + insets left bounds + insets top bounds width - insets left - insets right bounds height - insets top - insets bottom float leftMargin left margin = float textRect text rect float rightMargin right margin = float math max leftMargin left margin + 1 textRect text rect + textRect text rect width float verticalPos vertical pos = float textRect text rect if leftMargin left margin < rightMargin right margin { float tabWidth tab width = float getTabSize get tab size * getFontMetrics get font metrics font charWidth char width 'm' float tabStops tab stops = new float textRect text rect width / tabWidth tab width for i=0 < tabStops tab stops length i++ { tabStops tab stops = float textRect text rect + tabWidth tab width * + 1 } if getText get text != { shape savedClipArea saved clip area = getClip get clip clip textRect text rect paragraphs = getText get text split \n for = 0 < paragraphs length i++ { if paragraphs length == 0 paragraphs = AttributedString attributed = new AttributedString attributed paragraphs addAttribute add attribute TextAttribute text attribute FONT font if isUnderlined underlined { addAttribute add attribute TextAttribute text attribute UNDERLINE TextAttribute text attribute UNDERLINE_LOW_ONE_PIXEL } tabCount tab count = new StringTokenizer tokenizer paragraphs \t countTokens count tokens - 1 verticalPos vertical pos = drawParagraph draw paragraph getIterator get iterator verticalPos vertical pos leftMargin left margin rightMargin right margin tabStops tab stops tabCount tab count if verticalPos vertical pos > textRect text rect + textRect text rect height { break } } setClip set clip savedClipArea saved clip area } } if leftMargin left margin >= rightMargin right margin || verticalPos vertical pos > textRect text rect + textRect text rect height { setColor set color color red setStroke set stroke dashes draw new Line2D line2 textRect text rect textRect text rect + textRect text rect height - 1 textRect text rect + textRect text rect width - 1 textRect text rect + textRect text rect height - 1 } } } private float drawParagraph draw paragraph Graphics2D graphics2 AttributedCharacterIterator attributed character iterator styledText styled text float verticalPos vertical pos float leftMargin left margin float rightMargin right margin float tabStops tab stops tabCount tab count { tabLocations tab locations = new tabCount+1 tab count+1 = 0 for char = styledText styled text first != styledText styled text DONE = styledText styled text next { if == '\t' { tabLocations tab locations i++ = styledText styled text getIndex get index } } tabLocations tab locations tabCount tab count = styledText styled text getEndIndex get index - 1 LineBreakMeasurer line break measurer measurer = new LineBreakMeasurer line break measurer styledText styled text getFontRenderContext get font render context currentTab current tab = 0 while measurer getPosition get position < styledText styled text getEndIndex get index { lineContainsText line contains text = lineComplete line complete = float maxAscent max ascent = 0 maxDescent max descent = 0 float horizontalPos horizontal pos = leftMargin left margin LinkedList<TextLayout> linked list< text layout> layouts = new LinkedList<TextLayout> linked list< text layout> LinkedList<Float> linked list< float> penPositions pen positions = new LinkedList<Float> linked list< float> while !lineComplete !line complete { float wrappingWidth wrapping width = rightMargin right margin - horizontalPos horizontal pos TextLayout text layout layout = layout = measurer nextLayout next layout wrappingWidth wrapping width tabLocations tab locations currentTab current tab +1 lineContainsText line contains text if layout != { layouts add layout penPositions pen positions add horizontalPos horizontal pos horizontalPos horizontal pos += layout getAdvance get advance maxAscent max ascent = math max maxAscent max ascent layout getAscent get ascent maxDescent max descent = math max maxDescent max descent layout getDescent get descent + layout getLeading get leading } else { lineComplete line complete = } lineContainsText line contains text = if measurer getPosition get position == tabLocations tab locations currentTab current tab +1 { currentTab++ current tab++ } if measurer getPosition get position == styledText styled text getEndIndex get index lineComplete line complete = else if tabStops tab stops length == 0 || horizontalPos horizontal pos >= tabStops tab stops tabStops tab stops length-1 lineComplete line complete = if !lineComplete !line complete { for j=0 horizontalPos horizontal pos >= tabStops tab stops j++ {} horizontalPos horizontal pos = tabStops tab stops } } verticalPos vertical pos += maxAscent max ascent Iterator<TextLayout> iterator< text layout> layoutEnum layout enum = layouts iterator Iterator<Float> iterator< float> positionEnum position enum = penPositions pen positions iterator while layoutEnum layout enum hasNext has next { TextLayout text layout nextLayout next layout = layoutEnum layout enum next float nextPosition next position = positionEnum position enum next nextLayout next layout draw nextPosition next position verticalPos vertical pos } verticalPos vertical pos += maxDescent max descent } verticalPos vertical pos } drawFill draw fill Graphics2D graphics2 { fill bounds } drawStroke draw stroke Graphics2D graphics2 { draw bounds } Rectangle2D rectangle2 getBounds get bounds { Rectangle2D rectangle2 bounds getBounds2D get bounds2 } Collection<Handle> collection< handle> createHandles create handles detailLevel detail level { LinkedList<Handle> linked list< handle> handles = LinkedList<Handle> linked list< handle> super createHandles create handles detailLevel detail level if detailLevel detail level == 0 { handles add new FontSizeHandle font size handle this } handles } validate { super validate textLayout text layout = } isEditable editable { editable } setEditable set editable { this editable = } getTextColumns get text columns { getText get text == ? 4 math max getText get text length 4 } tool getTool get tool Point2D point2 { isEditable editable contains ? new TextAreaTool text area tool this } readBounds read bounds DOMInput dom input IOException { bounds = getAttribute get attribute 0d bounds = getAttribute get attribute 0d bounds width = getAttribute get attribute 0d bounds height = getAttribute get attribute 0d } writeBounds write bounds DOMOutput dom output out IOException { out addAttribute add attribute bounds out addAttribute add attribute bounds out addAttribute add attribute bounds width out addAttribute add attribute bounds height } read DOMInput dom input IOException { readBounds read bounds readAttributes read attributes textLayout text layout = } write DOMOutput dom output out IOException { writeBounds write bounds out writeAttributes write attributes out } TextAreaFigure text area figure clone { TextAreaFigure text area figure that = TextAreaFigure text area figure super clone that bounds = Rectangle2D rectangle2 this bounds clone that } TextHolder text holder getLabelFor get label for { this } restoreTo restore to geometry { Rectangle2D rectangle2 = Rectangle2D rectangle2 geometry bounds = bounds = bounds width = width bounds height = height } getRestoreData get restore data { bounds clone } font getFont get font { AttributeKeys attribute keys getFont get font this } color getTextColor get text color { TEXT_COLOR get this } color getFillColor get fill color { FILL_COLOR get this } setFontSize set font size float size { FONT_SIZE set this new size } float getFontSize get font size { FONT_SIZE get this floatValue float value } } 