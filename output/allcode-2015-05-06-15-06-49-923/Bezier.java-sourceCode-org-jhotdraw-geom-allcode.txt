org jhotdraw geom import org jhotdraw util * import awt * import awt geom * bezier { private maxpoints m a x p o i n t s = 1000 private bezier { } args { point2d point2 d d = {	 new point2d point2 d 0 0 0 0 new point2d point2 d 0 0 0 5 new point2d point2 d 1 1 1 4 new point2d point2 d 2 1 1 6 new point2d point2 d 3 2 1 1 new point2d point2 d 4 0 0 2 new point2d point2 d 4 0 0 0 } double	error = 4 0 		 generalpath general path path = fitcurve fit curve d 	 out path } generalpath general path fitcurve fit curve polygon p { point2d point2 d d = new point2d point2 d p npoints for i=0 i < d length i++ { d i = new point2d point2 d p xpoints i p ypoints i } fitcurve fit curve d } generalpath general path fitcurve fit curve point2d point2 d d { point2d point2 d that1 t hat1 = new point2d point2 d point2d point2 d that2 t hat2 = new point2d point2 d generalpath general path bezierpath bezier path = new generalpath general path bezierpath bezier path moveto move to float d 0 x float d 0 y that1 t hat1 = computelefttangent compute left tangent d 0 that2 t hat2 = computerighttangent compute right tangent d d length 1 fitcubic fit cubic d 0 d length 1 that1 t hat1 that2 t hat2 bezierpath bezier path bezierpath bezier path } bezierpath bezier path fitbeziercurve fit bezier curve bezierpath bezier path path { point2d point2 d d = path topolygonarray to polygon point2d point2 d that1 t hat1 = new point2d point2 d point2d point2 d that2 t hat2 = new point2d point2 d bezierpath bezier path bezierpath bezier path = new bezierpath bezier path bezierpath bezier path add new bezierpath bezier path node d 0 that1 t hat1 = computelefttangent compute left tangent d 0 that2 t hat2 = computerighttangent compute right tangent d d length 1 fitcubic fit cubic d 0 d length 1 that1 t hat1 that2 t hat2 bezierpath bezier path bezierpath bezier path setclosed set closed path isclosed is closed bezierpath bezier path } private fitcubic fit cubic point2d point2 d d first last point2d point2 d that1 t hat1 point2d point2 d that2 t hat2 generalpath general path bezierpath bezier path { point2d point2 d bezcurve bez curve u 		 uprime u prime 	 double	maxerror double	max 	 	splitpoint 	split point = new 1 int	npts int	n pts 		 double	iterationerror double	iteration int	maxiterations int	max iterations = 4 point2d point2 d double	thatcenter double	t hat center = new point2d point2 d int	i iterationerror iteration = * npts n pts = last first + 1 if npts n pts == 2 { dist = v2distancebetween2points v2 distance between2 points d last d first / 3 0 bezcurve bez curve = new point2d point2 d 4 for i=0 i < bezcurve bez curve length i++ { bezcurve bez curve i = new point2d point2 d } bezcurve bez curve 0 = d first bezcurve bez curve 3 = d last v2add v2 add bezcurve bez curve 0 v2scale v2 scale that1 t hat1 dist bezcurve bez curve 1 v2add v2 add bezcurve bez curve 3 v2scale v2 scale that2 t hat2 dist bezcurve bez curve 2 bezierpath bezier path curveto curve to float bezcurve bez curve 1 x float bezcurve bez curve 1 y float bezcurve bez curve 2 x float bezcurve bez curve 2 y float bezcurve bez curve 3 x float bezcurve bez curve 3 y } u = chordlengthparameterize chord length parameterize d first last bezcurve bez curve = generatebezier generate bezier d first last u that1 t hat1 that2 t hat2 maxerror max = computemaxerror compute max d first last bezcurve bez curve u splitpoint split point if maxerror max < { bezierpath bezier path curveto curve to float bezcurve bez curve 1 x float bezcurve bez curve 1 y float bezcurve bez curve 2 x float bezcurve bez curve 2 y float bezcurve bez curve 3 x float bezcurve bez curve 3 y } if maxerror max < iterationerror iteration { for i = 0 i < maxiterations max iterations i++ { uprime u prime = reparameterize d first last u bezcurve bez curve bezcurve bez curve = generatebezier generate bezier d first last uprime u prime that1 t hat1 that2 t hat2 maxerror max = computemaxerror compute max d first last bezcurve bez curve uprime u prime splitpoint split point if maxerror max < { bezierpath bezier path curveto curve to float bezcurve bez curve 1 x float bezcurve bez curve 1 y float bezcurve bez curve 2 x float bezcurve bez curve 2 y float bezcurve bez curve 3 x float bezcurve bez curve 3 y } u = uprime u prime } } thatcenter t hat center = computecentertangent compute center tangent d splitpoint split point 0 fitcubic fit cubic d first splitpoint split point 0 that1 t hat1 thatcenter t hat center bezierpath bezier path v2negate v2 negate thatcenter t hat center fitcubic fit cubic d splitpoint split point 0 last thatcenter t hat center that2 t hat2 bezierpath bezier path } private fitcubic fit cubic point2d point2 d d first last point2d point2 d that1 t hat1 point2d point2 d that2 t hat2 bezierpath bezier path bezierpath bezier path { point2d point2 d bezcurve bez curve u 		 uprime u prime 	 double	maxerror double	max 	 	splitpoint 	split point = new 1 int	npts int	n pts 		 double	iterationerror double	iteration int	maxiterations int	max iterations = 4 point2d point2 d double	thatcenter double	t hat center = new point2d point2 d int	i iterationerror iteration = * npts n pts = last first + 1 if npts n pts == 2 { dist = v2distancebetween2points v2 distance between2 points d last d first / 3 0 bezcurve bez curve = new point2d point2 d 4 for i=0 i < bezcurve bez curve length i++ { bezcurve bez curve i = new point2d point2 d } bezcurve bez curve 0 = d first bezcurve bez curve 3 = d last v2add v2 add bezcurve bez curve 0 v2scale v2 scale that1 t hat1 dist bezcurve bez curve 1 v2add v2 add bezcurve bez curve 3 v2scale v2 scale that2 t hat2 dist bezcurve bez curve 2 bezierpath bezier path curveto curve to bezcurve bez curve 1 x bezcurve bez curve 1 y bezcurve bez curve 2 x bezcurve bez curve 2 y bezcurve bez curve 3 x bezcurve bez curve 3 y } u = chordlengthparameterize chord length parameterize d first last bezcurve bez curve = generatebezier generate bezier d first last u that1 t hat1 that2 t hat2 maxerror max = computemaxerror compute max d first last bezcurve bez curve u splitpoint split point if maxerror max < { bezierpath bezier path curveto curve to bezcurve bez curve 1 x bezcurve bez curve 1 y bezcurve bez curve 2 x bezcurve bez curve 2 y bezcurve bez curve 3 x bezcurve bez curve 3 y } if maxerror max < iterationerror iteration { for i = 0 i < maxiterations max iterations i++ { uprime u prime = reparameterize d first last u bezcurve bez curve bezcurve bez curve = generatebezier generate bezier d first last uprime u prime that1 t hat1 that2 t hat2 maxerror max = computemaxerror compute max d first last bezcurve bez curve uprime u prime splitpoint split point if maxerror max < { bezierpath bezier path curveto curve to bezcurve bez curve 1 x bezcurve bez curve 1 y bezcurve bez curve 2 x bezcurve bez curve 2 y bezcurve bez curve 3 x bezcurve bez curve 3 y } u = uprime u prime } } thatcenter t hat center = computecentertangent compute center tangent d splitpoint split point 0 fitcubic fit cubic d first splitpoint split point 0 that1 t hat1 thatcenter t hat center bezierpath bezier path v2negate v2 negate thatcenter t hat center fitcubic fit cubic d splitpoint split point 0 last thatcenter t hat center that2 t hat2 bezierpath bezier path } private point2d point2 d generatebezier generate bezier point2d point2 d d first last uprime u prime point2d point2 d that1 t hat1 point2d point2 d that2 t hat2 { 	i point2d point2 d a = new point2d point2 d maxpoints m a x p o i n t s 2 	npts 	n pts 			 c = new 2 2 x = new 2 	 	det_C0_C1 		 det_C0_X det_X_C1 	alpha_l 		 alpha_r point2d point2 d 	tmp = new point2d point2 d point2d point2 d bezcurve bez curve 	 bezcurve bez curve = new point2d point2 d 4 for i=0 i < bezcurve bez curve length i++ { bezcurve bez curve i = new point2d point2 d } npts n pts = last first + 1 for i = 0 i < npts n pts i++ { point2d point2 d v1 v2 v1 = point2d point2 d that1 t hat1 clone v2 = point2d point2 d that2 t hat2 clone v2scale v2 scale v1 b1 uprime u prime i v2scale v2 scale v2 b2 uprime u prime i a i 0 = v1 a i 1 = v2 } c 0 0 = 0 0 c 0 1 = 0 0 c 1 0 = 0 0 c 1 1 = 0 0 x 0 = 0 0 x 1 = 0 0 for i = 0 i < npts n pts i++ { c 0 0 += v2dot v2 dot a i 0 a i 0 c 0 1 += v2dot v2 dot a i 0 a i 1 c 1 0 = c 0 1 c 1 1 += v2dot v2 dot a i 1 a i 1 tmp = v2subii v2 sub i i d first + i v2addii v2 add i i v2scaleiii v2 scale i i i d first b0 uprime u prime i v2addii v2 add i i v2scaleiii v2 scale i i i d first b1 uprime u prime i v2addii v2 add i i v2scaleiii v2 scale i i i d last b2 uprime u prime i v2scaleiii v2 scale i i i d last b3 uprime u prime i x 0 += v2dot v2 dot a i 0 tmp x 1 += v2dot v2 dot a i 1 tmp } det_C0_C1 = c 0 0 * c 1 1 c 1 0 * c 0 1 det_C0_X = c 0 0 * x 1 c 0 1 * x 0 det_X_C1 = x 0 * c 1 1 x 1 * c 0 1 if det_C0_C1 == 0 0 { det_C0_C1 = c 0 0 * c 1 1 * 10e 12 } alpha_l = det_X_C1 / det_C0_C1 alpha_r = det_C0_X / det_C0_C1 if alpha_l < 1 0e 6 || alpha_r < 1 0e 6 { dist = v2distancebetween2points v2 distance between2 points d last d first / 3 0 bezcurve bez curve 0 = d first bezcurve bez curve 3 = d last v2add v2 add bezcurve bez curve 0 v2scale v2 scale that1 t hat1 dist bezcurve bez curve 1 v2add v2 add bezcurve bez curve 3 v2scale v2 scale that2 t hat2 dist bezcurve bez curve 2 bezcurve bez curve } bezcurve bez curve 0 = d first bezcurve bez curve 3 = d last v2add v2 add bezcurve bez curve 0 v2scale v2 scale that1 t hat1 alpha_l bezcurve bez curve 1 v2add v2 add bezcurve bez curve 3 v2scale v2 scale that2 t hat2 alpha_r bezcurve bez curve 2 bezcurve bez curve } private reparameterize point2d point2 d d first last u point2d point2 d bezcurve bez curve { 	npts 	n pts = last first+1 	i uprime u prime uprime u prime = new npts n pts for i = first i <= last i++ { uprime u prime i first = newtonraphsonrootfind newton raphson root find bezcurve bez curve d i u i first } uprime u prime } private newtonraphsonrootfind newton raphson root find point2d point2 d q point2d point2 d p u { 		numerator denominator point2d point2 d q1 = new point2d point2 d 3 q2 = new point2d point2 d 2 	 point2d point2 d Double	Q_u = new point2d point2 d Q1_u = new point2d point2 d Q2_u = new point2d point2 d 		uprime 		u prime 		 		i Q_u = bezierii bezier i i 3 q u for i = 0 i <= 2 i++ { q1 i = new point2d point2 d q i+1 x q i x * 3 0 q i+1 y q i y * 3 0 } for i = 0 i <= 1 i++ { q2 i = new point2d point2 d q1 i+1 x q1 i x * 2 0 q1 i+1 y q1 i y * 2 0 } Q1_u = bezierii bezier i i 2 q1 u Q2_u = bezierii bezier i i 1 q2 u numerator = Q_u x p x * Q1_u x + Q_u y p y * Q1_u y denominator = Q1_u x * Q1_u x + Q1_u y * Q1_u y + Q_u x p x * Q2_u x + Q_u y p y * Q2_u y uprime u prime = u numerator/denominator uprime u prime } private point2d point2 d bezierii bezier i i degree point2d point2 d v t { 	i j point2d point2 d q point2d point2 d vtemp vtemp = new point2d point2 d degree+1 for i = 0 i <= degree i++ { vtemp i = point2d point2 d v i clone } for i = 1 i <= degree i++ { for j = 0 j <= degree i j++ { vtemp j x = 1 0 t * vtemp j x + t * vtemp j+1 x vtemp j y = 1 0 t * vtemp j y + t * vtemp j+1 y } } q = vtemp 0 q } private b0 u { tmp = 1 0 u tmp * tmp * tmp } private b1 u { tmp = 1 0 u 3 * u * tmp * tmp } private b2 u { tmp = 1 0 u 3 * u * u * tmp } private b3 u { u * u * u } private point2d point2 d computelefttangent compute left tangent point2d point2 d d end { point2d point2 d double	that1 double	t hat1 = new point2d point2 d that1 t hat1 = v2subii v2 sub i i d end+1 d end that1 t hat1 = v2normalize v2 normalize that1 t hat1 that1 t hat1 } private point2d point2 d computerighttangent compute right tangent point2d point2 d d end { point2d point2 d that2 t hat2 = new point2d point2 d that2 t hat2 = v2subii v2 sub i i d end 1 d end that2 t hat2 = v2normalize v2 normalize that2 t hat2 that2 t hat2 } private point2d point2 d computecentertangent compute center tangent point2d point2 d d center { point2d point2 d v1 = new point2d point2 d v2 = new point2d point2 d thatcenter t hat center = new point2d point2 d v1 = v2subii v2 sub i i d center 1 d center v2 = v2subii v2 sub i i d center d center+1 thatcenter t hat center x = v1 x + v2 x /2 0 thatcenter t hat center y = v1 y + v2 y /2 0 thatcenter t hat center = v2normalize v2 normalize thatcenter t hat center thatcenter t hat center } private chordlengthparameterize chord length parameterize point2d point2 d d first last { int	i u 	 u = new last first+1 u 0 = 0 0 for i = first+1 i <= last i++ { u i first = u i first 1 + v2distancebetween2points v2 distance between2 points d i d i 1 } for i = first + 1 i <= last i++ { u i first = u i first / u last first } u } private computemaxerror compute max point2d point2 d d first last point2d point2 d bezcurve bez curve u splitpoint split point { int		i double	maxdist double	max dist 		 double	dist 		 point2d point2 d double	p double	 p = new point2d point2 d point2d point2 d double	v = new point2d point2 d splitpoint split point 0 = last first + 1 /2 maxdist max dist = 0 0 for i = first + 1 i < last i++ { p = bezierii bezier i i 3 bezcurve bez curve u i first v = v2subii v2 sub i i p d i dist = v2squaredlength v2 squared length v if dist >= maxdist max dist { maxdist max dist = dist splitpoint split point 0 = i } } maxdist max dist } private point2d point2 d v2addii v2 add i i point2d point2 d a point2d point2 d b { point2d point2 d c = new point2d point2 d c x = a x + b x c y = a y + b y c } private point2d point2 d v2scaleiii v2 scale i i i point2d point2 d v s { point2d point2 d result = new point2d point2 d result x = v x * s result y = v y * s result } private point2d point2 d v2subii v2 sub i i point2d point2 d a point2d point2 d b { point2d point2 d c = new point2d point2 d c x = a x b x c y = a y b y c } private v2distancebetween2points v2 distance between2 points point2d point2 d a point2d point2 d b { dx = a x b x dy = a y b y math sqrt dx*dx + dy*dy } private point2d point2 d v2scale v2 scale point2d point2 d v newlen { len = v2length v2 length v if len != 0 0 { v x *= newlen/len v y *= newlen/len } v } private v2length v2 length point2d point2 d a { math sqrt v2squaredlength v2 squared length a } private v2squaredlength v2 squared length point2d point2 d a { a x * a x + a y * a y } private point2d point2 d v2add v2 add point2d point2 d a point2d point2 d b point2d point2 d c { c x = a x+b x c y = a y+b y c } private point2d point2 d v2negate v2 negate point2d point2 d v { v x = v x v y = v y v } private v2dot v2 dot point2d point2 d a point2d point2 d b { a x*b x + a y*b y } private point2d point2 d v2normalize v2 normalize point2d point2 d v { len = v2length v2 length v if len != 0 0 { v x /= len v y /= len } v } } 