org jhotdraw samples svg import awt color import awt geom * import io * import util * import javax swing * import org jhotdraw draw * import org jhotdraw geom * import org jhotdraw samples svg figures * import org jhotdraw xml * import org jhotdraw draw attributekeys attribute keys * svgutil s v g util { private color INHERIT_COLOR = new color 0xffff00 private color CURRENT_COLOR = new color 0xffff00 map<string map< color> SVG_COLORS { linkedhashmap<string linked hash map< color> map = new linkedhashmap<string linked hash map< color> map put black new color 0 0 0 map put green new color 0 128 0 map put silver new color 192 192 192 map put lime new color 0 255 0 map put gray new color 128 128 128 map put olive new color 128 128 0 map put white new color 255 255 255 map put yellow new color 255 255 0 map put maroon new color 128 0 0 map put navy new color 0 0 128 map put red new color 255 0 0 map put blue new color 0 0 255 map put purple new color 128 0 128 map put teal new color 0 128 128 map put fuchsia new color 255 0 255 map put aqua new color 0 255 255 map put aliceblue new color 240 248 255 map put antiquewhite new color 250 235 215 map put aqua new color 0 255 255 map put aquamarine new color 127 255 212 map put azure new color 240 255 255 map put beige new color 245 245 220 map put bisque new color 255 228 196 map put black new color 0 0 0 map put blanchedalmond new color 255 235 205 map put blue new color 0 0 255 map put blueviolet new color 138 43 226 map put brown new color 165 42 42 map put burlywood new color 222 184 135 map put cadetblue new color 95 158 160 map put chartreuse new color 127 255 0 map put chocolate new color 210 105 30 map put coral new color 255 127 80 map put cornflowerblue new color 100 149 237 map put cornsilk new color 255 248 220 map put crimson new color 220 20 60 map put cyan new color 0 255 255 map put darkblue new color 0 0 139 map put darkcyan new color 0 139 139 map put darkgoldenrod new color 184 134 11 map put darkgray new color 169 169 169 map put darkgreen new color 0 100 0 map put darkgrey new color 169 169 169 map put darkkhaki new color 189 183 107 map put darkmagenta new color 139 0 139 map put darkolivegreen new color 85 107 47 map put darkorange new color 255 140 0 map put darkorchid new color 153 50 204 map put darkred new color 139 0 0 map put darksalmon new color 233 150 122 map put darkseagreen new color 143 188 143 map put darkslateblue new color 72 61 139 map put darkslategray new color 47 79 79 map put darkslategrey new color 47 79 79 map put darkturquoise new color 0 206 209 map put darkviolet new color 148 0 211 map put deeppink new color 255 20 147 map put deepskyblue new color 0 191 255 map put dimgray new color 105 105 105 map put dimgrey new color 105 105 105 map put dodgerblue new color 30 144 255 map put firebrick new color 178 34 34 map put floralwhite new color 255 250 240 map put forestgreen new color 34 139 34 map put fuchsia new color 255 0 255 map put gainsboro new color 220 220 220 map put ghostwhite new color 248 248 255 map put gold new color 255 215 0 map put goldenrod new color 218 165 32 map put gray new color 128 128 128 map put grey new color 128 128 128 map put green new color 0 128 0 map put greenyellow new color 173 255 47 map put honeydew new color 240 255 240 map put hotpink new color 255 105 180 map put indianred new color 205 92 92 map put indigo new color 75 0 130 map put ivory new color 255 255 240 map put khaki new color 240 230 140 map put lavender new color 230 230 250 map put lavenderblush new color 255 240 245 map put lawngreen new color 124 252 0 map put lemonchiffon new color 255 250 205 map put lightblue new color 173 216 230 map put lightcoral new color 240 128 128 map put lightcyan new color 224 255 255 map put lightgoldenrodyellow new color 250 250 210 map put lightgray new color 211 211 211 map put lightgreen new color 144 238 144 map put lightgrey new color 211 211 211 map put lightpink new color 255 182 193 map put lightsalmon new color 255 160 122 map put lightseagreen new color 32 178 170 map put lightskyblue new color 135 206 250 map put lightslategray new color 119 136 153 map put lightslategrey new color 119 136 153 map put lightsteelblue new color 176 196 222 map put lightyellow new color 255 255 224 map put lime new color 0 255 0 map put limegreen new color 50 205 50 map put linen new color 250 240 230 map put magenta new color 255 0 255 map put maroon new color 128 0 0 map put mediumaquamarine new color 102 205 170 map put mediumblue new color 0 0 205 map put mediumorchid new color 186 85 211 map put mediumpurple new color 147 112 219 map put mediumseagreen new color 60 179 113 map put mediumslateblue new color 123 104 238 map put mediumspringgreen new color 0 250 154 map put mediumturquoise new color 72 209 204 map put mediumvioletred new color 199 21 133 map put midnightblue new color 25 25 112 map put mintcream new color 245 255 250 map put mistyrose new color 255 228 225 map put moccasin new color 255 228 181 map put navajowhite new color 255 222 173 map put navy new color 0 0 128 map put oldlace new color 253 245 230 map put olive new color 128 128 0 map put olivedrab new color 107 142 35 map put orange new color 255 165 0 map put orangered new color 255 69 0 map put orchid new color 218 112 214 map put palegoldenrod new color 238 232 170 map put palegreen new color 152 251 152 map put paleturquoise new color 175 238 238 map put palevioletred new color 219 112 147 map put papayawhip new color 255 239 213 map put peachpuff new color 255 218 185 map put peru new color 205 133 63 map put pink new color 255 192 203 map put plum new color 221 160 221 map put powderblue new color 176 224 230 map put purple new color 128 0 128 map put red new color 255 0 0 map put rosybrown new color 188 143 143 map put royalblue new color 65 105 225 map put saddlebrown new color 139 69 19 map put salmon new color 250 128 114 map put sandybrown new color 244 164 96 map put seagreen new color 46 139 87 map put seashell new color 255 245 238 map put sienna new color 160 82 45 map put silver new color 192 192 192 map put skyblue new color 135 206 235 map put slateblue new color 106 90 205 map put slategray new color 112 128 144 map put slategrey new color 112 128 144 map put snow new color 255 250 250 map put springgreen new color 0 255 127 map put steelblue new color 70 130 180 map put tan new color 210 180 140 map put teal new color 0 128 128 map put thistle new color 216 191 216 map put tomato new color 255 99 71 map put turquoise new color 64 224 208 map put violet new color 238 130 238 map put wheat new color 245 222 179 map put white new color 255 255 255 map put whitesmoke new color 245 245 245 map put yellow new color 255 255 0 map put yellowgreen new color 154 205 50 map put activeborder uimanager u i manager getcolor get color activecaptionborder active caption border map put activecaption uimanager u i manager getcolor get color activecaption active caption map put appworkspace uimanager u i manager getcolor get color window map put background uimanager u i manager getcolor get color desktop map put buttonface uimanager u i manager getcolor get color control map put buttonhighlight uimanager u i manager getcolor get color controlhighlight control highlight map put buttonshadow uimanager u i manager getcolor get color controlshadow control shadow map put buttontext uimanager u i manager getcolor get color controltext control text map put captiontext uimanager u i manager getcolor get color activecaptiontext active caption text map put graytext uimanager u i manager getcolor get color textinactivetext text inactive text map put highlight uimanager u i manager getcolor get color texthighlight text highlight map put highlighttext uimanager u i manager getcolor get color texthighlighttext text highlight text map put inactiveborder uimanager u i manager getcolor get color inactivecaptionborder inactive caption border map put inactivecaption uimanager u i manager getcolor get color inactivecaption inactive caption map put inactivecaptiontext uimanager u i manager getcolor get color inactivecaptiontext inactive caption text map put infobackground uimanager u i manager getcolor get color info map put infotext uimanager u i manager getcolor get color infotext info text map put menu uimanager u i manager getcolor get color menu map put menutext uimanager u i manager getcolor get color menutext menu text map put scrollbar uimanager u i manager getcolor get color scrollbar map put threeddarkshadow uimanager u i manager getcolor get color controldkshadow control dk shadow map put threedface uimanager u i manager getcolor get color control map put threedhighlight uimanager u i manager getcolor get color controlhighlight control highlight map put threedlightshadow uimanager u i manager getcolor get color controllthighlight control lt highlight map put threedshadow uimanager u i manager getcolor get color controlshadow control shadow map put window uimanager u i manager getcolor get color window map put windowframe uimanager u i manager getcolor get color windowborder window border map put windowtext uimanager u i manager getcolor get color windowtext window text SVG_COLORS = map } private svgutil s v g util { } affinetransform affine transform gettransform get transform dominput dom input in attributename attribute name ioexception i o { gettransform get transform in getattribute get attribute attributename attribute name } affinetransform affine transform gettransform get transform str ioexception i o { affinetransform affine transform t = new affinetransform affine transform if str != { streamtokenizer stream tokenizer tt = new streamtokenizer stream tokenizer new stringreader reader str tt resetsyntax reset syntax tt wordchars word chars 'a' 'z' tt wordchars word chars 'a' ' a' 'z' ' z' tt wordchars word chars 128 + 32 255 tt whitespacechars whitespace chars 0 ' ' tt whitespacechars whitespace chars ' ' ' ' tt parsenumbers parse numbers while tt nexttoken next token != streamtokenizer stream tokenizer TT_EOF { if tt ttype != streamtokenizer stream tokenizer TT_WORD { throw new ioexception i o illegal transform +str } type = tt sval if tt nexttoken next token != ' ' { throw new ioexception i o ' ' not found in transform +str } if type equals matrix { m = new 6 for i=0 i < 6 i++ { if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER { throw new ioexception i o matrix value +i+ not found in transform +str+ token +tt ttype+ +tt sval } if tt nexttoken next token == streamtokenizer stream tokenizer TT_WORD tt sval startswith starts with e { mantissa = tt nval tt nval = valueof value of tt nval + tt sval } else { tt pushback push back } m i = tt nval } t concatenate new affinetransform affine transform m } else if type equals translate { tx ty if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER { throw new ioexception i o x translation value not found in transform +str } tx = tt nval if tt nexttoken next token == streamtokenizer stream tokenizer TT_NUMBER { ty = tt nval } else { tt pushback push back ty = 0 } t translate tx ty } else if type equals scale { sx sy if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER { throw new ioexception i o x scale value not found in transform +str } sx = tt nval if tt nexttoken next token == streamtokenizer stream tokenizer TT_NUMBER { sy = tt nval } else { tt pushback push back sy = sx } t scale sx sy } else if type equals rotate { angle cx cy if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER { throw new ioexception i o angle value not found in transform +str } angle = tt nval if tt nexttoken next token == streamtokenizer stream tokenizer TT_NUMBER { cx = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER { throw new ioexception i o y center value not found in transform +str } cy = tt nval } else { tt pushback push back cx = cy = 0 } t rotate angle * math pi p i / 180d cx * math pi p i / 180d cy * math pi p i / 180d } else if type equals skewx skew x { angle if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER { throw new ioexception i o skew angle not found in transform +str } angle = tt nval t concatenate new affinetransform affine transform 1 0 math tan angle * math pi p i / 180 1 0 0 } else if type equals skewy skew y { angle if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER { throw new ioexception i o skew angle not found in transform +str } angle = tt nval t concatenate new affinetransform affine transform 1 math tan angle * math pi p i / 180 0 1 0 0 }else { throw new ioexception i o unknown transform +type+ in +str } if tt nexttoken next token != ' ' { throw new ioexception i o ' ' not found in transform +str } } } t } getdimension get dimension dominput dom input in attributename attribute name ioexception i o { getdimensionvalue get dimension value in in getattribute get attribute attributename attribute name 0 } getdimensionvalue get dimension value dominput dom input in str ioexception i o { scalefactor scale factor = 1d if str == || str length == 0 { 0d } if str endswith ends with % { str = str substring 0 str length 1 } else if str endswith ends with px { str = str substring 0 str length 2 } else if str endswith ends with pt { str = str substring 0 str length 2 scalefactor scale factor = 1 25 } else if str endswith ends with pc { str = str substring 0 str length 2 scalefactor scale factor = 15 } else if str endswith ends with mm { str = str substring 0 str length 2 scalefactor scale factor = 3 543307 } else if str endswith ends with cm { str = str substring 0 str length 2 scalefactor scale factor = 35 43307 } else if str endswith ends with in { str = str substring 0 str length 2 scalefactor scale factor = 90 } else if str endswith ends with em { str = str substring 0 str length 2 list<map<string list< map< string>> styles = new arraylist<map<string list< map< string>> list<string> list< string> values = in getinheritedattribute get inherited attribute style for v values { styles add getstyles get styles v } value = getinheritedattribute get inherited attribute font size in styles if value != ! value endswith ends with em { scalefactor scale factor = getdimensionvalue get dimension value in value } } parsedouble parse str * scalefactor scale factor } list<bezierpath> list< bezier path> getpath get path dominput dom input in attributename attribute name ioexception i o { frompathdata from path data in getattribute get attribute attributename attribute name } setpath set path domoutput dom output out attributename attribute name bezierpath bezier path path { out addattribute add attribute attributename attribute name topathdata to path data path } topathdata to path data bezierpath bezier path path { stringbuilder builder buf = new stringbuilder builder if path size == 0 { } else if path size == 1 { bezierpath bezier path node current = path get 0 buf append m buf append current x 0 buf append ' ' buf append current y 0 buf append l buf append current x 0 buf append ' ' buf append current y 0 + 1 } else { bezierpath bezier path node previous bezierpath bezier path node current previous = current = path get 0 buf append m buf append current x 0 buf append ' ' buf append current y 0 for i=1 n = path size i < n i++ { previous = current current = path get i if previous mask bezierpath bezier path C2_MASK == 0 { if current mask bezierpath bezier path C1_MASK == 0 { buf append l buf append current x 0 buf append ' ' buf append current y 0 } else { buf append q buf append current x 1 buf append ' ' buf append current y 1 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } } else { if current mask bezierpath bezier path C1_MASK == 0 { buf append q buf append current x 2 buf append ' ' buf append current y 2 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } else { buf append c buf append previous x 2 buf append ' ' buf append previous y 2 buf append ' ' buf append current x 1 buf append ' ' buf append current y 1 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } } } if path isclosed is closed { if path size > 1 { previous = path get path size 1 current = path get 0 if previous mask bezierpath bezier path C2_MASK == 0 { if current mask bezierpath bezier path C1_MASK == 0 { buf append l buf append current x 0 buf append ' ' buf append current y 0 } else { buf append q buf append current x 1 buf append ' ' buf append current y 1 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } } else { if current mask bezierpath bezier path C1_MASK == 0 { buf append q buf append previous x 2 buf append ' ' buf append previous y 2 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } else { buf append c buf append previous x 2 buf append ' ' buf append previous y 2 buf append ' ' buf append current x 1 buf append ' ' buf append current y 1 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } } } buf append z } } buf tostring to } private hashset hash set pathcommands path commands = new hashset hash set arrays aslist as list new { m m z z l l h h v v c c s s q q t t } list<bezierpath> list< bezier path> frompathdata from path data str ioexception i o { linkedlist<bezierpath> linked list< bezier path> paths = new linkedlist<bezierpath> linked list< bezier path> bezierpath bezier path path = point2d point2 d p = new point2d point2 d point2d point2 d c1 = new point2d point2 d point2d point2 d c2 = new point2d point2 d streamtokenizer stream tokenizer tt = new streamtokenizer stream tokenizer new stringreader reader str tt resetsyntax reset syntax tt parsenumbers parse numbers tt whitespacechars whitespace chars 0 ' ' tt whitespacechars whitespace chars ' ' ' ' char nextcommand next command = 'm' ' m' char command = 'm' ' m' while tt nexttoken next token != streamtokenizer stream tokenizer TT_EOF { if tt ttype > 0 { command = char tt ttype } else { command = nextcommand next command tt pushback push back } bezierpath bezier path node node switch command { case 'm' ' m' if path != { paths add path } path = new bezierpath bezier path if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y = tt nval path moveto move to p x p y nextcommand next command = 'l' ' l' break case 'm' if path != { paths add path } path = new bezierpath bezier path if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x += tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y += tt nval path moveto move to p x p y nextcommand next command = 'l' break case 'z' ' z' case 'z' p x = path get 0 x 0 p y = path get 0 y 0 path setclosed set closed break case 'l' ' l' if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y = tt nval path lineto line to p x p y nextcommand next command = 'l' ' l' break case 'l' if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x += tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y += tt nval path lineto line to p x p y nextcommand next command = 'l' break case 'h' ' h' if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x = tt nval path lineto line to p x p y nextcommand next command = 'h' ' h' break case 'h' if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x += tt nval path lineto line to p x p y nextcommand next command = 'h' break case 'v' ' v' if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y = tt nval path lineto line to p x p y nextcommand next command = 'v' ' v' break case 'v' if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y += tt nval path lineto line to p x p y nextcommand next command = 'v' break case 'c' ' c' if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c1 x = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c1 y = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c2 x = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c2 y = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y = tt nval path curveto curve to c1 x c1 y c2 x c2 y p x p y nextcommand next command = 'c' ' c' break case 'c' if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c1 x = p x + tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c1 y = p y + tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c2 x = p x + tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c2 y = p y + tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x += tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y += tt nval path curveto curve to c1 x c1 y c2 x c2 y p x p y nextcommand next command = 'c' break case 's' ' s' node = path get path size 1 c1 x = node x 0 * 2d node x 1 c1 y = node y 0 * 2d node y 1 if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c2 x = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c2 y = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y = tt nval path curveto curve to c1 x c1 y c2 x c2 y p x p y nextcommand next command = 's' ' s' break case 's' node = path get path size 1 c1 x = node x 0 * 2d node x 1 c1 y = node y 0 * 2d node y 1 if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c2 x = p x + tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c2 y = p y + tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x += tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y += tt nval path curveto curve to c1 x c1 y c2 x c2 y p x p y nextcommand next command = 's' break case 'q' ' q' if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c1 x = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c1 y = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y = tt nval path quadto quad to c1 x c1 y p x p y nextcommand next command = 'q' ' q' break case 'q' if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c1 x = p x + tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected c1 y = p y + tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x += tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y += tt nval path quadto quad to c1 x c1 y p x p y nextcommand next command = 'q' break case 't' ' t' node = path get path size 1 c1 x = node x 0 * 2d node x 1 c1 y = node y 0 * 2d node y 1 if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x = tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y = tt nval path quadto quad to c1 x c1 y p x p y nextcommand next command = 't' ' t' break case 't' node = path get path size 1 c1 x = node x 0 * 2d node x 1 c1 y = node y 0 * 2d node y 1 if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p x += tt nval if tt nexttoken next token != streamtokenizer stream tokenizer TT_NUMBER throw new ioexception i o number expected p y += tt nval path quadto quad to c1 x c1 y p x p y nextcommand next command = 's' break default throw new ioexception i o illegal command +command } } if path != { paths add path } paths } getinheritedattribute get inherited attribute name dominput dom input in list<map<string list< map< string>> styles { list<string> list< string> values = in getinheritedattribute get inherited attribute name for i=values size 1 i >= 0 i { if values get i != { values get i } if styles get i != styles get i containskey contains key name { styles get i get name } } } readattributes read attributes figure f dominput dom input in ioexception i o { list<map<string list< map< string>> styles = new arraylist<map<string list< map< string>> list<string> list< string> values = in getinheritedattribute get inherited attribute style for v values { styles add getstyles get styles v } value value = getinheritedattribute get inherited attribute fill in styles if value != { color color = getcolor get color value if color != INHERIT_COLOR color != CURRENT_COLOR { FILL_COLOR set f color } } value = getinheritedattribute get inherited attribute fill rule in styles if value != { WINDING_RULE set f value touppercase to upper case equals nonzero n o n z e r o ? windingrule winding rule NON_ZERO windingrule winding rule EVEN_ODD } else { WINDING_RULE set f windingrule winding rule NON_ZERO } value = getinheritedattribute get inherited attribute stroke in styles if value != { color color = getcolor get color value if color != INHERIT_COLOR color != CURRENT_COLOR { STROKE_COLOR set f color } } value = getinheritedattribute get inherited attribute stroke width in styles if value != { STROKE_WIDTH set f valueof value of value } value = getinheritedattribute get inherited attribute stroke miterlimit in styles if value != { STROKE_MITER_LIMIT_FACTOR set f valueof value of value } value = getinheritedattribute get inherited attribute stroke dasharray in styles if value != { stringtokenizer tokenizer tt = new stringtokenizer tokenizer value dashes = new tt counttokens count tokens for i=0 n = dashes length i < n i++ { dashes i = valueof value of tt nexttoken next token } STROKE_DASHES set f dashes } value = getinheritedattribute get inherited attribute stroke dashoffset in styles if value != { STROKE_DASH_PHASE set f math abs valueof value of value } value = getinheritedattribute get inherited attribute font size in styles if value != { FONT_SIZE set f getdimensionvalue get dimension value in value } value = getinheritedattribute get inherited attribute text anchor in styles if value != { svgtext s v g text TEXT_ANCHOR set f enum valueof value of svgtext s v g text textanchor text anchor value touppercase to upper case } } map<string map< string> getstyles get styles str ioexception i o { hashmap<string hash map< string> styles = new hashmap<string hash map< string> if str == styles streamtokenizer stream tokenizer tt = new streamtokenizer stream tokenizer new stringreader reader str tt resetsyntax reset syntax tt wordchars word chars '!' '9' tt wordchars word chars '<' '~' tt wordchars word chars 128 + 32 255 tt whitespacechars whitespace chars 0 ' ' while tt nexttoken next token != streamtokenizer stream tokenizer TT_EOF { if tt ttype != ' ' { key value if tt ttype != streamtokenizer stream tokenizer TT_WORD { throw new ioexception i o key token expected in +str+ +integer + integer tohexstring to hex tt ttype } key = tt sval if tt nexttoken next token != ' ' { throw new ioexception i o colon expected after +key+ in +str } if tt nexttoken next token != streamtokenizer stream tokenizer TT_WORD { throw new ioexception i o value token expected after +key+ in +str+ +tt ttype } value = tt sval while tt nexttoken next token == streamtokenizer stream tokenizer TT_WORD { value += ' ' + tt sval } tt pushback push back styles put key value } } styles } color getcolor get color value { value = value trim tolowercase to lower case if value equals none { } else if value equals currentcolor current color { CURRENT_COLOR } else if value equals inherit { INHERIT_COLOR } else if SVG_COLORS containskey contains key value { SVG_COLORS get value } else if value startswith starts with # value length == 7 { new color integer decode value } else if value startswith starts with # value length == 4 { th = integer decode value new color th 0xf | th 0xf << 4 | th 0xf0 << 4 | th 0xf0 << 8 | th 0xf00 << 8 | th 0xf00 << 12 } else if value startswith starts with rgb { stringtokenizer tokenizer tt = new stringtokenizer tokenizer value tt nexttoken next token color c = new color integer decode tt nexttoken next token integer decode tt nexttoken next token integer decode tt nexttoken next token c } else { } } setdefaults set defaults figure f { FILL_COLOR set f color black STROKE_COLOR set f STROKE_DASH_FACTOR set f 1d } writeattributes write attributes figure f domoutput dom output out ioexception i o { color color dbl value color = FILL_COLOR get f if color == { value = none } else { value = 000000 +integer + integer tohexstring to hex color getrgb get r g b value = # +value substring value length 6 } out addattribute add attribute fill value if WINDING_RULE get f != windingrule winding rule NON_ZERO { out addattribute add attribute fill rule evenodd } color = STROKE_COLOR get f if color == { value = none } else { value = 000000 +integer + integer tohexstring to hex color getrgb get r g b value = # +value substring value length 6 } out addattribute add attribute stroke value out addattribute add attribute stroke width STROKE_WIDTH get f 1d out addattribute add attribute stroke miterlimit STROKE_MITER_LIMIT_FACTOR get f / STROKE_WIDTH get f 4d dashes = STROKE_DASHES get f dbl = STROKE_DASH_FACTOR get f == ? STROKE_WIDTH get f STROKE_DASH_FACTOR get f if dashes != { stringbuilder builder buf = new stringbuilder builder for i=0 i < dashes length i++ { if i != 0 { buf append ' ' buf append dashes i * dbl } out addattribute add attribute stroke dasharray buf tostring to } } out addattribute add attribute stroke dashoffset STROKE_DASH_PHASE get f 0d out addattribute add attribute font size FONT_SIZE get f } } 