org jhotdraw geom import awt * import awt geom * import util * bezierpath bezier path arraylist<bezierpath list< bezier path node> implements shape { C1_MASK = 1 C2_MASK = 2 C1C2_MASK = C1_MASK | C2_MASK private transient generalpath general path generalpath general path private outer = 1 private isclosed is closed node implements cloneable { mask = 0 x = new 3 y = new 3 keepcolinear keep colinear = node { mask = 1 } node node that { setto set to that } setto set to node that { this mask = that mask this keepcolinear keep colinear = that keepcolinear keep colinear arraycopy that x 0 this x 0 3 arraycopy that y 0 this y 0 3 } node point2d point2 d c0 { this mask = 0 x 0 = c0 x y 0 = c0 y x 1 = c0 x y 1 = c0 y x 2 = c0 x y 2 = c0 y } node mask point2d point2 d c0 point2d point2 d c1 point2d point2 d c2 { this mask = mask x 0 = c0 x y 0 = c0 y x 1 = c1 x y 1 = c1 y x 2 = c2 x y 2 = c2 y } node x0 y0 { this mask = 0 x 0 = x0 y 0 = y0 x 1 = x0 y 1 = y0 x 2 = x0 y 2 = y0 } node mask x0 y0 x1 y1 x2 y2 { this mask = mask x 0 = x0 y 0 = y0 x 1 = x1 y 1 = y1 x 2 = x2 y 2 = y2 } getmask get mask { mask } setmask set mask newvalue new value { mask = newvalue new value } setcontrolpoint set control point index point2d point2 d p { x index = p x y index = p y } point2d point2 d getcontrolpoint get control point index { new point2d point2 d x index y index } moveto move to point2d point2 d p { moveby move by p x x 0 p y y 0 } moveto move to x y { moveby move by x this x 0 y this y 0 } moveby move by dx dy { for i=0 i < 3 i++ { x i += dx y i += dy } } clone { try { node that = node super clone that x = this x clone that y = this y clone that } catch clonenotsupportedexception clone not supported e { internalerror internal = new internalerror internal initcause init cause e throw } } tostring to { stringbuilder builder buf = new stringbuilder builder buf append ' ' for i=0 i < 3 i++ { if i != 0 { if mask i == i { buf append ' ' } else { continue } } buf append 'x' buf append i buf append '=' buf append x i buf append y buf append i buf append '=' buf append y i } buf append ' ' buf tostring to } } bezierpath bezier path { } add point2d point2 d c0 { add new node 0 c0 c0 c0 } addpoint add point x y { add new node 0 x y x y x y } add mask point2d point2 d c0 point2d point2 d c1 point2d point2 d c2 { add new node mask c0 c1 c2 } set index coord point2d point2 d p { node c = get index c x coord = p x c y coord = p y } point2d point2 d get index coord { node c = get index new point2d point2 d c x coord c y coord } invalidatepath invalidate path { generalpath general path = outer = 1 } validatepath validate path { if generalpath general path == { generalpath general path = togeneralpath to general path } } generalpath general path togeneralpath to general path { generalpath general path gp = new generalpath general path gp setwindingrule set winding rule generalpath general path WIND_EVEN_ODD if size == 0 { gp moveto move to 0 0 gp lineto line to 0 0 + 1 } else if size == 1 { node current = get 0 gp moveto move to float current x 0 float current y 0 gp lineto line to float current x 0 float current y 0 + 1 } else { node previous node current previous = current = get 0 gp moveto move to float current x 0 float current y 0 for i=1 n = size i < n i++ { previous = current current = get i if previous mask C2_MASK == 0 { if current mask C1_MASK == 0 { gp lineto line to float current x 0 float current y 0 } else { gp quadto quad to float current x 1 float current y 1 float current x 0 float current y 0 } } else { if current mask C1_MASK == 0 { gp quadto quad to float previous x 2 float previous y 2 float current x 0 float current y 0 } else { gp curveto curve to float previous x 2 float previous y 2 float current x 1 float current y 1 float current x 0 float current y 0 } } } if isclosed is closed { if size > 1 { previous = get size 1 current = get 0 if previous mask C2_MASK == 0 { if current mask C1_MASK == 0 { gp lineto line to float current x 0 float current y 0 } else { gp quadto quad to float current x 1 float current y 1 float current x 0 float current y 0 } } else { if current mask C1_MASK == 0 { gp quadto quad to float previous x 2 float previous y 2 float current x 0 float current y 0 } else { gp curveto curve to float previous x 2 float previous y 2 float current x 1 float current y 1 float current x 0 float current y 0 } } } gp closepath close path } } gp } contains point2d point2 d p { validatepath validate path generalpath general path contains p } outlinecontains outline contains point2d point2 d p tolerance { validatepath validate path pathiterator path iterator i = generalpath general path getpathiterator get path iterator new affinetransform affine transform tolerance coords = new 6 type = i currentsegment current segment coords prevx prev x = coords 0 prevy prev y = coords 1 i next while ! i isdone is done { i currentsegment current segment coords if geom linecontainspoint line contains point prevx prev x prevy prev y coords 0 coords 1 p x p y tolerance { } prevx prev x = coords 0 prevy prev y = coords 1 i next } } intersects rectangle2d rectangle2 d r { validatepath validate path generalpath general path intersects r } pathiterator path iterator getpathiterator get path iterator affinetransform affine transform at { validatepath validate path generalpath general path getpathiterator get path iterator at } contains rectangle2d rectangle2 d r { validatepath validate path generalpath general path contains r } pathiterator path iterator getpathiterator get path iterator affinetransform affine transform at flatness { validatepath validate path generalpath general path getpathiterator get path iterator at flatness } intersects x y w h { validatepath validate path generalpath general path intersects x y w h } rectangle2d rectangle2 d getbounds2d get bounds2 d { validatepath validate path generalpath general path getbounds2d get bounds2 d } rectangle2d rectangle2 d getbounds2ddouble get bounds2 d { validatepath validate path rectangle2d rectangle2 d r = generalpath general path getbounds2d get bounds2 d if r instanceof rectangle2d rectangle2 d { rectangle2d rectangle2 d r } else { new rectangle2d rectangle2 d r getx get x r gety get y r getwidth get width r getheight get height } } rectangle getbounds get bounds { validatepath validate path generalpath general path getbounds get bounds } contains x y w h { validatepath validate path generalpath general path contains x y w h } contains x y { validatepath validate path generalpath general path contains x y } setclosed set closed newvalue new value { if isclosed is closed != newvalue new value { isclosed is closed = newvalue new value invalidatepath invalidate path } } isclosed is closed { isclosed is closed } clone { bezierpath bezier path that = bezierpath bezier path super clone for i=0 n = this size i < n i++ { that set i node this get i clone } that } transform affinetransform affine transform tx { point2d point2 d p = new point2d point2 d for node cp this { for i=0 i < 3 i++ { p x = cp x i p y = cp y i tx transform p p cp x i = p x cp y i = p y } } invalidatepath invalidate path } setto set to bezierpath bezier path that { while that size < size { remove size 1 } for i=0 n = size i < n i++ { get i setto set to that get i } while size < that size { add node that get size clone } } point2d point2 d getcenter get center { sx = 0 sy = 0 for node p this { sx += p x 0 sy += p y 0 } n = size new point2d point2 d sx / n sy / n } point2d point2 d chop point2d point2 d p { validatepath validate path geom chop generalpath general path p } indexofoutermostnode index of outermost node { if outer == 1 { point2d point2 d ctr = getcenter get center outer = 0 dist = 0 for i = 0 n = size i < n i++ { node cp = get i d = geom length2 ctr x ctr y cp x 0 cp y 0 if d > dist { dist = d outer = i } } } outer } point2d point2 d getpointonpath get point on path relative flatness { if size == 0 { } else if size == 1 { get 0 getcontrolpoint get control point 0 } if relative <= 0 { get 0 getcontrolpoint get control point 0 } else if relative >= 1 { get size 1 getcontrolpoint get control point 0 } validatepath validate path len = 0 pathiterator path iterator i = generalpath general path getpathiterator get path iterator new affinetransform affine transform flatness coords = new 6 type = i currentsegment current segment coords prevx prev x = coords 0 prevy prev y = coords 1 i next for ! i isdone is done i next { i currentsegment current segment coords len += geom length prevx prev x prevy prev y coords 0 coords 1 prevx prev x = coords 0 prevy prev y = coords 1 } relativelen relative len = len * relative pos = 0 i = generalpath general path getpathiterator get path iterator new affinetransform affine transform flatness type = i currentsegment current segment coords prevx prev x = coords 0 prevy prev y = coords 1 i next for ! i isdone is done i next { i currentsegment current segment coords seglen seg len = geom length prevx prev x prevy prev y coords 0 coords 1 if pos + seglen seg len >= relativelen relative len { factor = relativelen relative len pos / seglen seg len new point2d point2 d prevx prev x * 1 factor + coords 0 * factor prevy prev y * 1 factor + coords 1 * factor } pos += seglen seg len prevx prev x = coords 0 prevy prev y = coords 1 } throw new internalerror internal we should never get here } findsegment find segment point2d point2 d find float tolerance { node v1 v2 bezierpath bezier path temppath temp path = new bezierpath bezier path node t1 t2 temppath temp path add t1 = new node temppath temp path add t2 = new node for i = 0 n = size 1 i < n i++ { v1 = get i v2 = get i+1 if v1 mask == 0 v2 mask == 0 { if geom linecontainspoint line contains point v1 x 0 v1 y 0 v2 x 0 v2 y 0 find x find y tolerance { i } } else { t1 setto set to v1 t2 setto set to v2 temppath temp path invalidatepath invalidate path if temppath temp path outlinecontains outline contains find tolerance { i } } } if isclosed is closed size > 1 { v1 = get size 1 v2 = get 0 if v1 mask == 0 v2 mask == 0 { if geom linecontainspoint line contains point v1 x 0 v1 y 0 v2 x 0 v2 y 0 find x find y tolerance { size 1 } } else { t1 setto set to v1 t2 setto set to v2 temppath temp path invalidatepath invalidate path if temppath temp path outlinecontains outline contains find tolerance { size 1 } } } 1 } joinsegments join segments point2d point2 d join float tolerance { for i=0 i < size i++ { node p = get i if geom length p x 0 p y 0 join x join y < tolerance { remove i i } } 1 } splitsegment split segment point2d point2 d split float tolerance { i = findsegment find segment split tolerance nexti next i = i + 1 % size if i != 1 { if get i mask C2_MASK == C2_MASK get nexti next i mask C1_MASK == 0 { add i + 1 new node C2_MASK split split split } else if get i mask C2_MASK == 0 get nexti next i mask C1_MASK == C1_MASK { add i + 1 new node C2_MASK split split split } else if get i mask C2_MASK == C2_MASK get nexti next i mask C1_MASK == C2_MASK { add i + 1 new node C1_MASK | C2_MASK split split split } else { add i + 1 new node split } } i+1 } moveto move to x1 y1 { if size != 0 { throw new illegalpathstateexception illegal path state moveto move to only allowed when empty } add new node x1 y1 } lineto line to x1 y1 { if size == 0 { throw new illegalpathstateexception illegal path state lineto line to only allowed when not empty } add new node x1 y1 } quadto quad to x1 y1 x2 y2 { if size == 0 { throw new illegalpathstateexception illegal path state quadto quad to only allowed when not empty } add new node C1_MASK x2 y2 x1 y1 x2 y2 } curveto curve to x1 y1 x2 y2 x3 y3 { if size == 0 { throw new illegalpathstateexception illegal path state curveto curve to only allowed when not empty } node lastpoint last point = get size 1 lastpoint last point mask |= C2_MASK lastpoint last point x 2 = x1 lastpoint last point y 2 = y1 add new node C1_MASK x3 y3 x2 y2 x3 y3 } point2d point2 d topolygonarray to polygon { point2d point2 d points = new point2d point2 d size for i=0 n = size i < n i++ { points i = new point2d point2 d get i x 0 get i y 0 } points } } 