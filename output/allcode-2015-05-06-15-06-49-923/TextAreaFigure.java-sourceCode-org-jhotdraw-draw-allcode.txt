org jhotdraw draw import org jhotdraw util * import awt * import awt font * import awt geom * import text * import util * import io * import org jhotdraw draw attributekeys attribute keys * import org jhotdraw geom * import org jhotdraw xml dominput dom input import org jhotdraw xml domoutput dom output textareafigure text area figure attributedfigure attributed figure implements textholder text holder { private rectangle2d rectangle2 d bounds = new rectangle2d rectangle2 d private editable = private basicstroke basic stroke dashes = new basicstroke basic stroke 1f basicstroke basic stroke CAP_BUTT basicstroke basic stroke JOIN_BEVEL 0f new float {4f 4f} 0f transient private textlayout text layout textlayout text layout textareafigure text area figure { this text } textareafigure text area figure text { settext set text text } gettext get text { getattribute get attribute text t e x t } settext set text newtext new text { setattribute set attribute text t e x t newtext new text } basicsetbounds basic set bounds point2d point2 d anchor point2d point2 d { bounds x = math min anchor x x bounds y = math min anchor y y bounds width = math max 1 math abs x anchor x bounds height = math max 1 math abs y anchor y textlayout text layout = } basictransform basic transform affinetransform affine transform tx { point2d point2 d anchor = getstartpoint get start point point2d point2 d = getendpoint get end point basicsetbounds basic set bounds point2d point2 d tx transform anchor anchor point2d point2 d tx transform } contains point2d point2 d p { bounds contains p } insets2ddouble insets2 d getinsets get insets { sw = math ceil STROKE_WIDTH get this / 2 insets2ddouble insets2 d insets = new insets2ddouble insets2 d 4 4 4 4 new insets2ddouble insets2 d insets top+sw insets left+sw insets bottom+sw insets right+sw } gettabsize get tab size { 8 } drawtext draw text graphics2d graphics2 d g { if gettext get text != || iseditable is editable { font font = getfont get font isunderlined is underlined = FONT_UNDERLINED get this insets2ddouble insets2 d insets = getinsets get insets rectangle2d rectangle2 d textrect text rect = new rectangle2d rectangle2 d bounds x + insets left bounds y + insets top bounds width insets left insets right bounds height insets top insets bottom float leftmargin left margin = float textrect text rect x float rightmargin right margin = float math max leftmargin left margin + 1 textrect text rect x + textrect text rect width float verticalpos vertical pos = float textrect text rect y if leftmargin left margin < rightmargin right margin { float tabwidth tab width = float gettabsize get tab size * g getfontmetrics get font metrics font charwidth char width 'm' float tabstops tab stops = new float textrect text rect width / tabwidth tab width for i=0 i < tabstops tab stops length i++ { tabstops tab stops i = float textrect text rect x + tabwidth tab width * i + 1 } if gettext get text != { shape savedcliparea saved clip area = g getclip get clip g clip textrect text rect paragraphs = gettext get text split \n for i = 0 i < paragraphs length i++ { if paragraphs i length == 0 paragraphs i = attributedstring attributed as = new attributedstring attributed paragraphs i as addattribute add attribute textattribute text attribute font f o n t font if isunderlined is underlined { as addattribute add attribute textattribute text attribute underline u n d e r l i n e textattribute text attribute UNDERLINE_LOW_ONE_PIXEL } tabcount tab count = new stringtokenizer tokenizer paragraphs i \t counttokens count tokens 1 verticalpos vertical pos = drawparagraph draw paragraph g as getiterator get iterator verticalpos vertical pos leftmargin left margin rightmargin right margin tabstops tab stops tabcount tab count if verticalpos vertical pos > textrect text rect y + textrect text rect height { break } } g setclip set clip savedcliparea saved clip area } } if leftmargin left margin >= rightmargin right margin || verticalpos vertical pos > textrect text rect y + textrect text rect height { g setcolor set color color red g setstroke set stroke dashes g draw new line2d line2 d textrect text rect x textrect text rect y + textrect text rect height 1 textrect text rect x + textrect text rect width 1 textrect text rect y + textrect text rect height 1 } } } private float drawparagraph draw paragraph graphics2d graphics2 d g attributedcharacteriterator attributed character iterator styledtext styled text float verticalpos vertical pos float leftmargin left margin float rightmargin right margin float tabstops tab stops tabcount tab count { tablocations tab locations = new tabcount+1 tab count+1 i = 0 for char c = styledtext styled text first c != styledtext styled text done d o n e c = styledtext styled text next { if c == '\t' { tablocations tab locations i++ = styledtext styled text getindex get index } } tablocations tab locations tabcount tab count = styledtext styled text getendindex get end index 1 linebreakmeasurer line break measurer measurer = new linebreakmeasurer line break measurer styledtext styled text getfontrendercontext get font render context currenttab current tab = 0 while measurer getposition get position < styledtext styled text getendindex get end index { linecontainstext line contains text = linecomplete line complete = float maxascent max ascent = 0 maxdescent max descent = 0 float horizontalpos horizontal pos = leftmargin left margin linkedlist<textlayout> linked list< text layout> layouts = new linkedlist<textlayout> linked list< text layout> linkedlist<float> linked list< float> penpositions pen positions = new linkedlist<float> linked list< float> while !linecomplete !line complete { float wrappingwidth wrapping width = rightmargin right margin horizontalpos horizontal pos textlayout text layout layout = layout = measurer nextlayout next layout wrappingwidth wrapping width tablocations tab locations currenttab current tab +1 linecontainstext line contains text if layout != { layouts add layout penpositions pen positions add horizontalpos horizontal pos horizontalpos horizontal pos += layout getadvance get advance maxascent max ascent = math max maxascent max ascent layout getascent get ascent maxdescent max descent = math max maxdescent max descent layout getdescent get descent + layout getleading get leading } else { linecomplete line complete = } linecontainstext line contains text = if measurer getposition get position == tablocations tab locations currenttab current tab +1 { currenttab++ current tab++ } if measurer getposition get position == styledtext styled text getendindex get end index linecomplete line complete = else if tabstops tab stops length == 0 || horizontalpos horizontal pos >= tabstops tab stops tabstops tab stops length 1 linecomplete line complete = if !linecomplete !line complete { j for j=0 horizontalpos horizontal pos >= tabstops tab stops j j++ {} horizontalpos horizontal pos = tabstops tab stops j } } verticalpos vertical pos += maxascent max ascent iterator<textlayout> iterator< text layout> layoutenum layout enum = layouts iterator iterator<float> iterator< float> positionenum position enum = penpositions pen positions iterator while layoutenum layout enum hasnext has next { textlayout text layout nextlayout next layout = layoutenum layout enum next float nextposition next position = positionenum position enum next nextlayout next layout draw g nextposition next position verticalpos vertical pos } verticalpos vertical pos += maxdescent max descent } verticalpos vertical pos } drawfill draw fill graphics2d graphics2 d g { g fill bounds } drawstroke draw stroke graphics2d graphics2 d g { g draw bounds } rectangle2d rectangle2 d getbounds get bounds { rectangle2d rectangle2 d bounds getbounds2d get bounds2 d } collection<handle> collection< handle> createhandles create handles detaillevel detail level { linkedlist<handle> linked list< handle> handles = linkedlist<handle> linked list< handle> super createhandles create handles detaillevel detail level if detaillevel detail level == 0 { handles add new fontsizehandle font size handle this } handles } validate { super validate textlayout text layout = } iseditable is editable { editable } seteditable set editable b { this editable = b } gettextcolumns get text columns { gettext get text == ? 4 math max gettext get text length 4 } tool gettool get tool point2d point2 d p { iseditable is editable contains p ? new textareatool text area tool this } readbounds read bounds dominput dom input in ioexception i o { bounds x = in getattribute get attribute x 0d bounds y = in getattribute get attribute y 0d bounds width = in getattribute get attribute w 0d bounds height = in getattribute get attribute h 0d } writebounds write bounds domoutput dom output out ioexception i o { out addattribute add attribute x bounds x out addattribute add attribute y bounds y out addattribute add attribute w bounds width out addattribute add attribute h bounds height } read dominput dom input in ioexception i o { readbounds read bounds in readattributes read attributes in textlayout text layout = } write domoutput dom output out ioexception i o { writebounds write bounds out writeattributes write attributes out } textareafigure text area figure clone { textareafigure text area figure that = textareafigure text area figure super clone that bounds = rectangle2d rectangle2 d this bounds clone that } textholder text holder getlabelfor get label for { this } restoreto restore to geometry { rectangle2d rectangle2 d r = rectangle2d rectangle2 d geometry bounds x = r x bounds y = r y bounds width = r width bounds height = r height } getrestoredata get restore data { bounds clone } font getfont get font { attributekeys attribute keys getfont get font this } color gettextcolor get text color { TEXT_COLOR get this } color getfillcolor get fill color { FILL_COLOR get this } setfontsize set font size float size { FONT_SIZE set this new size } float getfontsize get font size { FONT_SIZE get this floatvalue float value } } 