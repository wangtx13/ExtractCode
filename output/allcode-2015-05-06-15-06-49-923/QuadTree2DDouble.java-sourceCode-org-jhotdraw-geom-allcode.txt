org jhotdraw geom import awt geom * import util * import awt * quadtree2ddouble<t> quad tree2 d double< t> { private hashmap<t hash map< t rectangle2d rectangle2 d double> outside = new hashmap<t hash map< t rectangle2d rectangle2 d double> private quadnode quad node root private maxcapacity max capacity = 32 private minsize min size = 32 private maxoutside max outside = 32 quadtree2ddouble quad tree2 d { root = new quadnode quad node new rectangle2d rectangle2 d 0 0 800 600 } quadtree2ddouble quad tree2 d rectangle2d rectangle2 d bounds { root = new quadnode quad node bounds } add t o rectangle2d rectangle2 d bounds { if root bounds contains bounds { root add o rectangle2d rectangle2 d bounds clone } else { outside put o rectangle2d rectangle2 d bounds clone if outside size > maxoutside max outside { reorganize } } } reorganize { root join outside putall put all root root clear iterator<map iterator< map entry<t entry< t rectangle2d rectangle2 d double>> i = outside entryset entry set iterator map entry<t entry< t rectangle2d rectangle2 d double> entry = i next rectangle2d rectangle2 d treebounds tree bounds = rectangle2d rectangle2 d entry getvalue get value clone while i hasnext has next { entry = i next rectangle2d rectangle2 d bounds = entry getvalue get value treebounds tree bounds add bounds } root bounds = treebounds tree bounds i = outside entryset entry set iterator while i hasnext has next { entry = i next root add entry getkey get key entry getvalue get value } outside clear } remove t o { outside remove o root remove o } collection<t> collection< t> findcontains find contains point2d point2 d p { hashset<t> hash set< t> result = new hashset<t> hash set< t> root findcontains find contains p result for map entry<t entry< t rectangle2d rectangle2 d double> entry outside entryset entry set { if entry getvalue get value contains p { result add entry getkey get key } } result } collection<t> collection< t> findintersects find intersects rectangle2d rectangle2 d r { findintersects find intersects new rectangle2d rectangle2 d r getx get x r gety get y r getwidth get width r getheight get height } collection<t> collection< t> findintersects find intersects rectangle2d rectangle2 d r { hashset<t> hash set< t> result = new hashset<t> hash set< t> root findintersects find intersects r result for map entry<t entry< t rectangle2d rectangle2 d double> entry outside entryset entry set { if entry getvalue get value intersects r { result add entry getkey get key } } result } collection<t> collection< t> findinside find inside rectangle2d rectangle2 d r { hashset<t> hash set< t> result = new hashset<t> hash set< t> root findinside find inside r result for map entry<t entry< t rectangle2d rectangle2 d double> entry outside entryset entry set { if r contains entry getvalue get value { result add entry getkey get key } } result } private quadnode quad node { private rectangle2d rectangle2 d bounds private hashmap<t hash map< t rectangle2d rectangle2 d double> private quadnode quad node northeast north east private quadnode quad node northwest north west private quadnode quad node southeast south east private quadnode quad node southwest south west quadnode quad node rectangle2d rectangle2 d bounds { this bounds = bounds this = new hashmap<t hash map< t rectangle2d rectangle2 d double> } isleaf is leaf { northeast north east == } remove t o { if remove o == ! isleaf is leaf { northeast north east remove o northwest north west remove o southeast south east remove o southwest south west remove o } } add t o rectangle2d rectangle2 d obounds o bounds { if isleaf is leaf size >= maxcapacity max capacity bounds width > minsize min size bounds height > minsize min size { split } if isleaf is leaf || obounds o bounds contains bounds { put o obounds o bounds } else { if northeast north east bounds intersects obounds o bounds { northeast north east add o obounds o bounds } if northwest north west bounds intersects obounds o bounds { northwest north west add o obounds o bounds } if southeast south east bounds intersects obounds o bounds { southeast south east add o obounds o bounds } if southwest south west bounds intersects obounds o bounds { southwest south west add o obounds o bounds } } } split { if isleaf is leaf { hw = bounds width / 2 hh = bounds height / 2 northwest north west = new quadnode quad node new rectangle2d rectangle2 d bounds x bounds y hw hh northeast north east = new quadnode quad node new rectangle2d rectangle2 d bounds x + hw bounds y bounds width hw hh southwest south west = new quadnode quad node new rectangle2d rectangle2 d bounds x bounds y + hh hw bounds height hh southeast south east = new quadnode quad node new rectangle2d rectangle2 d bounds x + hw bounds y + hh bounds width hw bounds height hh hashmap<t hash map< t rectangle2d rectangle2 d double> temp = = new hashmap<t hash map< t rectangle2d rectangle2 d double> for map entry<t entry< t rectangle2d rectangle2 d double> entry temp entryset entry set { add entry getkey get key entry getvalue get value } } } join { if ! isleaf is leaf { northwest north west join northeast north east join southwest south west join southeast south east join putall put all northwest north west putall put all northeast north east putall put all southwest south west putall put all southeast south east northwest north west = northeast north east = southwest south west = southeast south east = } } findcontains find contains point2d point2 d p hashset<t> hash set< t> result { if bounds contains p { for map entry<t entry< t rectangle2d rectangle2 d double> entry entryset entry set { if entry getvalue get value contains p { result add entry getkey get key } } if ! isleaf is leaf { northwest north west findcontains find contains p result northeast north east findcontains find contains p result southwest south west findcontains find contains p result southeast south east findcontains find contains p result } } } findintersects find intersects rectangle2d rectangle2 d r hashset<t> hash set< t> result { if bounds intersects r { oldsize old size = result size for map entry<t entry< t rectangle2d rectangle2 d double> entry entryset entry set { if entry getvalue get value intersects r { result add entry getkey get key } } if ! isleaf is leaf { northwest north west findintersects find intersects r result northeast north east findintersects find intersects r result southwest south west findintersects find intersects r result southeast south east findintersects find intersects r result } } } findinside find inside rectangle2d rectangle2 d r hashset<t> hash set< t> result { if bounds intersects r { for map entry<t entry< t rectangle2d rectangle2 d double> entry entryset entry set { if r contains entry getvalue get value { result add entry getkey get key } } if ! isleaf is leaf { northwest north west findinside find inside r result northeast north east findinside find inside r result southwest south west findinside find inside r result southeast south east findinside find inside r result } } } } } 