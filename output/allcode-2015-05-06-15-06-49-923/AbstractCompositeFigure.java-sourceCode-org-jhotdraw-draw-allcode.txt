org jhotdraw draw import io ioexception i o import org jhotdraw util * import org jhotdraw util * import awt * import awt geom * import util * import javax swing event * import javax swing undo * import org jhotdraw geom * import org jhotdraw xml dominput dom input import org jhotdraw xml domoutput dom output abstractcompositefigure composite figure abstractfigure figure implements compositefigure composite figure { private linkedlist<figure> linked list< figure> children = new linkedlist<figure> linked list< figure> private rectangle2d rectangle2 d drawbounds draw bounds private rectangle2d rectangle2 d bounds private layouter layouter private childhandler child handler childhandler child handler = new childhandler child handler this private childhandler child handler implements figurelistener figure listener undoableeditlistener undoable edit listener { private abstractcompositefigure composite figure owner private childhandler child handler abstractcompositefigure composite figure owner { this owner = owner } figurerequestremove figure request remove figureevent figure event e { owner remove e getfigure get figure } figureremoved figure removed figureevent figure event evt { } figurechanged figure changed figureevent figure event e { if ! owner ischanging is changing { owner willchange will change owner firefigurechanged fire figure changed e owner changed } } figureadded figure added figureevent figure event e { } figureattributechanged figure attribute changed figureevent figure event e { } figureareainvalidated figure area invalidated figureevent figure event e { if ! owner ischanging is changing { owner fireareainvalidated fire area invalidated e getinvalidatedarea get invalidated area } } undoableedithappened undoable edit happened undoableeditevent undoable edit event e { owner fireundoableedithappened fire undoable edit happened e getedit get edit } } abstractcompositefigure composite figure { } collection<handle> collection< handle> createhandles create handles detaillevel detail level { if detaillevel detail level == 0 { super createhandles create handles 0 } linkedlist<handle> linked list< handle> handles = new linkedlist<handle> linked list< handle> handles } add figure figure { add getchildcount get child count figure } add index figure figure { willchange will change basicadd basic add index figure if getdrawing get drawing != { figure addnotify add notify getdrawing get drawing } changed } addall add all collection<figure> collection< figure> newfigures new figures { willchange will change for figure f newfigures new figures { basicadd basic add getchildcount get child count f if getdrawing get drawing != { f addnotify add notify getdrawing get drawing } } changed } basicadd basic add figure figure { basicadd basic add getchildcount get child count figure } basicadd basic add index figure figure { children add index figure figure addfigurelistener add figure listener childhandler child handler figure addundoableeditlistener add undoable edit listener childhandler child handler } basicaddall basic add all collection<figure> collection< figure> newfigures new figures { for figure f newfigures new figures { basicadd basic add getchildcount get child count f } } addnotify add notify drawing drawing { super addnotify add notify drawing for figure child children { child addnotify add notify drawing } } removenotify remove notify drawing drawing { for figure child new linkedlist<figure> linked list< figure> children { child removenotify remove notify drawing } super removenotify remove notify drawing } remove figure figure { index = children indexof index of figure if index == 1 { } else { willchange will change basicremovechild basic remove child index if getdrawing get drawing != { figure removenotify remove notify getdrawing get drawing } changed } } figure removechild remove child index { willchange will change figure removed = basicremovechild basic remove child index if getdrawing get drawing != { removed removenotify remove notify getdrawing get drawing } changed removed } basicremove basic remove figure figure { index = children indexof index of figure if index == 1 { } else { basicremovechild basic remove child index } } figure basicremovechild basic remove child index { figure figure = children remove index figure removefigurelistener remove figure listener childhandler child handler figure removeundoableeditlistener remove undoable edit listener childhandler child handler figure } removeallchildren remove all children { willchange will change while children size > 0 { figure f = basicremovechild basic remove child children size 1 if getdrawing get drawing != { f addnotify add notify getdrawing get drawing } } changed } basicremoveallchildren basic remove all children { while children size > 0 { figure f = basicremovechild basic remove child children size 1 } } synchronized sendtoback send to back figure figure { if children remove figure { children add 0 figure figure invalidate } } synchronized sendtofront send to front figure figure { if children remove figure { children add figure figure invalidate } } basictransform basic transform affinetransform affine transform tx { for figure f children { f basictransform basic transform tx } invalidatebounds invalidate bounds } basicsetbounds basic set bounds point2d point2 d anchor point2d point2 d { rectangle2d rectangle2 d oldbounds old bounds = getbounds get bounds rectangle2d rectangle2 d newbounds new bounds = new rectangle2d rectangle2 d math min anchor x x math min anchor y y math abs anchor x x math abs anchor y y sx = newbounds new bounds width / oldbounds old bounds width sy = newbounds new bounds height / oldbounds old bounds height affinetransform affine transform tx = new affinetransform affine transform tx translate oldbounds old bounds x oldbounds old bounds y if ! isnan is na n sx ! isnan is na n sy sx != 1d || sy != 1d ! sx < 0 0001 ! sy < 0 0001 { basictransform basic transform tx tx settoidentity set to identity tx scale sx sy basictransform basic transform tx tx settoidentity set to identity } tx translate newbounds new bounds x newbounds new bounds y basictransform basic transform tx } undoableedithappened undoable edit happened undoableeditevent undoable edit event e { fireundoableedithappened fire undoable edit happened e getedit get edit } util list<figure> list< figure> getchildren get children { collections unmodifiablelist unmodifiable list children } getchildcount get child count { children size } figure getchild get child index { children get index } util list<figure> list< figure> getchildrenfronttoback get children front to back { children == ? new linkedlist<figure> linked list< figure> new reversedlist<figure> reversed list< figure> children } setattribute set attribute attributekey attribute key name value { willchange will change for figure child children { child setattribute set attribute name value } changed } basicsetattribute basic set attribute attributekey attribute key name value { for figure child children { child basicsetattribute basic set attribute name value } } getattribute get attribute attributekey attribute key name { } contains point2d point2 d p { if getdrawbounds get draw bounds contains p { for figure child getchildrenfronttoback get children front to back { if child isvisible is visible child contains p } } } figure findfigureinside find figure inside point2d point2 d p { if getdrawbounds get draw bounds contains p { figure found = for figure child getchildrenfronttoback get children front to back { if child isvisible is visible { found = child findfigureinside find figure inside p if found != { found } } } } } figure findchild find child point2d point2 d p { if getbounds get bounds contains p { figure found = for figure child getchildrenfronttoback get children front to back { if child isvisible is visible child contains p { child } } } } findchildindex find child index point2d point2 d p { figure child = findchild find child p child == ? 1 children indexof index of child } layouter getlayouter get layouter { layouter } layout { if getlayouter get layouter != { rectangle2d rectangle2 d bounds = getbounds get bounds point2d point2 d p = new point2d point2 d bounds x bounds y rectangle2d rectangle2 d r = getlayouter get layouter layout this p p basicsetbounds basic set bounds new point2d point2 d r x r y new point2d point2 d r x + r width r y + r height invalidatebounds invalidate bounds } } setlayouter set layouter layouter newlayouter new layouter { this layouter = newlayouter new layouter } dimension2ddouble dimension2 d getpreferredsize get preferred size { if this layouter != { rectangle2d rectangle2 d r = layouter calculatelayout calculate layout this getstartpoint get start point getendpoint get end point new dimension2ddouble dimension2 d r width r height } else { super getpreferredsize get preferred size } } rectangle2d rectangle2 d getfiguredrawbounds get figure draw bounds { if drawbounds draw bounds == { for figure child getchildrenfronttoback get children front to back { if child isvisible is visible { rectangle2d rectangle2 d childbounds child bounds = child getdrawbounds get draw bounds if ! childbounds child bounds isempty is empty { if drawbounds draw bounds == { drawbounds draw bounds = childbounds child bounds } else { drawbounds draw bounds add childbounds child bounds } } } } } drawbounds draw bounds == ? new rectangle2d rectangle2 d 0 0 1 1 rectangle2d rectangle2 d drawbounds draw bounds clone } rectangle2d rectangle2 d getbounds get bounds { if bounds == { for figure child getchildrenfronttoback get children front to back { if child isvisible is visible { if bounds == { bounds = child getbounds get bounds } else { bounds add child getbounds get bounds } } } } bounds == ? new rectangle2d rectangle2 d 0 0 1 1 rectangle2d rectangle2 d bounds clone } drawfigure draw figure graphics2d graphics2 d g { for figure child children { if child isvisible is visible { child draw g } } if isconnectorsvisible is connectors visible { drawconnectors draw connectors g } } drawconnectors draw connectors graphics2d graphics2 d g { } abstractcompositefigure composite figure clone { abstractcompositefigure composite figure that = abstractcompositefigure composite figure super clone that childhandler child handler = new childhandler child handler that that children = new linkedlist<figure> linked list< figure> for figure thischild this child this children { figure thatchild that child = figure thischild this child clone that children add thatchild that child thatchild that child addfigurelistener add figure listener that childhandler child handler thatchild that child addundoableeditlistener add undoable edit listener that childhandler child handler } that } invalidatebounds invalidate bounds { bounds = drawbounds draw bounds = } collection<figure> collection< figure> getdecomposition get decomposition { linkedlist<figure> linked list< figure> list = new linkedlist<figure> linked list< figure> list add this list addall add all getchildren get children list } read dominput dom input in ioexception i o { in openelement open element children for i=0 i < in getelementcount get element count i++ { add figure in readobject read i } in closeelement close element } write domoutput dom output out ioexception i o { out openelement open element children for figure child getchildren get children { out writeobject write child } out closeelement close element } map<attributekey map< attribute key object> getattributes get attributes { new hashmap<attributekey hash map< attribute key object> } restoreto restore to geometry { linkedlist linked list list = linkedlist linked list geometry index = 0 for geom list { getchild get child index restoreto restore to geom index++ } invalidatebounds invalidate bounds } getrestoredata get restore data { linkedlist<object> linked list< object> list = new linkedlist<object> linked list< object> for figure child children { list add child getrestoredata get restore data } list } willchange will change { super willchange will change if getchangingdepth get changing depth == 1 { for figure child children { child willchange will change } } } changed { if getchangingdepth get changing depth == 1 { for figure child children { child changed } } super changed } invalidate { super invalidate invalidatebounds invalidate bounds } validate { super validate layout invalidatebounds invalidate bounds } removeattribute remove attribute attributekey attribute key key { } hasattribute has attribute attributekey attribute key key { } } 