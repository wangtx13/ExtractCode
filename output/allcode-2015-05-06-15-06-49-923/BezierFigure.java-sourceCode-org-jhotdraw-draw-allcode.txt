org jhotdraw draw import org jhotdraw util * import awt * import awt event * import awt geom * import util * import javax swing undo * import io * import org jhotdraw draw attributekeys attribute keys * import org jhotdraw geom * import org jhotdraw xml dominput dom input import org jhotdraw xml domoutput dom output bezierfigure bezier figure attributedfigure attributed figure { attributekey<boolean> attribute key< boolean> closed c l o s e d = new attributekey<boolean> attribute key< boolean> closed bezierpath bezier path path private transient bezierpath bezier path cappedpath capped path bezierfigure bezier figure { this } bezierfigure bezier figure isclosed is closed { path = new bezierpath bezier path closed c l o s e d set this isclosed is closed } connector findconnector find connector point2d point2 d p connectionfigure connection figure prototype { new chopbezierconnector chop bezier connector this } connector findcompatibleconnector find compatible connector connector c isstart is start { new chopbezierconnector chop bezier connector this } drawstroke draw stroke graphics2d graphics2 d g { if isclosed is closed { grow = attributekeys attribute keys getperpendiculardrawgrowth get perpendicular draw growth this if grow == 0d { g draw path } else { growstroke grow stroke gs = new growstroke grow stroke float grow float attributekeys attribute keys getstroketotalwidth get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this g draw gs createstrokedshape create stroked shape path } } else { g draw getcappedpath get capped path } drawcaps draw caps g } drawcaps draw caps graphics2d graphics2 d g { if getpointcount get point count > 1 { if START_DECORATION get this != { bezierpath bezier path cp = getcappedpath get capped path point2d point2 d p1 = path get 0 0 point2d point2 d p2 = cp get 0 0 if p2 equals p1 { p2 = path get 1 0 } START_DECORATION get this draw g this p1 p2 } if END_DECORATION get this != { bezierpath bezier path cp = getcappedpath get capped path point2d point2 d p1 = path get path size 1 0 point2d point2 d p2 = cp get path size 1 0 if p2 equals p1 { p2 = path get path size 2 0 } END_DECORATION get this draw g this p1 p2 } } } drawfill draw fill graphics2d graphics2 d g { if isclosed is closed { grow = attributekeys attribute keys getperpendicularfillgrowth get perpendicular fill growth this if grow == 0d { g fill path } else { growstroke grow stroke gs = new growstroke grow stroke float grow float attributekeys attribute keys getstroketotalwidth get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this g fill gs createstrokedshape create stroked shape path } } } contains point2d point2 d p { if isclosed is closed { grow = attributekeys attribute keys getperpendicularhitgrowth get perpendicular hit growth this if grow == 0d { path contains p } else { growstroke grow stroke gs = new growstroke grow stroke float grow float attributekeys attribute keys getstroketotalwidth get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this gs createstrokedshape create stroked shape path contains p } } else { tolerance = math max 2f attributekeys attribute keys getstroketotalwidth get stroke total width this / 2 if getcappedpath get capped path outlinecontains outline contains p tolerance { } if START_DECORATION get this != { bezierpath bezier path cp = getcappedpath get capped path point2d point2 d p1 = path get 0 0 point2d point2 d p2 = cp get 0 0 if geom linecontainspoint line contains point p1 x p1 y p2 x p2 y p x p y tolerance { } } if END_DECORATION get this != { bezierpath bezier path cp = getcappedpath get capped path point2d point2 d p1 = path get path size 1 0 point2d point2 d p2 = cp get path size 1 0 if geom linecontainspoint line contains point p1 x p1 y p2 x p2 y p x p y tolerance { } } } } canconnect can connect { isclosed is closed } collection<handle> collection< handle> createhandles create handles detaillevel detail level { linkedlist<handle> linked list< handle> handles = new linkedlist<handle> linked list< handle> switch detaillevel detail level { case 0 boxhandlekit box handle kit addboxhandles add box handles this handles handles add new bezierscalehandle bezier scale handle this break case 1 for i=0 n = path size i < n i++ { handles add new beziernodehandle bezier node handle this i } break } handles } rectangle2d rectangle2 d getbounds get bounds { rectangle2d rectangle2 d bounds =path getbounds2ddouble get bounds2 d bounds width = math max 1 bounds width bounds height = math max 1 bounds height bounds } rectangle2d rectangle2 d getfiguredrawbounds get figure draw bounds { rectangle2d rectangle2 d r = super getfiguredrawbounds get figure draw bounds if getnodecount get node count > 1 { if START_DECORATION get this != { point2d point2 d p1 = getpoint get point 0 0 point2d point2 d p2 = getpoint get point 1 0 r add START_DECORATION get this getdrawbounds get draw bounds this p1 p2 } if END_DECORATION get this != { point2d point2 d p1 = getpoint get point getnodecount get node count 1 0 point2d point2 d p2 = getpoint get point getnodecount get node count 2 0 r add END_DECORATION get this getdrawbounds get draw bounds this p1 p2 } } r } validate { super validate path invalidatepath invalidate path invalidatecappedpath invalidate capped path } bezierpath bezier path getbezierpath get bezier path { bezierpath bezier path path clone } point2d point2 d getpointonpath get point on path float relative flatness { path getpointonpath get point on path relative flatness } basicsetbezierpath basic set bezier path bezierpath bezier path newvalue new value { this path = newvalue new value this setclosed set closed newvalue new value isclosed is closed } isclosed is closed { getattribute get attribute closed c l o s e d } setclosed set closed newvalue new value { closed c l o s e d set this newvalue new value } basicsetattribute basic set attribute attributekey attribute key key newvalue new value { if key == closed c l o s e d { path setclosed set closed newvalue new value } super basicsetattribute basic set attribute key newvalue new value } basicsetbounds basic set bounds point2d point2 d anchor point2d point2 d { basicsetstartpoint basic set start point anchor basicsetendpoint basic set end point invalidate } basictransform basic transform affinetransform affine transform tx { path transform tx invalidate } invalidate { super invalidate path invalidatepath invalidate path invalidatecappedpath invalidate capped path } invalidatecappedpath invalidate capped path { cappedpath capped path = } bezierpath bezier path getcappedpath get capped path { if cappedpath capped path == { cappedpath capped path = bezierpath bezier path path clone if isclosed is closed { cappedpath capped path setclosed set closed } else { if cappedpath capped path size > 1 { if START_DECORATION get this != { bezierpath bezier path node p0 = cappedpath capped path get 0 bezierpath bezier path node p1 = cappedpath capped path get 1 point2d point2 d pp if p0 getmask get mask bezierpath bezier path C2_MASK != 0 { pp = p0 getcontrolpoint get control point 2 } else if p1 getmask get mask bezierpath bezier path C1_MASK != 0 { pp = p1 getcontrolpoint get control point 1 } else { pp = p1 getcontrolpoint get control point 0 } radius = START_DECORATION get this getdecorationradius get decoration radius this linelength line length = geom length p0 getcontrolpoint get control point 0 pp cappedpath capped path set 0 0 geom cap pp p0 getcontrolpoint get control point 0 math min radius linelength line length } if END_DECORATION get this != { bezierpath bezier path node p0 = cappedpath capped path get cappedpath capped path size 1 bezierpath bezier path node p1 = cappedpath capped path get cappedpath capped path size 2 point2d point2 d pp if p0 getmask get mask bezierpath bezier path C1_MASK != 0 { pp = p0 getcontrolpoint get control point 1 } else if p1 getmask get mask bezierpath bezier path C2_MASK != 0 { pp = p1 getcontrolpoint get control point 2 } else { pp = p1 getcontrolpoint get control point 0 } radius = END_DECORATION get this getdecorationradius get decoration radius this linelength line length = geom length p0 getcontrolpoint get control point 0 pp cappedpath capped path set cappedpath capped path size 1 0 geom cap pp p0 getcontrolpoint get control point 0 math min radius linelength line length } cappedpath capped path invalidatepath invalidate path } } } cappedpath capped path } layout { } addnode add node bezierpath bezier path node p { addnode add node getnodecount get node count p } addnode add node index bezierpath bezier path node p { bezierpath bezier path node newpoint new point = new bezierpath bezier path node p willchange will change basicaddnode basic add node index newpoint new point layout changed fireundoableedithappened fire undoable edit happened new abstractundoableedit undoable edit { getpresentationname get presentation name { punkt einf\u00fcgen } undo cannotundoexception cannot undo { super undo willchange will change basicremovenode basic remove node index changed } redo cannotundoexception cannot undo { super redo willchange will change basicaddnode basic add node index newpoint new point changed } } } basicaddnode basic add node bezierpath bezier path node p { path add p invalidate } basicaddnode basic add node index bezierpath bezier path node p { path add index p } setnode set node index bezierpath bezier path node p { willchange will change bezierpath bezier path node oldvalue old value = path get index bezierpath bezier path node newvalue new value = new bezierpath bezier path node p basicsetnode basic set node index newvalue new value changed fireundoableedithappened fire undoable edit happened new beziernodeedit bezier node edit this index oldvalue old value newvalue new value } basicsetnode basic set node index bezierpath bezier path node p { path set index p } bezierpath bezier path node getnode get node index { bezierpath bezier path node path get index clone } point2d point2 d getpoint get point index { path get index getcontrolpoint get control point 0 } point2d point2 d getpoint get point index coord { path get index getcontrolpoint get control point coord } setpoint set point index coord point2d point2 d p { willchange will change basicsetpoint basic set point index coord p changed } basicsetpoint basic set point index point2d point2 d p { bezierpath bezier path node node = path get index dx = p x node x 0 dy = p y node y 0 for i=0 i < node x length i++ { node x i += dx node y i += dy } invalidate } basicsetpoint basic set point index coord point2d point2 d p { bezierpath bezier path node cp = new bezierpath bezier path node path get index cp setcontrolpoint set control point coord p basicsetnode basic set node index cp } basicsetstartpoint basic set start point point2d point2 d p { basicsetpoint basic set point 0 p } basicsetendpoint basic set end point point2d point2 d p { basicsetpoint basic set point getpointcount get point count 1 p } point2d point2 d getstartpoint get start point { getpoint get point 0 0 } point2d point2 d getendpoint get end point { getpoint get point getnodecount get node count 1 0 } findnode find node point2d point2 d p { bezierpath bezier path tp = path for i=0 i < tp size i++ { bezierpath bezier path node p2 = tp get i if p2 x 0 == p x p2 y 0 == p y { i } } 1 } removeallnodes remove all nodes { willchange will change basicremoveallnodes basic remove all nodes changed } removenode remove node index { bezierpath bezier path node oldpoint old point = new bezierpath bezier path node path get index willchange will change basicremovenode basic remove node index layout changed fireundoableedithappened fire undoable edit happened new abstractundoableedit undoable edit { getpresentationname get presentation name { punkt entfernen } undo cannotundoexception cannot undo { super undo willchange will change basicaddnode basic add node index oldpoint old point changed } redo cannotundoexception cannot undo { super redo basicremovenode basic remove node index changed } } } findsegment find segment point2d point2 d find { point2d point2 d p1 p2 for i = 0 n = getnodecount get node count 1 i < n i++ { p1 = path get i 0 p2 = path get i+1 0 if geom linecontainspoint line contains point p1 x p1 y p2 x p2 y find x find y 3d { i } } 1 } basicjoinsegments basic join segments point2d point2 d join { i = findsegment find segment join if i != 1 i > 1 { removenode remove node i } } basicsplitsegment basic split segment point2d point2 d split { i = findsegment find segment split if i != 1 { addnode add node i + 1 new bezierpath bezier path node split } i+1 } basicremovenode basic remove node index { path remove index } basicremoveallnodes basic remove all nodes { path clear } getnodecount get node count { path size } getpointcount get point count { path size } bezierfigure bezier figure clone { bezierfigure bezier figure that = bezierfigure bezier figure super clone that path = bezierpath bezier path this path clone that invalidate that } restoreto restore to geometry { path setto set to bezierpath bezier path geometry } getrestoredata get restore data { path clone } point2d point2 d chop point2d point2 d p { if isclosed is closed { grow = attributekeys attribute keys getperpendicularhitgrowth get perpendicular hit growth this if grow == 0d { path chop p } else { growstroke grow stroke gs = new growstroke grow stroke float grow float attributekeys attribute keys getstroketotalwidth get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this geom chop gs createstrokedshape create stroked shape path p } } else { path chop p } } point2d point2 d getcenter get center { path getcenter get center } point2d point2 d getoutermostpoint get outermost point { path get path indexofoutermostnode index of outermost node getcontrolpoint get control point 0 } basicjoinsegments basic join segments point2d point2 d join float tolerance { path joinsegments join segments join tolerance } basicsplitsegment basic split segment point2d point2 d split float tolerance { path splitsegment split segment split tolerance } handlemouseclick handle mouse click point2d point2 d p mouseevent mouse event evt drawingview drawing view view { if evt getclickcount get click count == 2 view gethandledetaillevel get handle detail level == 1 { willchange will change index = basicsplitsegment basic split segment p float 5f / view getscalefactor get scale factor if index != 1 { bezierpath bezier path node newnode new node = getnode get node index fireundoableedithappened fire undoable edit happened new abstractundoableedit undoable edit { redo cannotredoexception cannot redo { super redo willchange will change basicaddnode basic add node index newnode new node changed } undo cannotundoexception cannot undo { super undo willchange will change basicremovenode basic remove node index changed } } changed } } } write domoutput dom output out ioexception i o { writepoints write points out writeattributes write attributes out } writepoints write points domoutput dom output out ioexception i o { out openelement open element points if isclosed is closed { out addattribute add attribute closed } for i=0 n = getnodecount get node count i < n i++ { bezierpath bezier path node node = getnode get node i out openelement open element p if node mask != 0 { out addattribute add attribute mask node mask } if ! node keepcolinear keep colinear { out addattribute add attribute colinear } out addattribute add attribute x node x 0 out addattribute add attribute y node y 0 if node x 1 != node x 0 || node y 1 != node y 0 { out addattribute add attribute c1x node x 1 out addattribute add attribute c1y node y 1 } if node x 2 != node x 0 || node y 2 != node y 0 { out addattribute add attribute c2x node x 2 out addattribute add attribute c2y node y 2 } out closeelement close element } out closeelement close element } @override @ override read dominput dom input in ioexception i o { readpoints read points in readattributes read attributes in } readpoints read points dominput dom input in ioexception i o { path clear in openelement open element points setclosed set closed in getattribute get attribute closed for i=0 n = in getelementcount get element count p i < n i++ { in openelement open element p i bezierpath bezier path node node = new bezierpath bezier path node in getattribute get attribute mask 0 in getattribute get attribute x 0d in getattribute get attribute y 0d in getattribute get attribute c1x in getattribute get attribute x 0d in getattribute get attribute c1y in getattribute get attribute y 0d in getattribute get attribute c2x in getattribute get attribute x 0d in getattribute get attribute c2y in getattribute get attribute y 0d node keepcolinear keep colinear = in getattribute get attribute colinear path add node path invalidatepath invalidate path in closeelement close element } in closeelement close element } } 