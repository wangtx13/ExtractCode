net n3 nanoxml import io reader import io ioexception i o import io stringreader reader import util enumeration import util hashtable import util properties import util stack nonvalidator non validator implements ixmlvalidator i xml validator { ixmlentityresolver i xml entity resolver parameterentityresolver parameter entity resolver hashtable attributedefaultvalues attribute default values stack currentelements current elements nonvalidator non validator { this attributedefaultvalues attribute default values = new hashtable this currentelements current elements = new stack this parameterentityresolver parameter entity resolver = new xmlentityresolver xml entity resolver } finalize throwable { this parameterentityresolver parameter entity resolver = this attributedefaultvalues attribute default values clear this attributedefaultvalues attribute default values = this currentelements current elements clear this currentelements current elements = super finalize } setparameterentityresolver set parameter entity resolver ixmlentityresolver i xml entity resolver resolver { this parameterentityresolver parameter entity resolver = resolver } ixmlentityresolver i xml entity resolver getparameterentityresolver get parameter entity resolver { this parameterentityresolver parameter entity resolver } parsedtd parse d t d publicid ixmlreader i xml reader reader ixmlentityresolver i xml entity resolver entityresolver entity resolver external { xmlutil xml util skipwhitespace skip whitespace reader origlevel orig level = reader getstreamlevel get stream level for { str = xmlutil xml util read reader '%' char ch = str charat char at 0 if ch == '%' { xmlutil xml util processentity process entity str reader this parameterentityresolver parameter entity resolver continue } else if ch == '<' { this processelement process element reader entityresolver entity resolver } else if ch == ' ' { } else { xmlutil xml util errorinvalidinput invalid input reader getsystemid get systemid reader getlinenr get line nr str } do { ch = reader read if external reader getstreamlevel get stream level < origlevel orig level { reader unread ch } } while ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r' reader unread ch } } processelement process element ixmlreader i xml reader reader ixmlentityresolver i xml entity resolver entityresolver entity resolver { str = xmlutil xml util read reader '%' char ch = str charat char at 0 if ch != '!' { xmlutil xml util skiptag skip tag reader } str = xmlutil xml util read reader '%' ch = str charat char at 0 switch ch { case ' ' xmlutil xml util skipcomment skip comment reader break case ' ' this processconditionalsection process conditional section reader entityresolver entity resolver break case 'e' ' e' this processentity process entity reader entityresolver entity resolver break case 'a' ' a' this processattlist process att list reader entityresolver entity resolver break default xmlutil xml util skiptag skip tag reader } } processconditionalsection process conditional section ixmlreader i xml reader reader ixmlentityresolver i xml entity resolver entityresolver entity resolver { xmlutil xml util skipwhitespace skip whitespace reader str = xmlutil xml util read reader '%' char ch = str charat char at 0 if ch != 'i' ' i' { xmlutil xml util skiptag skip tag reader } str = xmlutil xml util read reader '%' ch = str charat char at 0 switch ch { case 'g' ' g' this processignoresection process ignore section reader entityresolver entity resolver case 'n' ' n' break default xmlutil xml util skiptag skip tag reader } if ! xmlutil xml util checkliteral check literal reader clude c l u d e { xmlutil xml util skiptag skip tag reader } xmlutil xml util skipwhitespace skip whitespace reader str = xmlutil xml util read reader '%' ch = str charat char at 0 if ch != ' ' { xmlutil xml util skiptag skip tag reader } reader subreader = new cdatareader c d a t a reader reader stringbuffer buffer buf = new stringbuffer buffer 1024 for { ch2 = subreader read if ch2 < 0 { break } buf append char ch2 } subreader close reader startnewstream start new stream new stringreader reader buf tostring to } processignoresection process ignore section ixmlreader i xml reader reader ixmlentityresolver i xml entity resolver entityresolver entity resolver { if ! xmlutil xml util checkliteral check literal reader nore n o r e { xmlutil xml util skiptag skip tag reader } xmlutil xml util skipwhitespace skip whitespace reader str = xmlutil xml util read reader '%' char ch = str charat char at 0 if ch != ' ' { xmlutil xml util skiptag skip tag reader } reader subreader = new cdatareader c d a t a reader reader subreader close } processattlist process att list ixmlreader i xml reader reader ixmlentityresolver i xml entity resolver entityresolver entity resolver { if ! xmlutil xml util checkliteral check literal reader ttlist t t l i s t { xmlutil xml util skiptag skip tag reader } xmlutil xml util skipwhitespace skip whitespace reader str = xmlutil xml util read reader '%' char ch = str charat char at 0 while ch == '%' { xmlutil xml util processentity process entity str reader this parameterentityresolver parameter entity resolver str = xmlutil xml util read reader '%' ch = str charat char at 0 } reader unread ch elementname element name = xmlutil xml util scanidentifier scan identifier reader xmlutil xml util skipwhitespace skip whitespace reader str = xmlutil xml util read reader '%' ch = str charat char at 0 while ch == '%' { xmlutil xml util processentity process entity str reader this parameterentityresolver parameter entity resolver str = xmlutil xml util read reader '%' ch = str charat char at 0 } properties props = new properties while ch != '>' { reader unread ch attname att name = xmlutil xml util scanidentifier scan identifier reader xmlutil xml util skipwhitespace skip whitespace reader str = xmlutil xml util read reader '%' ch = str charat char at 0 while ch == '%' { xmlutil xml util processentity process entity str reader this parameterentityresolver parameter entity resolver str = xmlutil xml util read reader '%' ch = str charat char at 0 } if ch == ' ' { while ch != ' ' { str = xmlutil xml util read reader '%' ch = str charat char at 0 while ch == '%' { xmlutil xml util processentity process entity str reader this parameterentityresolver parameter entity resolver str = xmlutil xml util read reader '%' ch = str charat char at 0 } } } else { reader unread ch xmlutil xml util scanidentifier scan identifier reader } xmlutil xml util skipwhitespace skip whitespace reader str = xmlutil xml util read reader '%' ch = str charat char at 0 while ch == '%' { xmlutil xml util processentity process entity str reader this parameterentityresolver parameter entity resolver str = xmlutil xml util read reader '%' ch = str charat char at 0 } if ch == '#' { str = xmlutil xml util scanidentifier scan identifier reader xmlutil xml util skipwhitespace skip whitespace reader if ! str equals fixed f i x e d { xmlutil xml util skipwhitespace skip whitespace reader str = xmlutil xml util read reader '%' ch = str charat char at 0 while ch == '%' { xmlutil xml util processentity process entity str reader this parameterentityresolver parameter entity resolver str = xmlutil xml util read reader '%' ch = str charat char at 0 } continue } } else { reader unread ch } value = xmlutil xml util scanstring scan reader '%' this parameterentityresolver parameter entity resolver props put attname att name value xmlutil xml util skipwhitespace skip whitespace reader str = xmlutil xml util read reader '%' ch = str charat char at 0 while ch == '%' { xmlutil xml util processentity process entity str reader this parameterentityresolver parameter entity resolver str = xmlutil xml util read reader '%' ch = str charat char at 0 } } if ! props isempty is empty { this attributedefaultvalues attribute default values put elementname element name props } } processentity process entity ixmlreader i xml reader reader ixmlentityresolver i xml entity resolver entityresolver entity resolver { if ! xmlutil xml util checkliteral check literal reader ntity n t i t y { xmlutil xml util skiptag skip tag reader } xmlutil xml util skipwhitespace skip whitespace reader char ch = xmlutil xml util readchar read char reader '\0' if ch == '%' { xmlutil xml util skipwhitespace skip whitespace reader entityresolver entity resolver = this parameterentityresolver parameter entity resolver } else { reader unread ch } key = xmlutil xml util scanidentifier scan identifier reader xmlutil xml util skipwhitespace skip whitespace reader ch = xmlutil xml util readchar read char reader '%' systemid = publicid = switch ch { case 'p' ' p' if ! xmlutil xml util checkliteral check literal reader ublic u b l i c { xmlutil xml util skiptag skip tag reader } xmlutil xml util skipwhitespace skip whitespace reader publicid = xmlutil xml util scanstring scan reader '%' this parameterentityresolver parameter entity resolver xmlutil xml util skipwhitespace skip whitespace reader systemid = xmlutil xml util scanstring scan reader '%' this parameterentityresolver parameter entity resolver xmlutil xml util skipwhitespace skip whitespace reader xmlutil xml util readchar read char reader '%' break case 's' ' s' if ! xmlutil xml util checkliteral check literal reader ystem y s t e m { xmlutil xml util skiptag skip tag reader } xmlutil xml util skipwhitespace skip whitespace reader systemid = xmlutil xml util scanstring scan reader '%' this parameterentityresolver parameter entity resolver xmlutil xml util skipwhitespace skip whitespace reader xmlutil xml util readchar read char reader '%' break case ' ' case '\'' reader unread ch value = xmlutil xml util scanstring scan reader '%' this parameterentityresolver parameter entity resolver entityresolver entity resolver addinternalentity add internal entity key value xmlutil xml util skipwhitespace skip whitespace reader xmlutil xml util readchar read char reader '%' break default xmlutil xml util skiptag skip tag reader } if systemid != { entityresolver entity resolver addexternalentity add external entity key publicid systemid } } elementstarted element started name systemid linenr line nr { properties attribs = properties this attributedefaultvalues attribute default values get name if attribs == { attribs = new properties } else { attribs = properties attribs clone } this currentelements current elements push attribs } elementended element ended name systemid linenr line nr { } elementattributesprocessed element attributes processed name properties extraattributes extra attributes systemid linenr line nr { properties props = properties this currentelements current elements pop enumeration enm = props keys while enm hasmoreelements has more elements { key = enm nextelement next element extraattributes extra attributes put key props get key } } attributeadded attribute added key value systemid linenr line nr { properties props = properties this currentelements current elements peek if props containskey contains key key { props remove key } } pcdataadded p c data added systemid linenr line nr { } } 