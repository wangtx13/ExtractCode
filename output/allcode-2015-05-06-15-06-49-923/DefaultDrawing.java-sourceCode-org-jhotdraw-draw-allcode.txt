org jhotdraw draw import org jhotdraw util reversedlist reversed list import awt * import awt geom * import javax swing * import javax swing event * import javax swing undo * import org jhotdraw util * import util * defaultdrawing default drawing abstractdrawing drawing implements figurelistener figure listener undoableeditlistener undoable edit listener { private arraylist<figure> list< figure> figures = new arraylist<figure> list< figure> private needssorting needs sorting = defaultdrawing default drawing { } indexof index of figure figure { figures indexof index of figure } basicadd basic add index figure figure { figures add index figure figure addfigurelistener add figure listener this figure addundoableeditlistener add undoable edit listener this invalidatesortorder invalidate sort order } basicremove basic remove figure figure { figures remove figure figure removefigurelistener remove figure listener this figure removeundoableeditlistener remove undoable edit listener this invalidatesortorder invalidate sort order } draw graphics2d graphics2 d g { synchronized getlock get lock { ensuresorted ensure sorted arraylist<figure> list< figure> todraw to draw = new arraylist<figure> list< figure> figures size rectangle cliprect clip rect = g getclipbounds get clip bounds for figure f figures { if f getdrawbounds get draw bounds intersects cliprect clip rect { todraw to draw add f } } draw g todraw to draw } } draw graphics2d graphics2 d g collection<figure> collection< figure> figures { for figure f figures { if f isvisible is visible { f draw g } } } collection<figure> collection< figure> sort collection<figure> collection< figure> c { hashset<figure> hash set< figure> unsorted = new hashset<figure> hash set< figure> unsorted addall add all c arraylist<figure> list< figure> sorted = new arraylist<figure> list< figure> c size for figure f figures { if unsorted contains f { sorted add f unsorted remove f } } for figure f c { if unsorted contains f { sorted add f unsorted remove f } } sorted } figureareainvalidated figure area invalidated figureevent figure event e { fireareainvalidated fire area invalidated e getinvalidatedarea get invalidated area } figurechanged figure changed figureevent figure event e { invalidatesortorder invalidate sort order fireareainvalidated fire area invalidated e getinvalidatedarea get invalidated area } figureadded figure added figureevent figure event e { } figureremoved figure removed figureevent figure event e { } figurerequestremove figure request remove figureevent figure event e { remove e getfigure get figure } figure findfigure find figure point2d point2 d p { for figure f getfiguresfronttoback get figures front to back { if f isvisible is visible f contains p { f } } } figure findfigureexcept find figure except point2d point2 d p figure ignore { for figure f getfiguresfronttoback get figures front to back { if f != ignore f isvisible is visible f contains p { f } } } figure findfigureexcept find figure except point2d point2 d p collection<figure> collection< figure> ignore { for figure f getfiguresfronttoback get figures front to back { if ! ignore contains f f isvisible is visible f contains p { f } } } collection<figure> collection< figure> findfigures find figures rectangle2d rectangle2 d bounds { arraylist<figure> list< figure> intersection = new arraylist<figure> list< figure> for figure f figures { if f isvisible is visible f getbounds get bounds intersects bounds { intersection add f } } intersection } collection<figure> collection< figure> findfigureswithin find figures within rectangle2d rectangle2 d bounds { arraylist<figure> list< figure> contained = new arraylist<figure> list< figure> for figure f figures { if f isvisible is visible bounds contains f getbounds get bounds { contained add f } } contained } collection<figure> collection< figure> getfigures get figures { collections unmodifiablecollection unmodifiable collection figures } figure findfigureinside find figure inside point2d point2 d p { figure f = findfigure find figure p f == ? f findfigureinside find figure inside p } util list<figure> list< figure> getfiguresfronttoback get figures front to back { ensuresorted ensure sorted new reversedlist<figure> reversed list< figure> figures } bringtofront bring to front figure figure { if figures remove figure { figures add figure invalidatesortorder invalidate sort order fireareainvalidated fire area invalidated figure getdrawbounds get draw bounds } } sendtoback send to back figure figure { if figures remove figure { figures add 0 figure invalidatesortorder invalidate sort order fireareainvalidated fire area invalidated figure getdrawbounds get draw bounds } } undoableedithappened undoable edit happened undoableeditevent undoable edit event e { fireundoableedithappened fire undoable edit happened e getedit get edit } figureattributechanged figure attribute changed figureevent figure event e { } contains figure f { figures contains f } private invalidatesortorder invalidate sort order { needssorting needs sorting = } private ensuresorted ensure sorted { if needssorting needs sorting { collections sort figures figurelayercomparator figure layer comparator instance i n s t a n c e needssorting needs sorting = } } } 