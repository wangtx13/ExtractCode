nanoxml import io * import util * xmlelement xml element { long serialversionuid serial uid = 6685035139346394777l 6685035139346394777 l NANOXML_MAJOR_VERSION = 2 NANOXML_MINOR_VERSION = 2 private hashmap hash map attributes private arraylist list children private name private contents private hashmap hash map entities private linenr line nr private ignorecase ignore case private ignorewhitespace ignore whitespace private char charreadtoomuch char read too much private reader reader private parserlinenr parser line nr private isencodeunicodecharacters is encode unicode characters = xmlelement xml element { this new hashmap hash map } xmlelement xml element hashmap hash map entities { this entities } xmlelement xml element skipleadingwhitespace skip leading whitespace { this new hashmap hash map skipleadingwhitespace skip leading whitespace } xmlelement xml element hashmap hash map entities skipleadingwhitespace skip leading whitespace { this entities skipleadingwhitespace skip leading whitespace } xmlelement xml element hashmap hash map entities skipleadingwhitespace skip leading whitespace ignorecase ignore case { this entities skipleadingwhitespace skip leading whitespace ignorecase ignore case } xmlelement xml element hashmap hash map entities skipleadingwhitespace skip leading whitespace fillbasicconversiontable fill basic conversion table ignorecase ignore case { this entities skipleadingwhitespace skip leading whitespace fillbasicconversiontable fill basic conversion table ignorecase ignore case } xmlelement xml element hashmap hash map entities skipleadingwhitespace skip leading whitespace fillbasicconversiontable fill basic conversion table ignorecase ignore case encodeunicodecharacters encode unicode characters { this ignorewhitespace ignore whitespace = skipleadingwhitespace skip leading whitespace this ignorecase ignore case = ignorecase ignore case this name = this contents = this attributes = new hashmap hash map this children = new arraylist list this entities = entities this linenr line nr = 0 this isencodeunicodecharacters is encode unicode characters = encodeunicodecharacters encode unicode characters iterator iter = this entities keyset key set iterator while iter hasnext has next { key = iter next value = this entities get key if value instanceof { value = value tochararray to char this entities put key value } } if fillbasicconversiontable fill basic conversion table { this entities put amp new char { ' ' } this entities put new char { ' ' } this entities put apos new char { '\'' } this entities put lt new char { '<' } this entities put new char { '>' } } } addchild add child xmlelement xml element child { this children add child } setattribute set attribute name value { if this ignorecase ignore case { name = name touppercase to upper case } this attributes put name value tostring to } setintattribute set attribute name value { if this ignorecase ignore case { name = name touppercase to upper case } this attributes put name integer tostring to value } setdoubleattribute set attribute name value { if this ignorecase ignore case { name = name touppercase to upper case } this attributes put name tostring to value } countchildren count children { this children size } iterator enumerateattributenames enumerate attribute names { this attributes keyset key set iterator } iterator iteratechildren iterate children { this children iterator } arraylist list getchildren get children { try { arraylist list this children clone } catch e { } } getcontent get content { this contents } getlinenr get line nr { this linenr line nr } getattribute get attribute name { this getattribute get attribute name } getattribute get attribute name defaultvalue default value { if this ignorecase ignore case { name = name touppercase to upper case } value = this attributes get name if value == { value = defaultvalue default value } value } getattribute get attribute name map valueset value set defaultkey default key allowliterals allow literals { if this ignorecase ignore case { name = name touppercase to upper case } key = this attributes get name result if key == { key = defaultkey default key } result = valueset value set get key if result == { if allowliterals allow literals { result = key } else { throw this invalidvalue invalid value name key } } result } getstringattribute get attribute name { this getstringattribute get attribute name } getstringattribute get attribute name defaultvalue default value { this getattribute get attribute name defaultvalue default value } getstringattribute get attribute name hashmap hash map valueset value set defaultkey default key allowliterals allow literals { this getattribute get attribute name valueset value set defaultkey default key allowliterals allow literals } getintattribute get attribute name { this getintattribute get attribute name 0 } getintattribute get attribute name defaultvalue default value { if this ignorecase ignore case { name = name touppercase to upper case } value = this attributes get name if value == { defaultvalue default value } else { try { integer parseint parse value } catch numberformatexception number format e { throw this invalidvalue invalid value name value } } } getintattribute get attribute name min max defaultvalue default value { v = getintattribute get attribute name defaultvalue default value if v < min min if v > max max v } getintattribute get attribute name hashmap hash map valueset value set defaultkey default key allowliteralnumbers allow literal numbers { if this ignorecase ignore case { name = name touppercase to upper case } key = this attributes get name integer result if key == { key = defaultkey default key } try { result = integer valueset value set get key } catch classcastexception cast e { throw this invalidvalueset invalid value set name } if result == { if ! allowliteralnumbers allow literal numbers { throw this invalidvalue invalid value name key } try { result = integer valueof value of key } catch numberformatexception number format e { throw this invalidvalue invalid value name key } } result intvalue value } getdoubleattribute get attribute name { this getdoubleattribute get attribute name 0 } getdoubleattribute get attribute name defaultvalue default value { if this ignorecase ignore case { name = name touppercase to upper case } value = this attributes get name if value == { defaultvalue default value } else { try { valueof value of value doublevalue value } catch numberformatexception number format e { throw this invalidvalue invalid value name value } } } getdoubleattribute get attribute name hashmap hash map valueset value set defaultkey default key allowliteralnumbers allow literal numbers { if this ignorecase ignore case { name = name touppercase to upper case } key = this attributes get name result if key == { key = defaultkey default key } try { result = valueset value set get key } catch classcastexception cast e { throw this invalidvalueset invalid value set name } if result == { if ! allowliteralnumbers allow literal numbers { throw this invalidvalue invalid value name key } try { result = valueof value of key } catch numberformatexception number format e { throw this invalidvalue invalid value name key } } result doublevalue value } getbooleanattribute get attribute name truevalue value falsevalue value defaultvalue default value { if this ignorecase ignore case { name = name touppercase to upper case } value = this attributes get name if value == { defaultvalue default value } else if value equals truevalue value { } else if value equals falsevalue value { } else { throw this invalidvalue invalid value name value } } getbooleanattribute get attribute name defaultvalue default value { getbooleanattribute get attribute name defaultvalue default value } getname get name { this name } parsefromreader parse from reader reader reader ioexception i o xmlparseexception xml parse { this parsefromreader parse from reader reader 1 } parsefromreader parse from reader reader reader startinglinenr starting line nr ioexception i o xmlparseexception xml parse { this name = this contents = this attributes = new hashmap hash map this children = new arraylist list this charreadtoomuch char read too much = '\0' this reader = reader this parserlinenr parser line nr = startinglinenr starting line nr for { char ch = this scanwhitespace scan whitespace if ch != '<' { throw this expectedinput expected input < } ch = this readchar read char if ch == '!' || ch == '?' { this skipspecialtag skip special tag 0 } else { this unreadchar unread char ch this scanelement scan element this } } } parsestring parse xmlparseexception xml parse { try { this parsefromreader parse from reader new stringreader reader 1 } catch ioexception i o e { } } parsestring parse offset xmlparseexception xml parse { this parsestring parse substring offset } parsestring parse offset end xmlparseexception xml parse { this parsestring parse substring offset end } parsestring parse offset end startinglinenr starting line nr xmlparseexception xml parse { = substring offset end try { this parsefromreader parse from reader new stringreader reader startinglinenr starting line nr } catch ioexception i o e { } } parsechararray parse char char input offset end xmlparseexception xml parse { this parsechararray parse char input offset end 1 } parsechararray parse char char input offset end startinglinenr starting line nr xmlparseexception xml parse { try { reader reader = new chararrayreader char reader input offset end this parsefromreader parse from reader reader startinglinenr starting line nr } catch ioexception i o e { } } removechild remove child xmlelement xml element child { this children remove child } removeattribute remove attribute name { if this ignorecase ignore case { name = name touppercase to upper case } this attributes remove name } xmlelement xml element createelement create element name { xmlelement xml element elem = createelement create element elem setname set name name elem } xmlelement xml element createelement create element { new xmlelement xml element this entities this ignorewhitespace ignore whitespace this ignorecase ignore case this isencodeunicodecharacters is encode unicode characters } setcontent set content content { this contents = content } setname set name name { this name = name } tostring to { try { bytearrayoutputstream byte output stream out = new bytearrayoutputstream byte output stream outputstreamwriter output stream writer writer = new outputstreamwriter output stream writer out this write writer writer flush new out tobytearray to byte } catch ioexception i o e { super tostring to } } write writer writer ioexception i o { if this name == { this writeencoded write encoded writer this contents } writer write '<' writer write this name if ! this attributes isempty is empty { iterator iter = this attributes keyset key set iterator while iter hasnext has next { writer write ' ' key = iter next value = this attributes get key writer write key writer write '=' writer write ' ' this writeencoded write encoded writer value writer write ' ' } } if this contents != this contents length > 0 { writer write '>' this writeencoded write encoded writer this contents writer write '<' writer write '/' writer write this name writer write '>' } else if this children isempty is empty { writer write '/' writer write '>' } else { writer write '>' iterator iter = this iteratechildren iterate children while iter hasnext has next { xmlelement xml element child = xmlelement xml element iter next child write writer } writer write '<' writer write '/' writer write this name writer write '>' } } print printwriter print writer writer { print writer 0 } print printwriter print writer writer indent { try { if this name == { this writeencoded write encoded writer this contents } char spaces = new char indent * 2 arrays fill spaces ' ' writer write spaces writer write '<' writer write this name if ! this attributes isempty is empty { iterator enm = this attributes keyset key set iterator while enm hasnext has next { writer write ' ' key = enm next value = this attributes get key writer write key writer write '=' writer write ' ' this writeencoded write encoded writer value writer write ' ' } } if this contents != this contents length > 0 { writer write '>' this writeencoded write encoded writer this contents writer write '<' writer write '/' writer write this name writer write '>' } else if this children isempty is empty { writer write '/' writer write '>' } else { writer write '>' writer write '\n' iterator enm = this getchildren get children iterator while enm hasnext has next { xmlelement xml element child = xmlelement xml element enm next child print writer indent + 1 } writer write spaces writer write '<' writer write '/' writer write this name writer write '>' } writer write '\n' } catch ioexception i o e { internalerror internal = new internalerror internal e getmessage get message initcause init cause e throw } } writeencoded write encoded writer writer str ioexception i o { for i = 0 i < str length i += 1 { char ch = str charat char at i switch ch { case '<' writer write ' ' writer write 'l' writer write 't' writer write ' ' break case '>' writer write ' ' writer write 'g' writer write 't' writer write ' ' break case ' ' writer write ' ' writer write 'a' writer write 'm' writer write 'p' writer write ' ' break case ' ' writer write ' ' writer write 'q' writer write 'u' writer write 'o' writer write 't' writer write ' ' break case '\'' writer write ' ' writer write 'a' writer write 'p' writer write 'o' writer write 's' writer write ' ' break default unicode = ch if unicode < 32 || isencodeunicodecharacters is encode unicode characters unicode > 126 { writer write ' ' writer write '#' writer write 'x' writer write integer tostring to unicode 16 writer write ' ' } else { writer write ch } } } } scanidentifier scan identifier stringbuffer buffer result ioexception i o { for { char ch = this readchar read char if ch < 'a' ' a' || ch > 'z' ' z' ch < 'a' || ch > 'z' ch < '0' || ch > '9' ch != '_' ch != ' ' ch != ' ' ch != ' ' ch <= '\u007e' '\u007 e' { this unreadchar unread char ch } result append ch } } char scanwhitespace scan whitespace ioexception i o { for { char ch = this readchar read char switch ch { case ' ' case '\t' case '\n' case '\r' break default ch } } } char scanwhitespace scan whitespace stringbuffer buffer result ioexception i o { for { char ch = this readchar read char switch ch { case ' ' case '\t' case '\n' result append ch case '\r' break default ch } } } scanstring scan stringbuffer buffer ioexception i o { char delimiter = this readchar read char if delimiter != '\'' delimiter != ' ' { throw this expectedinput expected input ' or \ } for { char ch = this readchar read char if ch == delimiter { } else if ch == ' ' { this resolveentity resolve entity } else { append ch } } } scanpcdata scan p c data stringbuffer buffer data ioexception i o { for { char ch = this readchar read char if ch == '<' { ch = this readchar read char if ch == '!' { this checkcdata check c d a t a data } else { this unreadchar unread char ch } } else if ch == ' ' { this resolveentity resolve entity data } else { data append ch } } } checkcdata check c d a t a stringbuffer buffer buf ioexception i o { char ch = this readchar read char if ch != ' ' { this unreadchar unread char ch this skipspecialtag skip special tag 0 } else if ! this checkliteral check literal cdata c d a t a { this skipspecialtag skip special tag 1 } else { delimitercharsskipped delimiter chars skipped = 0 while delimitercharsskipped delimiter chars skipped < 3 { ch = this readchar read char switch ch { case ' ' if delimitercharsskipped delimiter chars skipped < 2 { delimitercharsskipped delimiter chars skipped += 1 } else { buf append ' ' buf append ' ' delimitercharsskipped delimiter chars skipped = 0 } break case '>' if delimitercharsskipped delimiter chars skipped < 2 { for i = 0 i < delimitercharsskipped delimiter chars skipped i++ { buf append ' ' } delimitercharsskipped delimiter chars skipped = 0 buf append '>' } else { delimitercharsskipped delimiter chars skipped = 3 } break default for i = 0 i < delimitercharsskipped delimiter chars skipped i += 1 { buf append ' ' } buf append ch delimitercharsskipped delimiter chars skipped = 0 } } } } skipcomment skip comment ioexception i o { dashestoread dashes to read = 2 while dashestoread dashes to read > 0 { char ch = this readchar read char if ch == ' ' { dashestoread dashes to read = 1 } else { dashestoread dashes to read = 2 } } if this readchar read char != '>' { throw this expectedinput expected input > } } skipspecialtag skip special tag bracketlevel bracket level ioexception i o { taglevel tag level = 1 char stringdelimiter delimiter = '\0' if bracketlevel bracket level == 0 { char ch = this readchar read char if ch == ' ' { bracketlevel bracket level += 1 } else if ch == ' ' { ch = this readchar read char if ch == ' ' { bracketlevel bracket level += 1 } else if ch == ' ' { bracketlevel bracket level = 1 } else if ch == ' ' { this skipcomment skip comment } } } while taglevel tag level > 0 { char ch = this readchar read char if stringdelimiter delimiter == '\0' { if ch == ' ' || ch == '\'' { stringdelimiter delimiter = ch } else if bracketlevel bracket level <= 0 { if ch == '<' { taglevel tag level += 1 } else if ch == '>' { taglevel tag level = 1 } } if ch == ' ' { bracketlevel bracket level += 1 } else if ch == ' ' { bracketlevel bracket level = 1 } } else { if ch == stringdelimiter delimiter { stringdelimiter delimiter = '\0' } } } } checkliteral check literal literal ioexception i o { length = literal length for i = 0 i < length i += 1 { if this readchar read char != literal charat char at i { } } } char readchar read char ioexception i o { if this charreadtoomuch char read too much != '\0' { char ch = this charreadtoomuch char read too much this charreadtoomuch char read too much = '\0' ch } else { i = this reader read if i < 0 { throw this unexpectedendofdata unexpected end of data } else if i == 10 { this parserlinenr parser line nr += 1 '\n' } else { char i } } } scanelement scan element xmlelement xml element elt ioexception i o { stringbuffer buffer buf = new stringbuffer buffer this scanidentifier scan identifier buf name = buf tostring to elt setname set name name char ch = this scanwhitespace scan whitespace while ch != '>' ch != '/' { buf setlength set length 0 this unreadchar unread char ch this scanidentifier scan identifier buf key = buf tostring to ch = this scanwhitespace scan whitespace if ch != '=' { throw this expectedinput expected input = } this unreadchar unread char this scanwhitespace scan whitespace buf setlength set length 0 this scanstring scan buf elt setattribute set attribute key buf ch = this scanwhitespace scan whitespace } if ch == '/' { ch = this readchar read char if ch != '>' { throw this expectedinput expected input > } } buf setlength set length 0 ch = this scanwhitespace scan whitespace buf if ch != '<' { this unreadchar unread char ch this scanpcdata scan p c data buf } else { for { ch = this readchar read char if ch == '!' { if this checkcdata check c d a t a buf { this scanpcdata scan p c data buf break } else { ch = this scanwhitespace scan whitespace buf if ch != '<' { this unreadchar unread char ch this scanpcdata scan p c data buf break } } } else { if ch != '/' || this ignorewhitespace ignore whitespace { buf setlength set length 0 } if ch == '/' { this unreadchar unread char ch } break } } } if buf length == 0 { while ch != '/' { if ch == '!' { ch = this readchar read char if ch != ' ' { throw this expectedinput expected input comment or element } ch = this readchar read char if ch != ' ' { throw this expectedinput expected input comment or element } this skipcomment skip comment } else { this unreadchar unread char ch xmlelement xml element child = this createelement create element this scanelement scan element child elt addchild add child child } ch = this scanwhitespace scan whitespace if ch != '<' { throw this expectedinput expected input < } ch = this readchar read char } this unreadchar unread char ch } else { if this ignorewhitespace ignore whitespace { elt setcontent set content buf tostring to trim } else { elt setcontent set content buf tostring to } } ch = this readchar read char if ch != '/' { throw this expectedinput expected input / } this unreadchar unread char this scanwhitespace scan whitespace if ! this checkliteral check literal name { throw this expectedinput expected input name } if this scanwhitespace scan whitespace != '>' { throw this expectedinput expected input > } } resolveentity resolve entity stringbuffer buffer buf ioexception i o { char ch = '\0' stringbuffer buffer keybuf key buf = new stringbuffer buffer for { ch = this readchar read char if ch == ' ' { break } keybuf key buf append ch } key = keybuf key buf tostring to if key charat char at 0 == '#' { try { if key charat char at 1 == 'x' { ch = char integer parseint parse key substring 2 16 } else { ch = char integer parseint parse key substring 1 10 } } catch numberformatexception number format e { throw this unknownentity unknown entity key } buf append ch } else { char value = char this entities get key if value == { throw this unknownentity unknown entity key } buf append value } } unreadchar unread char char ch { this charreadtoomuch char read too much = ch } xmlparseexception xml parse invalidvalueset invalid value set name { msg = invalid value set entity name = \ + name + \ new xmlparseexception xml parse this getname get name this parserlinenr parser line nr msg } xmlparseexception xml parse invalidvalue invalid value name value { msg = attribute \ + name + \ does not contain a valid + value \ + value + \ new xmlparseexception xml parse this getname get name this parserlinenr parser line nr msg } xmlparseexception xml parse unexpectedendofdata unexpected end of data { msg = unexpected end of data reached new xmlparseexception xml parse this getname get name this parserlinenr parser line nr msg } xmlparseexception xml parse syntaxerror syntax context { msg = syntax while parsing + context new xmlparseexception xml parse this getname get name this parserlinenr parser line nr msg } xmlparseexception xml parse expectedinput expected input charset char set { msg = expected + charset char set new xmlparseexception xml parse this getname get name this parserlinenr parser line nr msg } xmlparseexception xml parse unknownentity unknown entity name { msg = unknown or invalid entity + name + new xmlparseexception xml parse this getname get name this parserlinenr parser line nr msg } } 