net n3 nanoxml import serializable import util * xml element implements xml element serializable { long serial uid = 2383376380548624920 NO_LINE = 1 private xml element parent private list attributes private list children private private full private namespace private content private systemid private line nr xml element { this NO_LINE } xml element full { this full NO_LINE } xml element full systemid line nr { this full systemid line nr } xml element full namespace { this full namespace NO_LINE } xml element full namespace systemid line nr { this attributes = new list this children = new list 8 this full = full if namespace == { this = full } else { index = full index of ' ' if index >= 0 { this = full substring index + 1 } else { this = full } } this namespace = namespace this content = this line nr = line nr this systemid = systemid this parent = } xml element create data element { new xml element } xml element create element full { new xml element full } xml element create element full systemid line nr { new xml element full systemid line nr } xml element create element full namespace { new xml element full namespace } xml element create element full namespace systemid line nr { new xml element full namespace systemid line nr } finalize throwable { this attributes clear this attributes = this children = this full = this = this namespace = this content = this systemid = this parent = super finalize } xml element get parent { this parent } get full { this full } get { this } get namespace { this namespace } set { this = this full = this namespace = } set full namespace { index = full index of ' ' if namespace == || index < 0 { this = full } else { this = full substring index + 1 } this full = full this namespace = namespace } add child xml element child { if child == { new illegal argument child must not be } if child get == ! this children empty { xml element last child = xml element this children get this children size 1 if last child get == { last child set content last child get content + child get content } } xml element child parent = this this children add child } insert child xml element child index { if child == { new illegal argument child must not be } if child get == ! this children empty { xml element last child = xml element this children get this children size 1 if last child get == { last child set content last child get content + child get content } } xml element child parent = this this children add index child } remove child xml element child { if child == { new illegal argument child must not be } this children remove child } remove child index index { this children remove index } iterator iterate children { this children iterator } leaf { this children empty } has children { ! this children empty } get children count { this children size } list get children { this children } xml element get child index index index out of bounds { xml element this children get index } xml element get first child named { iterator enm = this children iterator while enm has next { xml element child = xml element enm next child = child get full if child != child equals { child } } } xml element get first child named namespace { iterator enm = this children iterator while enm has next { xml element child = xml element enm next = child get found = != equals = child get namespace if == { found = == } else { found = equals namespace } if found { child } } } list get children named { list result = new list this children size iterator enm = this children iterator while enm has next { xml element child = xml element enm next child = child get full if child != child equals { result add child } } result } list get children named namespace { list result = new list this children size iterator enm = this children iterator while enm has next { xml element child = xml element enm next = child get found = != equals = child get namespace if == { found = == } else { found = equals namespace } if found { result add child } } result } private xml attribute find attribute full { iterator enm = this attributes iterator while enm has next { xml attribute attr = xml attribute enm next if attr get full equals full { attr } } } private xml attribute find attribute namespace { iterator enm = this attributes iterator while enm has next { xml attribute attr = xml attribute enm next found = attr get equals if namespace == { found = attr get namespace == } else { found = namespace equals attr get namespace } if found { attr } } } get attribute count { this attributes size } get attribute { this get attribute } get attribute default value { xml attribute attr = this find attribute if attr == { default value } else { attr get value } } get attribute namespace default value { xml attribute attr = this find attribute namespace if attr == { default value } else { attr get value } } get attribute default value { value = this get attribute integer to default value integer parse value } get attribute namespace default value { value = this get attribute namespace integer to default value integer parse value } get attribute type { xml attribute attr = this find attribute if attr == { } else { attr get type } } get attribute namespace { xml attribute attr = this find attribute if attr == { } else { attr get namespace } } get attribute type namespace { xml attribute attr = this find attribute namespace if attr == { } else { attr get type } } set attribute value { xml attribute attr = this find attribute if attr == { attr = new xml attribute value this attributes add attr } else { attr set value value } } set attribute full namespace value { index = full index of ' ' = full substring index + 1 xml attribute attr = this find attribute namespace if attr == { attr = new xml attribute full namespace value this attributes add attr } else { attr set value value } } remove attribute { for = 0 < this attributes size i++ { xml attribute attr = xml attribute this attributes get if attr get full equals { this attributes remove } } } remove attribute namespace { for = 0 < this attributes size i++ { xml attribute attr = xml attribute this attributes get found = attr get equals if namespace == { found = attr get namespace == } else { found = attr get namespace equals namespace } if found { this attributes remove } } } iterator iterate attribute names { list result = new list iterator enm = this attributes iterator while enm has next { xml attribute attr = xml attribute enm next result add attr get full } result iterator } has attribute { this find attribute != } has attribute namespace { this find attribute namespace != } properties get attributes { properties result = new properties iterator enm = this attributes iterator while enm has next { xml attribute attr = xml attribute enm next result put attr get full attr get value } result } properties get attributes namespace namespace { properties result = new properties iterator enm = this attributes iterator while enm has next { xml attribute attr = xml attribute enm next if namespace == { if attr get namespace == { result put attr get attr get value } } else { if namespace equals attr get namespace { result put attr get attr get value } } } result } get systemid { this systemid } get line nr { this line nr } get content { this content } set content content { this content = content } equals raw element { try { this equals xml element xml element raw element } catch cast { } } equals xml element xml element elt { if ! this equals elt get { } if this attributes size != elt get attribute count { } iterator enm = this attributes iterator while enm has next { xml attribute attr = xml attribute enm next if ! elt has attribute attr get attr get namespace { } value = elt get attribute attr get attr get namespace if ! attr get value equals value { } type = elt get attribute type attr get attr get namespace if ! attr get type equals type { } } if this children size != elt get children count { } for = 0 < this children size i++ { xml element child1 = this get child index xml element child2 = elt get child index if ! child1 equals xml element child2 { } } } } 