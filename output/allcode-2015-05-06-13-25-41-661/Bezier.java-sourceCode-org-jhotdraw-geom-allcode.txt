org jhotdraw geom import org jhotdraw util * import awt * import awt geom * bezier { private = 1000 private bezier { } args { point2 = {	 new point2 0 0 0 0 new point2 0 0 0 5 new point2 1 1 1 4 new point2 2 1 1 6 new point2 3 2 1 1 new point2 4 0 0 2 new point2 4 0 0 0 } double	error = 4 0 		 general path path = fit curve 	 out path } general path fit curve polygon { point2 = new point2 npoints for i=0 < length i++ { = new point2 xpoints ypoints } fit curve } general path fit curve point2 { point2 hat1 = new point2 point2 hat2 = new point2 general path bezier path = new general path bezier path move to float 0 float 0 hat1 = compute left tangent 0 hat2 = compute right tangent length 1 fit cubic 0 length 1 hat1 hat2 bezier path bezier path } bezier path fit bezier curve bezier path path { point2 = path to polygon point2 hat1 = new point2 point2 hat2 = new point2 bezier path bezier path = new bezier path bezier path add new bezier path node 0 hat1 = compute left tangent 0 hat2 = compute right tangent length 1 fit cubic 0 length 1 hat1 hat2 bezier path bezier path set closed path closed bezier path } private fit cubic point2 first last point2 hat1 point2 hat2 general path bezier path { point2 bez curve 		 prime 	 double	max 	 	split point = new 1 int	n pts 		 double	iteration int	max iterations = 4 point2 double	t hat center = new point2 int	i iteration = * pts = last first + 1 if pts == 2 { dist = v2 distance between2 points last first / 3 0 bez curve = new point2 4 for i=0 < bez curve length i++ { bez curve = new point2 } bez curve 0 = first bez curve 3 = last v2 add bez curve 0 v2 scale hat1 dist bez curve 1 v2 add bez curve 3 v2 scale hat2 dist bez curve 2 bezier path curve to float bez curve 1 float bez curve 1 float bez curve 2 float bez curve 2 float bez curve 3 float bez curve 3 } = chord length parameterize first last bez curve = generate bezier first last hat1 hat2 max = compute max first last bez curve split point if max < { bezier path curve to float bez curve 1 float bez curve 1 float bez curve 2 float bez curve 2 float bez curve 3 float bez curve 3 } if max < iteration { for = 0 < max iterations i++ { prime = reparameterize first last bez curve bez curve = generate bezier first last prime hat1 hat2 max = compute max first last bez curve prime split point if max < { bezier path curve to float bez curve 1 float bez curve 1 float bez curve 2 float bez curve 2 float bez curve 3 float bez curve 3 } = prime } } hat center = compute center tangent split point 0 fit cubic first split point 0 hat1 hat center bezier path v2 negate hat center fit cubic split point 0 last hat center hat2 bezier path } private fit cubic point2 first last point2 hat1 point2 hat2 bezier path bezier path { point2 bez curve 		 prime 	 double	max 	 	split point = new 1 int	n pts 		 double	iteration int	max iterations = 4 point2 double	t hat center = new point2 int	i iteration = * pts = last first + 1 if pts == 2 { dist = v2 distance between2 points last first / 3 0 bez curve = new point2 4 for i=0 < bez curve length i++ { bez curve = new point2 } bez curve 0 = first bez curve 3 = last v2 add bez curve 0 v2 scale hat1 dist bez curve 1 v2 add bez curve 3 v2 scale hat2 dist bez curve 2 bezier path curve to bez curve 1 bez curve 1 bez curve 2 bez curve 2 bez curve 3 bez curve 3 } = chord length parameterize first last bez curve = generate bezier first last hat1 hat2 max = compute max first last bez curve split point if max < { bezier path curve to bez curve 1 bez curve 1 bez curve 2 bez curve 2 bez curve 3 bez curve 3 } if max < iteration { for = 0 < max iterations i++ { prime = reparameterize first last bez curve bez curve = generate bezier first last prime hat1 hat2 max = compute max first last bez curve prime split point if max < { bezier path curve to bez curve 1 bez curve 1 bez curve 2 bez curve 2 bez curve 3 bez curve 3 } = prime } } hat center = compute center tangent split point 0 fit cubic first split point 0 hat1 hat center bezier path v2 negate hat center fit cubic split point 0 last hat center hat2 bezier path } private point2 generate bezier point2 first last prime point2 hat1 point2 hat2 { 	i point2 = new point2 2 	n pts 			 = new 2 2 = new 2 	 	det_C0_C1 		 det_C0_X det_X_C1 	alpha_l 		 alpha_r point2 	tmp = new point2 point2 bez curve 	 bez curve = new point2 4 for i=0 < bez curve length i++ { bez curve = new point2 } pts = last first + 1 for = 0 < pts i++ { point2 v1 v2 v1 = point2 hat1 clone v2 = point2 hat2 clone v2 scale v1 b1 prime v2 scale v2 b2 prime 0 = v1 1 = v2 } 0 0 = 0 0 0 1 = 0 0 1 0 = 0 0 1 1 = 0 0 0 = 0 0 1 = 0 0 for = 0 < pts i++ { 0 0 += v2 dot 0 0 0 1 += v2 dot 0 1 1 0 = 0 1 1 1 += v2 dot 1 1 tmp = v2 sub first + v2 add v2 scale first b0 prime v2 add v2 scale first b1 prime v2 add v2 scale last b2 prime v2 scale last b3 prime 0 += v2 dot 0 tmp 1 += v2 dot 1 tmp } det_C0_C1 = 0 0 * 1 1 1 0 * 0 1 det_C0_X = 0 0 * 1 0 1 * 0 det_X_C1 = 0 * 1 1 1 * 0 1 if det_C0_C1 == 0 0 { det_C0_C1 = 0 0 * 1 1 * 10e 12 } alpha_l = det_X_C1 / det_C0_C1 alpha_r = det_C0_X / det_C0_C1 if alpha_l < 1 0e 6 || alpha_r < 1 0e 6 { dist = v2 distance between2 points last first / 3 0 bez curve 0 = first bez curve 3 = last v2 add bez curve 0 v2 scale hat1 dist bez curve 1 v2 add bez curve 3 v2 scale hat2 dist bez curve 2 bez curve } bez curve 0 = first bez curve 3 = last v2 add bez curve 0 v2 scale hat1 alpha_l bez curve 1 v2 add bez curve 3 v2 scale hat2 alpha_r bez curve 2 bez curve } private reparameterize point2 first last point2 bez curve { 	n pts = last first+1 	i prime prime = new pts for = first <= last i++ { prime first = newton raphson root find bez curve first } prime } private newton raphson root find point2 point2 { 		numerator denominator point2 q1 = new point2 3 q2 = new point2 2 	 point2 Double	Q_u = new point2 Q1_u = new point2 Q2_u = new point2 		u prime 		 		i Q_u = bezier 3 for = 0 <= 2 i++ { q1 = new point2 i+1 * 3 0 i+1 * 3 0 } for = 0 <= 1 i++ { q2 = new point2 q1 i+1 q1 * 2 0 q1 i+1 q1 * 2 0 } Q1_u = bezier 2 q1 Q2_u = bezier 1 q2 numerator = Q_u * Q1_u + Q_u * Q1_u denominator = Q1_u * Q1_u + Q1_u * Q1_u + Q_u * Q2_u + Q_u * Q2_u prime = numerator/denominator prime } private point2 bezier degree point2 { 	i point2 point2 vtemp vtemp = new point2 degree+1 for = 0 <= degree i++ { vtemp = point2 clone } for = 1 <= degree i++ { for = 0 <= degree j++ { vtemp = 1 0 * vtemp + * vtemp j+1 vtemp = 1 0 * vtemp + * vtemp j+1 } } = vtemp 0 } private b0 { tmp = 1 0 tmp * tmp * tmp } private b1 { tmp = 1 0 3 * * tmp * tmp } private b2 { tmp = 1 0 3 * * * tmp } private b3 { * * } private point2 compute left tangent point2 { point2 double	t hat1 = new point2 hat1 = v2 sub end+1 hat1 = v2 normalize hat1 hat1 } private point2 compute right tangent point2 { point2 hat2 = new point2 hat2 = v2 sub 1 hat2 = v2 normalize hat2 hat2 } private point2 compute center tangent point2 center { point2 v1 = new point2 v2 = new point2 hat center = new point2 v1 = v2 sub center 1 center v2 = v2 sub center center+1 hat center = v1 + v2 /2 0 hat center = v1 + v2 /2 0 hat center = v2 normalize hat center hat center } private chord length parameterize point2 first last { int	i 	 = new last first+1 0 = 0 0 for = first+1 <= last i++ { first = first 1 + v2 distance between2 points 1 } for = first + 1 <= last i++ { first = first / last first } } private compute max point2 first last point2 bez curve split point { int		i double	max dist 		 double	dist 		 point2 double	 = new point2 point2 double	v = new point2 split point 0 = last first + 1 /2 max dist = 0 0 for = first + 1 < last i++ { = bezier 3 bez curve first = v2 sub dist = v2 squared length if dist >= max dist { max dist = dist split point 0 = } } max dist } private point2 v2 add point2 point2 { point2 = new point2 = + = + } private point2 v2 scale point2 { point2 result = new point2 result = * result = * result } private point2 v2 sub point2 point2 { point2 = new point2 = = } private v2 distance between2 points point2 point2 { dx = dy = math sqrt dx*dx + dy*dy } private point2 v2 scale point2 newlen { len = v2 length if len != 0 0 { *= newlen/len *= newlen/len } } private v2 length point2 { math sqrt v2 squared length } private v2 squared length point2 { * + * } private point2 v2 add point2 point2 point2 { = x+b = y+b } private point2 v2 negate point2 { = = } private v2 dot point2 point2 { x*b + y*b } private point2 v2 normalize point2 { len = v2 length if len != 0 0 { /= len /= len } } } 