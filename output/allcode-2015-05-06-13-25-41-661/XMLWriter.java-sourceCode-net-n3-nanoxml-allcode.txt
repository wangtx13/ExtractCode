net n3 nanoxml import import output stream import writer import writer import util iterator import util vector xml writer { private writer writer xml writer writer writer { if writer instanceof writer { this writer = writer writer } else { this writer = new writer writer } } xml writer output stream stream { this writer = new writer stream } finalize throwable { this writer = super finalize } write xml element xml { this write xml 0 } write xml element xml pretty { this write xml pretty 0 } write xml element xml pretty indent { this write xml pretty indent } write xml element xml pretty indent collapse empty elements { if pretty { for = 0 < indent i++ { this writer ' ' } } if xml get == { if xml get content != { if pretty { this write encoded xml get content trim writer } else { this write encoded xml get content } } } else { this writer '<' this writer xml get full vector nsprefixes = new vector if xml get namespace != { if xml get equals xml get full { this writer xmlns=\ + xml get namespace + ' ' } else { prefix = xml get full prefix = prefix substring 0 prefix index of ' ' nsprefixes add element prefix this writer xmlns + prefix this writer =\ + xml get namespace + \ } } iterator enm = xml iterate attribute names while enm has next { key = enm next index = key index of ' ' if index >= 0 { namespace = xml get attribute namespace key if namespace != { prefix = key substring 0 index if ! nsprefixes contains prefix { this writer xmlns + prefix this writer =\ + namespace + ' ' nsprefixes add element prefix } } } } enm = xml iterate attribute names while enm has next { key = enm next value = xml get attribute key this writer + key + =\ this write encoded value this writer ' ' } if xml get content != xml get content length > 0 { writer '>' this write encoded xml get content writer </ + xml get full + '>' if pretty { writer } } else if xml has children || ! collapse empty elements { writer '>' if pretty { writer } enm = xml iterate children while enm has next { xml element child = xml element enm next this write child pretty indent + 4 collapse empty elements } if pretty { for = 0 < indent i++ { this writer ' ' } } this writer </ + xml get full + > if pretty { writer } } else { this writer /> if pretty { writer } } } this writer flush } private write encoded { for = 0 < length i++ { char = char switch { case 0x0 this writer break case '<' this writer lt break case '>' this writer break case ' ' this writer amp break case '\'' this writer apos break case ' ' this writer break default if < ' ' || > 0x7 { this writer #x this writer integer to 16 this writer ' ' } else { this writer } } } } } 