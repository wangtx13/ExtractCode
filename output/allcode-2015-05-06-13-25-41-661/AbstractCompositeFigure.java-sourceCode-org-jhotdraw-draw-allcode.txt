org jhotdraw draw import import org jhotdraw util * import org jhotdraw util * import awt * import awt geom * import util * import javax swing event * import javax swing undo * import org jhotdraw geom * import org jhotdraw xml dom input import org jhotdraw xml dom output composite figure figure implements composite figure { private linked list< figure> children = new linked list< figure> private rectangle2 draw bounds private rectangle2 bounds private layouter layouter private child handler child handler = new child handler this private child handler implements figure listener undoable edit listener { private composite figure owner private child handler composite figure owner { this owner = owner } figure request remove figure event { owner remove get figure } figure removed figure event evt { } figure changed figure event { if ! owner changing { owner will change owner fire figure changed owner changed } } figure added figure event { } figure attribute changed figure event { } figure area invalidated figure event { if ! owner changing { owner fire area invalidated get invalidated area } } undoable edit happened undoable edit event { owner fire undoable edit happened get edit } } composite figure { } collection< handle> create handles detail level { if detail level == 0 { super create handles 0 } linked list< handle> handles = new linked list< handle> handles } add figure figure { add get child count figure } add index figure figure { will change basic add index figure if get drawing != { figure add notify get drawing } changed } add all collection< figure> new figures { will change for figure new figures { basic add get child count if get drawing != { add notify get drawing } } changed } basic add figure figure { basic add get child count figure } basic add index figure figure { children add index figure figure add figure listener child handler figure add undoable edit listener child handler } basic add all collection< figure> new figures { for figure new figures { basic add get child count } } add notify drawing drawing { super add notify drawing for figure child children { child add notify drawing } } remove notify drawing drawing { for figure child new linked list< figure> children { child remove notify drawing } super remove notify drawing } remove figure figure { index = children index of figure if index == 1 { } else { will change basic remove child index if get drawing != { figure remove notify get drawing } changed } } figure remove child index { will change figure removed = basic remove child index if get drawing != { removed remove notify get drawing } changed removed } basic remove figure figure { index = children index of figure if index == 1 { } else { basic remove child index } } figure basic remove child index { figure figure = children remove index figure remove figure listener child handler figure remove undoable edit listener child handler figure } remove all children { will change while children size > 0 { figure = basic remove child children size 1 if get drawing != { add notify get drawing } } changed } basic remove all children { while children size > 0 { figure = basic remove child children size 1 } } synchronized send to back figure figure { if children remove figure { children add 0 figure figure invalidate } } synchronized send to front figure figure { if children remove figure { children add figure figure invalidate } } basic transform affine transform tx { for figure children { basic transform tx } invalidate bounds } basic set bounds point2 anchor point2 { rectangle2 old bounds = get bounds rectangle2 new bounds = new rectangle2 math min anchor math min anchor math anchor math anchor sx = new bounds width / old bounds width = new bounds height / old bounds height affine transform tx = new affine transform tx translate old bounds old bounds if ! sx ! sx != 1d || != 1d ! sx < 0 0001 ! < 0 0001 { basic transform tx tx set to identity tx scale sx basic transform tx tx set to identity } tx translate new bounds new bounds basic transform tx } undoable edit happened undoable edit event { fire undoable edit happened get edit } util list< figure> get children { collections unmodifiable list children } get child count { children size } figure get child index { children get index } util list< figure> get children front to back { children == ? new linked list< figure> new reversed list< figure> children } set attribute attribute key value { will change for figure child children { child set attribute value } changed } basic set attribute attribute key value { for figure child children { child basic set attribute value } } get attribute attribute key { } contains point2 { if get draw bounds contains { for figure child get children front to back { if child visible child contains } } } figure find figure inside point2 { if get draw bounds contains { figure found = for figure child get children front to back { if child visible { found = child find figure inside if found != { found } } } } } figure find child point2 { if get bounds contains { figure found = for figure child get children front to back { if child visible child contains { child } } } } find child index point2 { figure child = find child child == ? 1 children index of child } layouter get layouter { layouter } layout { if get layouter != { rectangle2 bounds = get bounds point2 = new point2 bounds bounds rectangle2 = get layouter layout this basic set bounds new point2 new point2 + width + height invalidate bounds } } set layouter layouter new layouter { this layouter = new layouter } dimension2 get preferred size { if this layouter != { rectangle2 = layouter calculate layout this get start point get point new dimension2 width height } else { super get preferred size } } rectangle2 get figure draw bounds { if draw bounds == { for figure child get children front to back { if child visible { rectangle2 child bounds = child get draw bounds if ! child bounds empty { if draw bounds == { draw bounds = child bounds } else { draw bounds add child bounds } } } } } draw bounds == ? new rectangle2 0 0 1 1 rectangle2 draw bounds clone } rectangle2 get bounds { if bounds == { for figure child get children front to back { if child visible { if bounds == { bounds = child get bounds } else { bounds add child get bounds } } } } bounds == ? new rectangle2 0 0 1 1 rectangle2 bounds clone } draw figure graphics2 { for figure child children { if child visible { child draw } } if connectors visible { draw connectors } } draw connectors graphics2 { } composite figure clone { composite figure that = composite figure super clone that child handler = new child handler that that children = new linked list< figure> for figure this child this children { figure that child = figure this child clone that children add that child that child add figure listener that child handler that child add undoable edit listener that child handler } that } invalidate bounds { bounds = draw bounds = } collection< figure> get decomposition { linked list< figure> list = new linked list< figure> list add this list add all get children list } read dom input { open element children for i=0 < get element count i++ { add figure read } close element } write dom output out { out open element children for figure child get children { out write child } out close element } map< attribute key object> get attributes { new hash map< attribute key object> } restore to geometry { linked list list = linked list geometry index = 0 for geom list { get child index restore to geom index++ } invalidate bounds } get restore data { linked list< object> list = new linked list< object> for figure child children { list add child get restore data } list } will change { super will change if get changing depth == 1 { for figure child children { child will change } } } changed { if get changing depth == 1 { for figure child children { child changed } } super changed } invalidate { super invalidate invalidate bounds } validate { super validate layout invalidate bounds } remove attribute attribute key key { } has attribute attribute key key { } } 