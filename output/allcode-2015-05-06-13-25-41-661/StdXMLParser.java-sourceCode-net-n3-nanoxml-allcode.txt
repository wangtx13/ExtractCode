net n3 nanoxml import import char reader import reader import util enumeration import util properties import util vector std xml parser implements xml parser { private xml builder builder private xml reader reader private xml entity resolver entity resolver private xml validator validator std xml parser { this builder = this validator = this reader = this entity resolver = new xml entity resolver } finalize throwable { this builder = this reader = this entity resolver = this validator = super finalize } set builder xml builder builder { this builder = builder } xml builder get builder { this builder } set validator xml validator validator { this validator = validator } xml validator get validator { this validator } set resolver xml entity resolver resolver { this entity resolver = resolver } xml entity resolver get resolver { this entity resolver } set reader xml reader reader { this reader = reader } xml reader get reader { this reader } parse xml { try { this builder start building this reader get systemid this reader get line nr this scan data this builder get result } catch xml { } catch { xml = new xml init cause } } scan data { while ! this reader this builder get result == { = xml util read this reader ' ' char ch = char 0 if ch == ' ' { xml util process entity this reader this entity resolver continue } switch ch { case '<' this scan some tag new properties break case ' ' case '\t' case '\r' case '\n' break default xml util invalid input reader get systemid reader get line nr ` + ch + ' 0x + integer to hex ch + ' ' } } } scan some tag allow default namespace properties namespaces { = xml util read this reader ' ' char ch = char 0 if ch == ' ' { xml util unexpected entity reader get systemid reader get line nr } switch ch { case '?' this process break case '!' this process special tag allow break default this reader unread ch this process element default namespace namespaces } } process { xml util skip whitespace this reader target = xml util scan identifier this reader xml util skip whitespace this reader reader reader = new reader this reader if ! target equals ignore case xml { this builder new processing instruction target reader } reader close } process special tag allow { = xml util read this reader ' ' char ch = char 0 if ch == ' ' { xml util unexpected entity reader get systemid reader get line nr } switch ch { case ' ' if allow { this process } else { xml util unexpected reader get systemid reader get line nr } case ' d' this process doc type case ' ' xml util skip comment this reader } } process { if ! xml util check literal this reader { xml util expected input reader get systemid reader get line nr <! } this validator data added this reader get systemid this reader get line nr reader reader = new reader this reader this builder add data reader this reader get systemid this reader get line nr reader close } process doc type { if ! xml util check literal this reader { xml util expected input reader get systemid reader get line nr <! } xml util skip whitespace this reader systemid = buffer publicid = new buffer root element = xml util scan identifier this reader xml util skip whitespace this reader char ch = this reader read if ch == ' p' { systemid = xml util scan publicid publicid reader xml util skip whitespace this reader ch = this reader read } else if ch == ' s' { systemid = xml util scan systemid reader xml util skip whitespace this reader ch = this reader read } if ch == ' ' { this validator parse publicid to this reader this entity resolver xml util skip whitespace this reader ch = this reader read } if ch != '>' { xml util expected input reader get systemid reader get line nr `>' } if { if systemid != { reader reader = this reader open stream publicid to systemid this reader start new stream reader this reader set systemid systemid this reader set publicid publicid to this validator parse publicid to this reader this entity resolver } } } process element default namespace properties namespaces { full = xml util scan identifier this reader = full xml util skip whitespace this reader prefix = colon index = index of ' ' if colon index > 0 { prefix = substring 0 colon index = substring colon index + 1 } vector attr names = new vector vector attr values = new vector vector attr types = new vector this validator element started full this reader get systemid this reader get line nr char ch for { ch = this reader read if ch == '/' || ch == '>' { break } this reader unread ch this process attribute attr names attr values attr types xml util skip whitespace this reader } properties extra attributes = new properties this validator element attributes processed full extra attributes this reader get systemid this reader get line nr enumeration enm = extra attributes keys while enm has more elements { key = enm next element value = extra attributes get property key attr names add element key attr values add element value attr types add element } for = 0 < attr names size i++ { key = attr names element value = attr values element type = attr types element if key equals xmlns { default namespace = value } else if key starts with xmlns { namespaces put key substring 6 value } } if prefix == { this builder start element prefix default namespace this reader get systemid this reader get line nr } else { this builder start element prefix namespaces get property prefix this reader get systemid this reader get line nr } for = 0 < attr names size i++ { key = attr names element if key starts with xmlns { continue } value = attr values element type = attr types element colon index = key index of ' ' if colon index > 0 { att prefix = key substring 0 colon index key = key substring colon index + 1 this builder add attribute key att prefix namespaces get property att prefix value type } else { this builder add attribute key value type } } if prefix == { this builder element attributes processed prefix default namespace } else { this builder element attributes processed prefix namespaces get property prefix } if ch == '/' { if this reader read != '>' { xml util expected input reader get systemid reader get line nr `>' } this validator element ended this reader get systemid this reader get line nr if prefix == { this builder element prefix default namespace } else { this builder element prefix namespaces get property prefix } } buffer buffer = new buffer 16 for { buffer set length 0 for { xml util skip whitespace this reader buffer = xml util read this reader ' ' if char 0 == ' ' char 1 != '#' { xml util process entity this reader this entity resolver } else { break } } if char 0 == '<' { = xml util read this reader '\0' if char 0 == '/' { xml util skip whitespace this reader = xml util scan identifier this reader if ! equals full { xml util wrong closing tag reader get systemid reader get line nr } xml util skip whitespace this reader if this reader read != '>' { xml util closing tag not empty reader get systemid reader get line nr } this validator element ended full this reader get systemid this reader get line nr if prefix == { this builder element prefix default namespace } else { this builder element prefix namespaces get property prefix } break } else { this reader unread char 0 this scan some tag default namespace properties namespaces clone } } else { if char 0 == ' ' { ch = xml util process char literal buffer append ch } else { reader unread char 0 } this validator data added this reader get systemid this reader get line nr reader = new content reader this reader this entity resolver buffer to this builder add data this reader get systemid this reader get line nr close } } } process attribute vector attr names vector attr values vector attr types { key = xml util scan identifier this reader xml util skip whitespace this reader if ! xml util read this reader ' ' equals = { xml util expected input reader get systemid reader get line nr `=' } xml util skip whitespace this reader value = xml util scan this reader ' ' this entity resolver attr names add element key attr values add element value attr types add element this validator attribute added key value this reader get systemid this reader get line nr } } 