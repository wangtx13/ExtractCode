org jhotdraw draw import org jhotdraw util * import awt * import awt event * import awt geom * import util * import javax swing undo * import * import org jhotdraw draw attribute keys * import org jhotdraw geom * import org jhotdraw xml dom input import org jhotdraw xml dom output bezier figure attributed figure { attribute key< boolean> = new attribute key< boolean> closed bezier path path private transient bezier path capped path bezier figure { this } bezier figure closed { path = new bezier path set this closed } connector find connector point2 connection figure prototype { new chop bezier connector this } connector find compatible connector connector start { new chop bezier connector this } draw stroke graphics2 { if closed { grow = attribute keys get perpendicular draw growth this if grow == 0d { draw path } else { grow stroke gs = new grow stroke float grow float attribute keys get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this draw gs create stroked shape path } } else { draw get capped path } draw caps } draw caps graphics2 { if get point count > 1 { if START_DECORATION get this != { bezier path cp = get capped path point2 p1 = path get 0 0 point2 p2 = cp get 0 0 if p2 equals p1 { p2 = path get 1 0 } START_DECORATION get this draw this p1 p2 } if END_DECORATION get this != { bezier path cp = get capped path point2 p1 = path get path size 1 0 point2 p2 = cp get path size 1 0 if p2 equals p1 { p2 = path get path size 2 0 } END_DECORATION get this draw this p1 p2 } } } draw fill graphics2 { if closed { grow = attribute keys get perpendicular fill growth this if grow == 0d { fill path } else { grow stroke gs = new grow stroke float grow float attribute keys get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this fill gs create stroked shape path } } } contains point2 { if closed { grow = attribute keys get perpendicular hit growth this if grow == 0d { path contains } else { grow stroke gs = new grow stroke float grow float attribute keys get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this gs create stroked shape path contains } } else { tolerance = math max 2f attribute keys get stroke total width this / 2 if get capped path outline contains tolerance { } if START_DECORATION get this != { bezier path cp = get capped path point2 p1 = path get 0 0 point2 p2 = cp get 0 0 if geom line contains point p1 p1 p2 p2 tolerance { } } if END_DECORATION get this != { bezier path cp = get capped path point2 p1 = path get path size 1 0 point2 p2 = cp get path size 1 0 if geom line contains point p1 p1 p2 p2 tolerance { } } } } can connect { closed } collection< handle> create handles detail level { linked list< handle> handles = new linked list< handle> switch detail level { case 0 box handle kit add box handles this handles handles add new bezier scale handle this break case 1 for i=0 = path size < i++ { handles add new bezier node handle this } break } handles } rectangle2 get bounds { rectangle2 bounds =path get bounds2 bounds width = math max 1 bounds width bounds height = math max 1 bounds height bounds } rectangle2 get figure draw bounds { rectangle2 = super get figure draw bounds if get node count > 1 { if START_DECORATION get this != { point2 p1 = get point 0 0 point2 p2 = get point 1 0 add START_DECORATION get this get draw bounds this p1 p2 } if END_DECORATION get this != { point2 p1 = get point get node count 1 0 point2 p2 = get point get node count 2 0 add END_DECORATION get this get draw bounds this p1 p2 } } } validate { super validate path invalidate path invalidate capped path } bezier path get bezier path { bezier path path clone } point2 get point path float relative flatness { path get point path relative flatness } basic set bezier path bezier path new value { this path = new value this set closed new value closed } closed { get attribute } set closed new value { set this new value } basic set attribute attribute key key new value { if key == { path set closed new value } super basic set attribute key new value } basic set bounds point2 anchor point2 { basic set start point anchor basic set point invalidate } basic transform affine transform tx { path transform tx invalidate } invalidate { super invalidate path invalidate path invalidate capped path } invalidate capped path { capped path = } bezier path get capped path { if capped path == { capped path = bezier path path clone if closed { capped path set closed } else { if capped path size > 1 { if START_DECORATION get this != { bezier path node p0 = capped path get 0 bezier path node p1 = capped path get 1 point2 pp if p0 get mask bezier path C2_MASK != 0 { pp = p0 get control point 2 } else if p1 get mask bezier path C1_MASK != 0 { pp = p1 get control point 1 } else { pp = p1 get control point 0 } radius = START_DECORATION get this get decoration radius this line length = geom length p0 get control point 0 pp capped path set 0 0 geom cap pp p0 get control point 0 math min radius line length } if END_DECORATION get this != { bezier path node p0 = capped path get capped path size 1 bezier path node p1 = capped path get capped path size 2 point2 pp if p0 get mask bezier path C1_MASK != 0 { pp = p0 get control point 1 } else if p1 get mask bezier path C2_MASK != 0 { pp = p1 get control point 2 } else { pp = p1 get control point 0 } radius = END_DECORATION get this get decoration radius this line length = geom length p0 get control point 0 pp capped path set capped path size 1 0 geom cap pp p0 get control point 0 math min radius line length } capped path invalidate path } } } capped path } layout { } add node bezier path node { add node get node count } add node index bezier path node { bezier path node new point = new bezier path node will change basic add node index new point layout changed fire undoable edit happened new undoable edit { get presentation { punkt einf\u00fcgen } undo cannot undo { super undo will change basic remove node index changed } redo cannot undo { super redo will change basic add node index new point changed } } } basic add node bezier path node { path add invalidate } basic add node index bezier path node { path add index } set node index bezier path node { will change bezier path node old value = path get index bezier path node new value = new bezier path node basic set node index new value changed fire undoable edit happened new bezier node edit this index old value new value } basic set node index bezier path node { path set index } bezier path node get node index { bezier path node path get index clone } point2 get point index { path get index get control point 0 } point2 get point index coord { path get index get control point coord } set point index coord point2 { will change basic set point index coord changed } basic set point index point2 { bezier path node node = path get index dx = node 0 dy = node 0 for i=0 < node length i++ { node += dx node += dy } invalidate } basic set point index coord point2 { bezier path node cp = new bezier path node path get index cp set control point coord basic set node index cp } basic set start point point2 { basic set point 0 } basic set point point2 { basic set point get point count 1 } point2 get start point { get point 0 0 } point2 get point { get point get node count 1 0 } find node point2 { bezier path tp = path for i=0 < tp size i++ { bezier path node p2 = tp get if p2 0 == p2 0 == { } } 1 } remove all nodes { will change basic remove all nodes changed } remove node index { bezier path node old point = new bezier path node path get index will change basic remove node index layout changed fire undoable edit happened new undoable edit { get presentation { punkt entfernen } undo cannot undo { super undo will change basic add node index old point changed } redo cannot undo { super redo basic remove node index changed } } } find segment point2 find { point2 p1 p2 for = 0 = get node count 1 < i++ { p1 = path get 0 p2 = path get i+1 0 if geom line contains point p1 p1 p2 p2 find find 3d { } } 1 } basic join segments point2 join { = find segment join if != 1 > 1 { remove node } } basic split segment point2 split { = find segment split if != 1 { add node + 1 new bezier path node split } i+1 } basic remove node index { path remove index } basic remove all nodes { path clear } get node count { path size } get point count { path size } bezier figure clone { bezier figure that = bezier figure super clone that path = bezier path this path clone that invalidate that } restore to geometry { path set to bezier path geometry } get restore data { path clone } point2 chop point2 { if closed { grow = attribute keys get perpendicular hit growth this if grow == 0d { path chop } else { grow stroke gs = new grow stroke float grow float attribute keys get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this geom chop gs create stroked shape path } } else { path chop } } point2 get center { path get center } point2 get outermost point { path get path index of outermost node get control point 0 } basic join segments point2 join float tolerance { path join segments join tolerance } basic split segment point2 split float tolerance { path split segment split tolerance } handle mouse click point2 mouse event evt drawing view view { if evt get click count == 2 view get handle detail level == 1 { will change index = basic split segment float 5f / view get scale factor if index != 1 { bezier path node new node = get node index fire undoable edit happened new undoable edit { redo cannot redo { super redo will change basic add node index new node changed } undo cannot undo { super undo will change basic remove node index changed } } changed } } } write dom output out { write points out write attributes out } write points dom output out { out open element points if closed { out add attribute closed } for i=0 = get node count < i++ { bezier path node node = get node out open element if node mask != 0 { out add attribute mask node mask } if ! node keep colinear { out add attribute colinear } out add attribute node 0 out add attribute node 0 if node 1 != node 0 || node 1 != node 0 { out add attribute c1x node 1 out add attribute c1y node 1 } if node 2 != node 0 || node 2 != node 0 { out add attribute c2x node 2 out add attribute c2y node 2 } out close element } out close element } @ read dom input { read points read attributes } read points dom input { path clear open element points set closed get attribute closed for i=0 = get element count < i++ { open element bezier path node node = new bezier path node get attribute mask 0 get attribute 0d get attribute 0d get attribute c1x get attribute 0d get attribute c1y get attribute 0d get attribute c2x get attribute 0d get attribute c2y get attribute 0d node keep colinear = get attribute colinear path add node path invalidate path close element } close element } } 