org jhotdraw geom import org jhotdraw util * import awt * import awt geom * Bezier { private M A X P O I N T S = 1000 private Bezier { } String args { Point2 = {	 new Point2 0 0 0 0 new Point2 0 0 0 5 new Point2 1 1 1 4 new Point2 2 1 1 6 new Point2 3 2 1 1 new Point2 4 0 0 2 new Point2 4 0 0 0 } double	error = 4 0 		 General Path path = fit Curve error 	 System out path } General Path fit Curve Polygon error { Point2 = new Point2 npoints for i=0 < length i++ { = new Point2 xpoints ypoints } fit Curve error } General Path fit Curve Point2 error { Point2 Hat1 = new Point2 Point2 Hat2 = new Point2 General Path bezier Path = new General Path bezier Path move To float 0 float 0 Hat1 = compute Left Tangent 0 Hat2 = compute Right Tangent length - 1 fit Cubic 0 length - 1 Hat1 Hat2 error bezier Path bezier Path } Bezier Path fit Bezier Curve Bezier Path path error { Point2 = path to Polygon Array Point2 Hat1 = new Point2 Point2 Hat2 = new Point2 Bezier Path bezier Path = new Bezier Path bezier Path add new Bezier Path Node 0 Hat1 = compute Left Tangent 0 Hat2 = compute Right Tangent length - 1 fit Cubic 0 length - 1 Hat1 Hat2 error bezier Path bezier Path set Closed path Closed bezier Path } private fit Cubic Point2 first last Point2 Hat1 Point2 Hat2 error General Path bezier Path { Point2 bez Curve 		 Prime 	 double	max Error 	 	split Point = new 1 int	n Pts 		 double	iteration Error int	max Iterations = 4 Point2 Double	t Hat Center = new Point2 int	i iteration Error = error * error Pts = last - first + 1 if Pts == 2 { dist = v2 Distance Between2 Points last first / 3 0 bez Curve = new Point2 4 for i=0 < bez Curve length i++ { bez Curve = new Point2 } bez Curve 0 = first bez Curve 3 = last v2 Add bez Curve 0 v2 Scale Hat1 dist bez Curve 1 v2 Add bez Curve 3 v2 Scale Hat2 dist bez Curve 2 bezier Path curve To float bez Curve 1 float bez Curve 1 float bez Curve 2 float bez Curve 2 float bez Curve 3 float bez Curve 3 } = chord Length Parameterize first last bez Curve = generate Bezier first last Hat1 Hat2 max Error = compute Max Error first last bez Curve split Point if max Error < error { bezier Path curve To float bez Curve 1 float bez Curve 1 float bez Curve 2 float bez Curve 2 float bez Curve 3 float bez Curve 3 } if max Error < iteration Error { for = 0 < max Iterations i++ { Prime = reparameterize first last bez Curve bez Curve = generate Bezier first last Prime Hat1 Hat2 max Error = compute Max Error first last bez Curve Prime split Point if max Error < error { bezier Path curve To float bez Curve 1 float bez Curve 1 float bez Curve 2 float bez Curve 2 float bez Curve 3 float bez Curve 3 } = Prime } } Hat Center = compute Center Tangent split Point 0 fit Cubic first split Point 0 Hat1 Hat Center error bezier Path v2 Negate Hat Center fit Cubic split Point 0 last Hat Center Hat2 error bezier Path } private fit Cubic Point2 first last Point2 Hat1 Point2 Hat2 error Bezier Path bezier Path { Point2 bez Curve 		 Prime 	 double	max Error 	 	split Point = new 1 int	n Pts 		 double	iteration Error int	max Iterations = 4 Point2 Double	t Hat Center = new Point2 int	i iteration Error = error * error Pts = last - first + 1 if Pts == 2 { dist = v2 Distance Between2 Points last first / 3 0 bez Curve = new Point2 4 for i=0 < bez Curve length i++ { bez Curve = new Point2 } bez Curve 0 = first bez Curve 3 = last v2 Add bez Curve 0 v2 Scale Hat1 dist bez Curve 1 v2 Add bez Curve 3 v2 Scale Hat2 dist bez Curve 2 bezier Path curve To bez Curve 1 bez Curve 1 bez Curve 2 bez Curve 2 bez Curve 3 bez Curve 3 } = chord Length Parameterize first last bez Curve = generate Bezier first last Hat1 Hat2 max Error = compute Max Error first last bez Curve split Point if max Error < error { bezier Path curve To bez Curve 1 bez Curve 1 bez Curve 2 bez Curve 2 bez Curve 3 bez Curve 3 } if max Error < iteration Error { for = 0 < max Iterations i++ { Prime = reparameterize first last bez Curve bez Curve = generate Bezier first last Prime Hat1 Hat2 max Error = compute Max Error first last bez Curve Prime split Point if max Error < error { bezier Path curve To bez Curve 1 bez Curve 1 bez Curve 2 bez Curve 2 bez Curve 3 bez Curve 3 } = Prime } } Hat Center = compute Center Tangent split Point 0 fit Cubic first split Point 0 Hat1 Hat Center error bezier Path v2 Negate Hat Center fit Cubic split Point 0 last Hat Center Hat2 error bezier Path } private Point2 generate Bezier Point2 first last Prime Point2 Hat1 Point2 Hat2 { 	i Point2 A = new Point2 M A X P O I N T S 2 	n Pts 			 C = new 2 2 X = new 2 	 	det_C0_C1 		 det_C0_X det_X_C1 	alpha_l 		 alpha_r Point2 	tmp = new Point2 Point2 bez Curve 	 bez Curve = new Point2 4 for i=0 < bez Curve length i++ { bez Curve = new Point2 } Pts = last - first + 1 for = 0 < Pts i++ { Point2 v1 v2 v1 = Point2 Hat1 clone v2 = Point2 Hat2 clone v2 Scale v1 b1 Prime v2 Scale v2 b2 Prime A 0 = v1 A 1 = v2 } C 0 0 = 0 0 C 0 1 = 0 0 C 1 0 = 0 0 C 1 1 = 0 0 X 0 = 0 0 X 1 = 0 0 for = 0 < Pts i++ { C 0 0 += v2 Dot A 0 A 0 C 0 1 += v2 Dot A 0 A 1 C 1 0 = C 0 1 C 1 1 += v2 Dot A 1 A 1 tmp = v2 Sub I I first + v2 Add I I v2 Scale I I I first b0 Prime v2 Add I I v2 Scale I I I first b1 Prime v2 Add I I v2 Scale I I I last b2 Prime v2 Scale I I I last b3 Prime X 0 += v2 Dot A 0 tmp X 1 += v2 Dot A 1 tmp } det_C0_C1 = C 0 0 * C 1 1 - C 1 0 * C 0 1 det_C0_X = C 0 0 * X 1 - C 0 1 * X 0 det_X_C1 = X 0 * C 1 1 - X 1 * C 0 1 if det_C0_C1 == 0 0 { det_C0_C1 = C 0 0 * C 1 1 * 10e-12 } alpha_l = det_X_C1 / det_C0_C1 alpha_r = det_C0_X / det_C0_C1 if alpha_l < 1 0e-6 || alpha_r < 1 0e-6 { dist = v2 Distance Between2 Points last first / 3 0 bez Curve 0 = first bez Curve 3 = last v2 Add bez Curve 0 v2 Scale Hat1 dist bez Curve 1 v2 Add bez Curve 3 v2 Scale Hat2 dist bez Curve 2 bez Curve } bez Curve 0 = first bez Curve 3 = last v2 Add bez Curve 0 v2 Scale Hat1 alpha_l bez Curve 1 v2 Add bez Curve 3 v2 Scale Hat2 alpha_r bez Curve 2 bez Curve } private reparameterize Point2 first last Point2 bez Curve { 	n Pts = last-first+1 	i Prime Prime = new Pts for = first <= last i++ { Prime i-first = newton Raphson Root Find bez Curve i-first } Prime } private newton Raphson Root Find Point2 Q Point2 P { 		numerator denominator Point2 Q1 = new Point2 3 Q2 = new Point2 2 	 Point2 Double	Q_u = new Point2 Q1_u = new Point2 Q2_u = new Point2 		u Prime 		 		i Q_u = bezier I I 3 Q for = 0 <= 2 i++ { Q1 = new Point2 Q i+1 - Q * 3 0 Q i+1 - Q * 3 0 } for = 0 <= 1 i++ { Q2 = new Point2 Q1 i+1 - Q1 * 2 0 Q1 i+1 - Q1 * 2 0 } Q1_u = bezier I I 2 Q1 Q2_u = bezier I I 1 Q2 numerator = Q_u - P * Q1_u + Q_u - P * Q1_u denominator = Q1_u * Q1_u + Q1_u * Q1_u + Q_u - P * Q2_u + Q_u - P * Q2_u Prime = - numerator/denominator Prime } private Point2 bezier I I degree Point2 V { 	i Point2 Q Point2 Vtemp Vtemp = new Point2 degree+1 for = 0 <= degree i++ { Vtemp = Point2 V clone } for = 1 <= degree i++ { for = 0 <= degree-i j++ { Vtemp = 1 0 - * Vtemp + * Vtemp j+1 Vtemp = 1 0 - * Vtemp + * Vtemp j+1 } } Q = Vtemp 0 Q } private b0 { tmp = 1 0 - tmp * tmp * tmp } private b1 { tmp = 1 0 - 3 * * tmp * tmp } private b2 { tmp = 1 0 - 3 * * * tmp } private b3 { * * } private Point2 compute Left Tangent Point2 { Point2 Double	t Hat1 = new Point2 Hat1 = v2 Sub I I end+1 Hat1 = v2 Normalize Hat1 Hat1 } private Point2 compute Right Tangent Point2 { Point2 Hat2 = new Point2 Hat2 = v2 Sub I I end-1 Hat2 = v2 Normalize Hat2 Hat2 } private Point2 compute Center Tangent Point2 center { Point2 V1 = new Point2 V2 = new Point2 Hat Center = new Point2 V1 = v2 Sub I I center-1 center V2 = v2 Sub I I center center+1 Hat Center = V1 + V2 /2 0 Hat Center = V1 + V2 /2 0 Hat Center = v2 Normalize Hat Center Hat Center } private chord Length Parameterize Point2 first last { int	i 	 = new last-first+1 0 = 0 0 for = first+1 <= last i++ { i-first = i-first-1 + v2 Distance Between2 Points i-1 } for = first + 1 <= last i++ { i-first = i-first / last-first } } private compute Max Error Point2 first last Point2 bez Curve split Point { int		i double	max Dist 		 double	dist 		 Point2 Double	 P = new Point2 Point2 Double	v = new Point2 split Point 0 = last - first + 1 /2 max Dist = 0 0 for = first + 1 < last i++ { P = bezier I I 3 bez Curve i-first = v2 Sub I I P dist = v2 Squared Length if dist >= max Dist { max Dist = dist split Point 0 = } } max Dist } private Point2 v2 Add I I Point2 Point2 { Point2 = new Point2 = + = + } private Point2 v2 Scale I I I Point2 { Point2 result = new Point2 result = * result = * result } private Point2 v2 Sub I I Point2 Point2 { Point2 = new Point2 = - = - } private v2 Distance Between2 Points Point2 Point2 { dx = - dy = - Math sqrt dx*dx + dy*dy } private Point2 v2 Scale Point2 newlen { len = v2 Length if len != 0 0 { *= newlen/len *= newlen/len } } private v2 Length Point2 { Math sqrt v2 Squared Length } private v2 Squared Length Point2 { * + * } private Point2 v2 Add Point2 Point2 Point2 { = x+b = y+b } private Point2 v2 Negate Point2 { = -v = -v } private v2 Dot Point2 Point2 { x*b + y*b } private Point2 v2 Normalize Point2 { len = v2 Length if len != 0 0 { /= len /= len } } } 