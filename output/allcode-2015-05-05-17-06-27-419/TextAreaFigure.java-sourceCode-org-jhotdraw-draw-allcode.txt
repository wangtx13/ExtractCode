org jhotdraw draw import org jhotdraw util * import awt * import awt font * import awt geom * import text * import util * import * import org jhotdraw draw Attribute Keys * import org jhotdraw geom * import org jhotdraw xml Dom Input import org jhotdraw xml Dom Output Text Area Figure Attributed Figure implements Text Holder { private Rectangle2 bounds = new Rectangle2 private editable = private Basic Stroke dashes = new Basic Stroke 1f Basic Stroke CAP_BUTT Basic Stroke JOIN_BEVEL 0f new float {4f 4f} 0f transient private Text Layout text Layout Text Area Figure { this Text } Text Area Figure String text { set Text text } String get Text { String get Attribute T E X T } set Text String new Text { set Attribute T E X T new Text } basic Set Bounds Point2 anchor Point2 { bounds = Math min anchor bounds = Math min anchor bounds width = Math max 1 Math - anchor bounds height = Math max 1 Math - anchor text Layout = } basic Transform Affine Transform tx { Point2 anchor = get Start Point Point2 = get End Point basic Set Bounds Point2 tx transform anchor anchor Point2 tx transform } contains Point2 { bounds contains } Insets2 get Insets { sw = Math ceil STROKE_WIDTH get this / 2 Insets2 insets = new Insets2 4 4 4 4 new Insets2 insets top+sw insets left+sw insets bottom+sw insets right+sw } get Tab Size { 8 } draw Text Graphics2 { if get Text != || Editable { Font font = get Font Underlined = FONT_UNDERLINED get this Insets2 insets = get Insets Rectangle2 text Rect = new Rectangle2 bounds + insets left bounds + insets top bounds width - insets left - insets right bounds height - insets top - insets bottom float left Margin = float text Rect float right Margin = float Math max left Margin + 1 text Rect + text Rect width float vertical Pos = float text Rect if left Margin < right Margin { float tab Width = float get Tab Size * get Font Metrics font char Width 'm' float tab Stops = new float text Rect width / tab Width for i=0 < tab Stops length i++ { tab Stops = float text Rect + tab Width * + 1 } if get Text != { Shape saved Clip Area = get Clip clip text Rect String paragraphs = get Text split \n for = 0 < paragraphs length i++ { if paragraphs length == 0 paragraphs = Attributed String = new Attributed String paragraphs add Attribute Text Attribute F O N T font if Underlined { add Attribute Text Attribute U N E R L I N E Text Attribute UNDERLINE_LOW_ONE_PIXEL } tab Count = new String Tokenizer paragraphs \t count Tokens - 1 vertical Pos = draw Paragraph get Iterator vertical Pos left Margin right Margin tab Stops tab Count if vertical Pos > text Rect + text Rect height { break } } set Clip saved Clip Area } } if left Margin >= right Margin || vertical Pos > text Rect + text Rect height { set Color Color red set Stroke dashes draw new Line2 text Rect text Rect + text Rect height - 1 text Rect + text Rect width - 1 text Rect + text Rect height - 1 } } } private float draw Paragraph Graphics2 Attributed Character Iterator styled Text float vertical Pos float left Margin float right Margin float tab Stops tab Count { tab Locations = new tab Count+1 = 0 for char = styled Text first != styled Text O N E = styled Text next { if == '\t' { tab Locations i++ = styled Text get Index } } tab Locations tab Count = styled Text get End Index - 1 Line Break Measurer measurer = new Line Break Measurer styled Text get Font Render Context current Tab = 0 while measurer get Position < styled Text get End Index { line Contains Text = line Complete = float max Ascent = 0 max Descent = 0 float horizontal Pos = left Margin Linked List< Text Layout> layouts = new Linked List< Text Layout> Linked List< Float> pen Positions = new Linked List< Float> while !line Complete { float wrapping Width = right Margin - horizontal Pos Text Layout layout = layout = measurer next Layout wrapping Width tab Locations current Tab +1 line Contains Text if layout != { layouts add layout pen Positions add horizontal Pos horizontal Pos += layout get Advance max Ascent = Math max max Ascent layout get Ascent max Descent = Math max max Descent layout get Descent + layout get Leading } else { line Complete = } line Contains Text = if measurer get Position == tab Locations current Tab +1 { current Tab++ } if measurer get Position == styled Text get End Index line Complete = else if tab Stops length == 0 || horizontal Pos >= tab Stops tab Stops length-1 line Complete = if !line Complete { for j=0 horizontal Pos >= tab Stops j++ {} horizontal Pos = tab Stops } } vertical Pos += max Ascent Iterator< Text Layout> layout Enum = layouts iterator Iterator< Float> position Enum = pen Positions iterator while layout Enum has Next { Text Layout next Layout = layout Enum next float next Position = position Enum next next Layout draw next Position vertical Pos } vertical Pos += max Descent } vertical Pos } draw Fill Graphics2 { fill bounds } draw Stroke Graphics2 { draw bounds } Rectangle2 get Bounds { Rectangle2 bounds get Bounds2 } Collection< Handle> create Handles detail Level { Linked List< Handle> handles = Linked List< Handle> super create Handles detail Level if detail Level == 0 { handles add new Font Size Handle this } handles } validate { super validate text Layout = } Editable { editable } set Editable { this editable = } get Text Columns { get Text == ? 4 Math max get Text length 4 } Tool get Tool Point2 { Editable contains ? new Text Area Tool this } read Bounds Dom Input I O Exception { bounds = get Attribute 0d bounds = get Attribute 0d bounds width = get Attribute 0d bounds height = get Attribute 0d } write Bounds Dom Output out I O Exception { out add Attribute bounds out add Attribute bounds out add Attribute bounds width out add Attribute bounds height } read Dom Input I O Exception { read Bounds read Attributes text Layout = } write Dom Output out I O Exception { write Bounds out write Attributes out } Text Area Figure clone { Text Area Figure that = Text Area Figure super clone that bounds = Rectangle2 this bounds clone that } Text Holder get Label For { this } restore To Object geometry { Rectangle2 = Rectangle2 geometry bounds = bounds = bounds width = width bounds height = height } Object get Restore Data { bounds clone } Font get Font { Attribute Keys get Font this } Color get Text Color { TEXT_COLOR get this } Color get Fill Color { FILL_COLOR get this } set Font Size float size { FONT_SIZE set this new size } float get Font Size { FONT_SIZE get this float Value } } 