nanoxml import * import util * Xml Element { long serial Version Uid = 6685035139346394777 L NANOXML_MAJOR_VERSION = 2 NANOXML_MINOR_VERSION = 2 private Hash Map attributes private Array List children private String private String contents private Hash Map entities private line Nr private ignore Case private ignore Whitespace private char char Read Too Much private Reader reader private parser Line Nr private Encode Unicode Characters = Xml Element { this new Hash Map } Xml Element Hash Map entities { this entities } Xml Element skip Leading Whitespace { this new Hash Map skip Leading Whitespace } Xml Element Hash Map entities skip Leading Whitespace { this entities skip Leading Whitespace } Xml Element Hash Map entities skip Leading Whitespace ignore Case { this entities skip Leading Whitespace ignore Case } Xml Element Hash Map entities skip Leading Whitespace fill Basic Conversion Table ignore Case { this entities skip Leading Whitespace fill Basic Conversion Table ignore Case } Xml Element Hash Map entities skip Leading Whitespace fill Basic Conversion Table ignore Case encode Unicode Characters { this ignore Whitespace = skip Leading Whitespace this ignore Case = ignore Case this = this contents = this attributes = new Hash Map this children = new Array List this entities = entities this line Nr = 0 this Encode Unicode Characters = encode Unicode Characters Iterator iter = this entities key Set iterator while iter has Next { Object key = iter next Object value = this entities get key if value instanceof String { value = String value to Char Array this entities put key value } } if fill Basic Conversion Table { this entities put amp new char { ' ' } this entities put quot new char { ' ' } this entities put apos new char { '\'' } this entities put lt new char { '<' } this entities put new char { '>' } } } add Child Xml Element child { this children add child } set Attribute String Object value { if this ignore Case { = to Upper Case } this attributes put value to String } set Int Attribute String value { if this ignore Case { = to Upper Case } this attributes put Integer to String value } set Attribute String value { if this ignore Case { = to Upper Case } this attributes put to String value } count Children { this children size } Iterator enumerate Attribute Names { this attributes key Set iterator } Iterator iterate Children { this children iterator } Array List get Children { try { Array List this children clone } catch Exception { } } String get Content { this contents } get Line Nr { this line Nr } Object get Attribute String { this get Attribute } Object get Attribute String Object default Value { if this ignore Case { = to Upper Case } Object value = this attributes get if value == { value = default Value } value } Object get Attribute String Map value Set String default Key allow Literals { if this ignore Case { = to Upper Case } Object key = this attributes get Object result if key == { key = default Key } result = value Set get key if result == { if allow Literals { result = key } else { this invalid Value String key } } result } String get String Attribute String { this get String Attribute } String get String Attribute String String default Value { String this get Attribute default Value } String get String Attribute String Hash Map value Set String default Key allow Literals { String this get Attribute value Set default Key allow Literals } get Int Attribute String { this get Int Attribute 0 } get Int Attribute String default Value { if this ignore Case { = to Upper Case } String value = String this attributes get if value == { default Value } else { try { Integer parse Int value } catch Number Format Exception { this invalid Value value } } } get Int Attribute String min max default Value { = get Int Attribute default Value if < min min if > max max } get Int Attribute String Hash Map value Set String default Key allow Literal Numbers { if this ignore Case { = to Upper Case } Object key = this attributes get Integer result if key == { key = default Key } try { result = Integer value Set get key } catch Class Cast Exception { this invalid Value Set } if result == { if ! allow Literal Numbers { this invalid Value String key } try { result = Integer value Of String key } catch Number Format Exception { this invalid Value String key } } result Value } get Attribute String { this get Attribute 0 } get Attribute String default Value { if this ignore Case { = to Upper Case } String value = String this attributes get if value == { default Value } else { try { value Of value Value } catch Number Format Exception { this invalid Value value } } } get Attribute String Hash Map value Set String default Key allow Literal Numbers { if this ignore Case { = to Upper Case } Object key = this attributes get result if key == { key = default Key } try { result = value Set get key } catch Class Cast Exception { this invalid Value Set } if result == { if ! allow Literal Numbers { this invalid Value String key } try { result = value Of String key } catch Number Format Exception { this invalid Value String key } } result Value } get Boolean Attribute String String Value String Value default Value { if this ignore Case { = to Upper Case } Object value = this attributes get if value == { default Value } else if value equals Value { } else if value equals Value { } else { this invalid Value String value } } get Boolean Attribute String default Value { get Boolean Attribute default Value } String get Name { this } parse From Reader Reader reader I O Exception Xml Parse Exception { this parse From Reader reader 1 } parse From Reader Reader reader starting Line Nr I O Exception Xml Parse Exception { this = this contents = this attributes = new Hash Map this children = new Array List this char Read Too Much = '\0' this reader = reader this parser Line Nr = starting Line Nr for { char ch = this scan Whitespace if ch != '<' { this expected Input < } ch = this read Char if ch == '!' || ch == '?' { this skip Special Tag 0 } else { this unread Char ch this scan Element this } } } parse String String Xml Parse Exception { try { this parse From Reader new String Reader 1 } catch I O Exception { } } parse String String offset Xml Parse Exception { this parse String substring offset } parse String String offset Xml Parse Exception { this parse String substring offset } parse String String offset starting Line Nr Xml Parse Exception { = substring offset try { this parse From Reader new String Reader starting Line Nr } catch I O Exception { } } parse Char Array char input offset Xml Parse Exception { this parse Char Array input offset 1 } parse Char Array char input offset starting Line Nr Xml Parse Exception { try { Reader reader = new Char Array Reader input offset this parse From Reader reader starting Line Nr } catch I O Exception { } } remove Child Xml Element child { this children remove child } remove Attribute String { if this ignore Case { = to Upper Case } this attributes remove } Xml Element create Element String { Xml Element elem = create Element elem set Name elem } Xml Element create Element { new Xml Element this entities this ignore Whitespace this ignore Case this Encode Unicode Characters } set Content String content { this contents = content } set Name String { this = } String to String { try { Byte Array Output Stream out = new Byte Array Output Stream Output Stream Writer writer = new Output Stream Writer out this write writer writer flush new String out to Byte Array } catch I O Exception { super to String } } write Writer writer I O Exception { if this == { this write Encoded writer this contents } writer write '<' writer write this if ! this attributes Empty { Iterator iter = this attributes key Set iterator while iter has Next { writer write ' ' String key = String iter next String value = String this attributes get key writer write key writer write '=' writer write ' ' this write Encoded writer value writer write ' ' } } if this contents != this contents length > 0 { writer write '>' this write Encoded writer this contents writer write '<' writer write '/' writer write this writer write '>' } else if this children Empty { writer write '/' writer write '>' } else { writer write '>' Iterator iter = this iterate Children while iter has Next { Xml Element child = Xml Element iter next child write writer } writer write '<' writer write '/' writer write this writer write '>' } } Print Writer writer { writer 0 } Print Writer writer indent { try { if this == { this write Encoded writer this contents } char spaces = new char indent * 2 Arrays fill spaces ' ' writer write spaces writer write '<' writer write this if ! this attributes Empty { Iterator enm = this attributes key Set iterator while enm has Next { writer write ' ' String key = String enm next String value = String this attributes get key writer write key writer write '=' writer write ' ' this write Encoded writer value writer write ' ' } } if this contents != this contents length > 0 { writer write '>' this write Encoded writer this contents writer write '<' writer write '/' writer write this writer write '>' } else if this children Empty { writer write '/' writer write '>' } else { writer write '>' writer write '\n' Iterator enm = this get Children iterator while enm has Next { Xml Element child = Xml Element enm next child writer indent + 1 } writer write spaces writer write '<' writer write '/' writer write this writer write '>' } writer write '\n' } catch I O Exception { Internal Error error = new Internal Error get Message error init Cause error } } write Encoded Writer writer String I O Exception { for = 0 < length += 1 { char ch = char At switch ch { case '<' writer write ' ' writer write 'l' writer write 't' writer write ' ' break case '>' writer write ' ' writer write 'g' writer write 't' writer write ' ' break case ' ' writer write ' ' writer write 'a' writer write 'm' writer write 'p' writer write ' ' break case ' ' writer write ' ' writer write 'q' writer write 'u' writer write 'o' writer write 't' writer write ' ' break case '\'' writer write ' ' writer write 'a' writer write 'p' writer write 'o' writer write 's' writer write ' ' break default unicode = ch if unicode < 32 || Encode Unicode Characters unicode > 126 { writer write ' ' writer write '#' writer write 'x' writer write Integer to String unicode 16 writer write ' ' } else { writer write ch } } } } scan Identifier String Buffer result I O Exception { for { char ch = this read Char if ch < ' A' || ch > ' Z' ch < 'a' || ch > 'z' ch < '0' || ch > '9' ch != '_' ch != ' ' ch != ' ' ch != '-' ch <= '\u007 E' { this unread Char ch } result append ch } } char scan Whitespace I O Exception { for { char ch = this read Char switch ch { case ' ' case '\t' case '\n' case '\r' break default ch } } } char scan Whitespace String Buffer result I O Exception { for { char ch = this read Char switch ch { case ' ' case '\t' case '\n' result append ch case '\r' break default ch } } } scan String String Buffer I O Exception { char delimiter = this read Char if delimiter != '\'' delimiter != ' ' { this expected Input ' or \ } for { char ch = this read Char if ch == delimiter { } else if ch == ' ' { this resolve Entity } else { append ch } } } scan P C Data String Buffer data I O Exception { for { char ch = this read Char if ch == '<' { ch = this read Char if ch == '!' { this check C A T A data } else { this unread Char ch } } else if ch == ' ' { this resolve Entity data } else { data append ch } } } check C A T A String Buffer buf I O Exception { char ch = this read Char if ch != ' ' { this unread Char ch this skip Special Tag 0 } else if ! this check Literal C A T A { this skip Special Tag 1 } else { delimiter Chars Skipped = 0 while delimiter Chars Skipped < 3 { ch = this read Char switch ch { case ' ' if delimiter Chars Skipped < 2 { delimiter Chars Skipped += 1 } else { buf append ' ' buf append ' ' delimiter Chars Skipped = 0 } break case '>' if delimiter Chars Skipped < 2 { for = 0 < delimiter Chars Skipped i++ { buf append ' ' } delimiter Chars Skipped = 0 buf append '>' } else { delimiter Chars Skipped = 3 } break default for = 0 < delimiter Chars Skipped += 1 { buf append ' ' } buf append ch delimiter Chars Skipped = 0 } } } } skip Comment I O Exception { dashes To Read = 2 while dashes To Read > 0 { char ch = this read Char if ch == '-' { dashes To Read -= 1 } else { dashes To Read = 2 } } if this read Char != '>' { this expected Input > } } skip Special Tag bracket Level I O Exception { tag Level = 1 char Delimiter = '\0' if bracket Level == 0 { char ch = this read Char if ch == ' ' { bracket Level += 1 } else if ch == '-' { ch = this read Char if ch == ' ' { bracket Level += 1 } else if ch == ' ' { bracket Level -= 1 } else if ch == '-' { this skip Comment } } } while tag Level > 0 { char ch = this read Char if Delimiter == '\0' { if ch == ' ' || ch == '\'' { Delimiter = ch } else if bracket Level <= 0 { if ch == '<' { tag Level += 1 } else if ch == '>' { tag Level -= 1 } } if ch == ' ' { bracket Level += 1 } else if ch == ' ' { bracket Level -= 1 } } else { if ch == Delimiter { Delimiter = '\0' } } } } check Literal String literal I O Exception { length = literal length for = 0 < length += 1 { if this read Char != literal char At { } } } char read Char I O Exception { if this char Read Too Much != '\0' { char ch = this char Read Too Much this char Read Too Much = '\0' ch } else { = this reader read if < 0 { this unexpected End Of Data } else if == 10 { this parser Line Nr += 1 '\n' } else { char } } } scan Element Xml Element elt I O Exception { String Buffer buf = new String Buffer this scan Identifier buf String = buf to String elt set Name char ch = this scan Whitespace while ch != '>' ch != '/' { buf set Length 0 this unread Char ch this scan Identifier buf String key = buf to String ch = this scan Whitespace if ch != '=' { this expected Input = } this unread Char this scan Whitespace buf set Length 0 this scan String buf elt set Attribute key buf ch = this scan Whitespace } if ch == '/' { ch = this read Char if ch != '>' { this expected Input > } } buf set Length 0 ch = this scan Whitespace buf if ch != '<' { this unread Char ch this scan P C Data buf } else { for { ch = this read Char if ch == '!' { if this check C A T A buf { this scan P C Data buf break } else { ch = this scan Whitespace buf if ch != '<' { this unread Char ch this scan P C Data buf break } } } else { if ch != '/' || this ignore Whitespace { buf set Length 0 } if ch == '/' { this unread Char ch } break } } } if buf length == 0 { while ch != '/' { if ch == '!' { ch = this read Char if ch != '-' { this expected Input Comment or Element } ch = this read Char if ch != '-' { this expected Input Comment or Element } this skip Comment } else { this unread Char ch Xml Element child = this create Element this scan Element child elt add Child child } ch = this scan Whitespace if ch != '<' { this expected Input < } ch = this read Char } this unread Char ch } else { if this ignore Whitespace { elt set Content buf to String trim } else { elt set Content buf to String } } ch = this read Char if ch != '/' { this expected Input / } this unread Char this scan Whitespace if ! this check Literal { this expected Input } if this scan Whitespace != '>' { this expected Input > } } resolve Entity String Buffer buf I O Exception { char ch = '\0' String Buffer key Buf = new String Buffer for { ch = this read Char if ch == ' ' { break } key Buf append ch } String key = key Buf to String if key char At 0 == '#' { try { if key char At 1 == 'x' { ch = char Integer parse Int key substring 2 16 } else { ch = char Integer parse Int key substring 1 10 } } catch Number Format Exception { this unknown Entity key } buf append ch } else { char value = char this entities get key if value == { this unknown Entity key } buf append value } } unread Char char ch { this char Read Too Much = ch } Xml Parse Exception invalid Value Set String { String msg = Invalid value set entity = \ + + \ new Xml Parse Exception this get Name this parser Line Nr msg } Xml Parse Exception invalid Value String String value { String msg = Attribute \ + + \ does not contain valid + value \ + value + \ new Xml Parse Exception this get Name this parser Line Nr msg } Xml Parse Exception unexpected End Of Data { String msg = Unexpected of data reached new Xml Parse Exception this get Name this parser Line Nr msg } Xml Parse Exception syntax Error String context { String msg = Syntax error while parsing + context new Xml Parse Exception this get Name this parser Line Nr msg } Xml Parse Exception expected Input String char Set { String msg = Expected + char Set new Xml Parse Exception this get Name this parser Line Nr msg } Xml Parse Exception unknown Entity String { String msg = Unknown or invalid entity + + new Xml Parse Exception this get Name this parser Line Nr msg } } 