org jhotdraw geom import awt * import awt geom * import awt font * Stroke implements Stroke { private Basic Stroke outline Stroke private float inner Width private float outline Width private miter Limit private float dashes private float dash Phase Stroke float inner Width float outline Width { this inner Width outline Width Basic Stroke CAP_SQUARE Basic Stroke JOIN_BEVEL 10f 0f } Stroke float inner Width float outline Width cap join float miter Limit float dashes float dash Phase { this inner Width = inner Width this outline Width = outline Width this miter Limit = miter Limit outline Stroke = new Basic Stroke outline Width cap Basic Stroke JOIN_BEVEL miter Limit dashes dash Phase } Shape create Stroked Shape Shape { Bezier Path bp = new Bezier Path General Path left = new General Path General Path right = new General Path coords = new 6 for Path Iterator = get Path Iterator 0 1d ! Done next { type = current Segment coords switch type { case Path Iterator SEG_MOVETO if bp size != 0 { trace Stroke bp left right } bp clear bp set Closed bp move To coords 0 coords 1 break case Path Iterator SEG_LINETO if coords 0 != bp get bp size - 1 0 || coords 1 != bp get bp size - 1 0 { bp line To coords 0 coords 1 } break case Path Iterator SEG_QUADTO bp quad To coords 0 coords 1 coords 2 coords 3 break case Path Iterator SEG_CUBICTO bp curve To coords 0 coords 1 coords 2 coords 3 coords 4 coords 5 break case Path Iterator SEG_CLOSE bp set Closed break } } if bp size != 0 { trace Stroke bp left right } right append left outline Stroke create Stroked Shape right } trace Stroke Bezier Path bp General Path left General Path right { current Corners = new 8 prev Corners = new 8 Point2 intersect if bp Closed { Bezier Path Node prev = bp get bp size - 1 for i=0 < bp size i++ { Bezier Path Node node = bp get if prev 0 == node 0 prev 0 == node 0 { bp remove i-- } else { prev = node } } } else { Bezier Path Node prev = bp get 0 for i=1 < bp size i++ { Bezier Path Node node = bp get if prev 0 == node 0 prev 0 == node 0 { bp remove i-- } else { prev = node } } } if bp Closed bp size > 1 { prev Corners = compute Thick Line bp get bp size - 1 0 bp get bp size - 1 0 bp get 0 0 bp get 0 0 inner Width prev Corners current Corners = compute Thick Line bp get 0 0 bp get 0 0 bp get 1 0 bp get 1 0 inner Width current Corners intersect = Geom intersect prev Corners 0 prev Corners 1 prev Corners 4 prev Corners 5 current Corners 0 current Corners 1 current Corners 4 current Corners 5 miter Limit if intersect != { right move To float intersect float intersect } else { right move To float prev Corners 4 float prev Corners 5 right line To float current Corners 0 float current Corners 1 } intersect = Geom intersect prev Corners 2 prev Corners 3 prev Corners 6 prev Corners 7 current Corners 2 current Corners 3 current Corners 6 current Corners 7 miter Limit if intersect != { left move To float intersect float intersect } else { left move To float prev Corners 6 float prev Corners 7 left line To float current Corners 2 float current Corners 3 } } else { if bp size > 1 { current Corners = compute Thick Line bp get 0 0 bp get 0 0 bp get 1 0 bp get 1 0 inner Width current Corners right move To float current Corners 0 float current Corners 1 left move To float current Corners 2 float current Corners 3 } } for i=1 = bp size - 1 < i++ { tmp = prev Corners prev Corners = current Corners current Corners = compute Thick Line bp get 0 bp get 0 bp get i+1 0 bp get i+1 0 inner Width tmp intersect = Geom intersect prev Corners 0 prev Corners 1 prev Corners 4 prev Corners 5 current Corners 0 current Corners 1 current Corners 4 current Corners 5 miter Limit if intersect != { right line To float intersect float intersect } else { right line To float prev Corners 4 float prev Corners 5 right line To float current Corners 0 float current Corners 1 } intersect = Geom intersect prev Corners 2 prev Corners 3 prev Corners 6 prev Corners 7 current Corners 2 current Corners 3 current Corners 6 current Corners 7 miter Limit if intersect != { left line To float intersect float intersect } else { left line To float prev Corners 6 float prev Corners 7 left line To float current Corners 2 float current Corners 3 } } if bp Closed { tmp = prev Corners prev Corners = current Corners current Corners = compute Thick Line bp get bp size - 1 0 bp get bp size - 1 0 bp get 0 0 bp get 0 0 inner Width tmp intersect = Geom intersect prev Corners 0 prev Corners 1 prev Corners 4 prev Corners 5 current Corners 0 current Corners 1 current Corners 4 current Corners 5 miter Limit if intersect != { right line To float intersect float intersect } else { right line To float prev Corners 4 float prev Corners 5 right line To float current Corners 0 float current Corners 1 } intersect = Geom intersect prev Corners 2 prev Corners 3 prev Corners 6 prev Corners 7 current Corners 2 current Corners 3 current Corners 6 current Corners 7 miter Limit if intersect != { left line To float intersect float intersect } else { left line To float prev Corners 6 float prev Corners 7 left line To float current Corners 2 float current Corners 3 } right close Path left close Path } else { right line To float current Corners 4 float current Corners 5 left line To float current Corners 6 float current Corners 7 } } private compute Thick Line seg offset corners { compute Thick Line seg 0+offset seg 1+offset seg 2+offset seg 3+offset inner Width corners } private compute Thick Line x1 y1 x2 y2 thickness corners { dx = x2 - x1 dy = y2 - y1 line Length = Math sqrt dx * dx + dy * dy scale = thickness / 2d * line Length ddx = -scale * dy ddy = scale * dx corners 0 = x1 + ddx corners 1 = y1 + ddy corners 2 = x1 - ddx corners 3 = y1 - ddy corners 4 = x2 + ddx corners 5 = y2 + ddy corners 6 = x2 - ddx corners 7 = y2 - ddy corners } } 