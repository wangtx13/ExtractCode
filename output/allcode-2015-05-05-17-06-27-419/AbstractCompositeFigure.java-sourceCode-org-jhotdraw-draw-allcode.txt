org jhotdraw draw import I O Exception import org jhotdraw util * import org jhotdraw util * import awt * import awt geom * import util * import javax swing event * import javax swing undo * import org jhotdraw geom * import org jhotdraw xml Dom Input import org jhotdraw xml Dom Output Abstract Composite Figure Abstract Figure implements Composite Figure { private Linked List< Figure> children = new Linked List< Figure> private Rectangle2 draw Bounds private Rectangle2 bounds private Layouter layouter private Child Handler child Handler = new Child Handler this private Child Handler implements Figure Listener Undoable Edit Listener { private Abstract Composite Figure owner private Child Handler Abstract Composite Figure owner { this owner = owner } figure Request Remove Figure Event { owner remove get Figure } figure Removed Figure Event evt { } figure Changed Figure Event { if ! owner Changing { owner will Change owner fire Figure Changed owner changed } } figure Added Figure Event { } figure Attribute Changed Figure Event { } figure Area Invalidated Figure Event { if ! owner Changing { owner fire Area Invalidated get Invalidated Area } } undoable Edit Happened Undoable Edit Event { owner fire Undoable Edit Happened get Edit } } Abstract Composite Figure { } Collection< Handle> create Handles detail Level { if detail Level == 0 { super create Handles 0 } Linked List< Handle> handles = new Linked List< Handle> handles } add Figure figure { add get Child Count figure } add index Figure figure { will Change basic Add index figure if get Drawing != { figure add Notify get Drawing } changed } add All Collection< Figure> new Figures { will Change for Figure new Figures { basic Add get Child Count if get Drawing != { add Notify get Drawing } } changed } basic Add Figure figure { basic Add get Child Count figure } basic Add index Figure figure { children add index figure figure add Figure Listener child Handler figure add Undoable Edit Listener child Handler } basic Add All Collection< Figure> new Figures { for Figure new Figures { basic Add get Child Count } } add Notify Drawing drawing { super add Notify drawing for Figure child children { child add Notify drawing } } remove Notify Drawing drawing { for Figure child new Linked List< Figure> children { child remove Notify drawing } super remove Notify drawing } remove Figure figure { index = children index Of figure if index == -1 { } else { will Change basic Remove Child index if get Drawing != { figure remove Notify get Drawing } changed } } Figure remove Child index { will Change Figure removed = basic Remove Child index if get Drawing != { removed remove Notify get Drawing } changed removed } basic Remove Figure figure { index = children index Of figure if index == -1 { } else { basic Remove Child index } } Figure basic Remove Child index { Figure figure = children remove index figure remove Figure Listener child Handler figure remove Undoable Edit Listener child Handler figure } remove All Children { will Change while children size > 0 { Figure = basic Remove Child children size - 1 if get Drawing != { add Notify get Drawing } } changed } basic Remove All Children { while children size > 0 { Figure = basic Remove Child children size - 1 } } synchronized send To Back Figure figure { if children remove figure { children add 0 figure figure invalidate } } synchronized send To Front Figure figure { if children remove figure { children add figure figure invalidate } } basic Transform Affine Transform tx { for Figure children { basic Transform tx } invalidate Bounds } basic Set Bounds Point2 anchor Point2 { Rectangle2 old Bounds = get Bounds Rectangle2 new Bounds = new Rectangle2 Math min anchor Math min anchor Math anchor - Math anchor - sx = new Bounds width / old Bounds width = new Bounds height / old Bounds height Affine Transform tx = new Affine Transform tx translate -old Bounds -old Bounds if ! Na N sx ! Na N sx != 1d || != 1d ! sx < 0 0001 ! < 0 0001 { basic Transform tx tx set To Identity tx scale sx basic Transform tx tx set To Identity } tx translate new Bounds new Bounds basic Transform tx } undoable Edit Happened Undoable Edit Event { fire Undoable Edit Happened get Edit } util List< Figure> get Children { Collections unmodifiable List children } get Child Count { children size } Figure get Child index { children get index } util List< Figure> get Children Front To Back { children == ? new Linked List< Figure> new Reversed List< Figure> children } set Attribute Attribute Key Object value { will Change for Figure child children { child set Attribute value } changed } basic Set Attribute Attribute Key Object value { for Figure child children { child basic Set Attribute value } } Object get Attribute Attribute Key { } contains Point2 { if get Draw Bounds contains { for Figure child get Children Front To Back { if child Visible child contains } } } Figure find Figure Inside Point2 { if get Draw Bounds contains { Figure found = for Figure child get Children Front To Back { if child Visible { found = child find Figure Inside if found != { found } } } } } Figure find Child Point2 { if get Bounds contains { Figure found = for Figure child get Children Front To Back { if child Visible child contains { child } } } } find Child Index Point2 { Figure child = find Child child == ? -1 children index Of child } Layouter get Layouter { layouter } layout { if get Layouter != { Rectangle2 bounds = get Bounds Point2 = new Point2 bounds bounds Rectangle2 = get Layouter layout this basic Set Bounds new Point2 new Point2 + width + height invalidate Bounds } } set Layouter Layouter new Layouter { this layouter = new Layouter } Dimension2 get Preferred Size { if this layouter != { Rectangle2 = layouter calculate Layout this get Start Point get End Point new Dimension2 width height } else { super get Preferred Size } } Rectangle2 get Figure Draw Bounds { if draw Bounds == { for Figure child get Children Front To Back { if child Visible { Rectangle2 child Bounds = child get Draw Bounds if ! child Bounds Empty { if draw Bounds == { draw Bounds = child Bounds } else { draw Bounds add child Bounds } } } } } draw Bounds == ? new Rectangle2 0 0 -1 -1 Rectangle2 draw Bounds clone } Rectangle2 get Bounds { if bounds == { for Figure child get Children Front To Back { if child Visible { if bounds == { bounds = child get Bounds } else { bounds add child get Bounds } } } } bounds == ? new Rectangle2 0 0 -1 -1 Rectangle2 bounds clone } draw Figure Graphics2 { for Figure child children { if child Visible { child draw } } if Connectors Visible { draw Connectors } } draw Connectors Graphics2 { } Abstract Composite Figure clone { Abstract Composite Figure that = Abstract Composite Figure super clone that child Handler = new Child Handler that that children = new Linked List< Figure> for Figure this Child this children { Figure that Child = Figure this Child clone that children add that Child that Child add Figure Listener that child Handler that Child add Undoable Edit Listener that child Handler } that } invalidate Bounds { bounds = draw Bounds = } Collection< Figure> get Decomposition { Linked List< Figure> list = new Linked List< Figure> list add this list add All get Children list } read Dom Input I O Exception { open Element children for i=0 < get Element Count i++ { add Figure read Object } close Element } write Dom Output out I O Exception { out open Element children for Figure child get Children { out write Object child } out close Element } Map< Attribute Key Object> get Attributes { new Hash Map< Attribute Key Object> } restore To Object geometry { Linked List list = Linked List geometry index = 0 for Object geom list { get Child index restore To geom index++ } invalidate Bounds } Object get Restore Data { Linked List< Object> list = new Linked List< Object> for Figure child children { list add child get Restore Data } list } will Change { super will Change if get Changing Depth == 1 { for Figure child children { child will Change } } } changed { if get Changing Depth == 1 { for Figure child children { child changed } } super changed } invalidate { super invalidate invalidate Bounds } validate { super validate layout invalidate Bounds } remove Attribute Attribute Key key { } has Attribute Attribute Key key { } } 