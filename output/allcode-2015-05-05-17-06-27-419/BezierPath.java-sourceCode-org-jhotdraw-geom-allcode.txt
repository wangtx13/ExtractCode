org jhotdraw geom import awt * import awt geom * import util * Bezier Path Array List< Bezier Path Node> implements Shape { C1_MASK = 1 C2_MASK = 2 C1C2_MASK = C1_MASK | C2_MASK private transient General Path general Path private outer = -1 private Closed Node implements Cloneable { mask = 0 = new 3 = new 3 keep Colinear = Node { mask = 1 } Node Node that { set To that } set To Node that { this mask = that mask this keep Colinear = that keep Colinear System arraycopy that 0 this 0 3 System arraycopy that 0 this 0 3 } Node Point2 c0 { this mask = 0 0 = c0 0 = c0 1 = c0 1 = c0 2 = c0 2 = c0 } Node mask Point2 c0 Point2 c1 Point2 c2 { this mask = mask 0 = c0 0 = c0 1 = c1 1 = c1 2 = c2 2 = c2 } Node x0 y0 { this mask = 0 0 = x0 0 = y0 1 = x0 1 = y0 2 = x0 2 = y0 } Node mask x0 y0 x1 y1 x2 y2 { this mask = mask 0 = x0 0 = y0 1 = x1 1 = y1 2 = x2 2 = y2 } get Mask { mask } set Mask new Value { mask = new Value } set Control Point index Point2 { index = index = } Point2 get Control Point index { new Point2 index index } move To Point2 { move By - 0 - 0 } move To { move By - this 0 - this 0 } move By dx dy { for i=0 < 3 i++ { += dx += dy } } Object clone { try { Node that = Node super clone that = this clone that = this clone that } catch Clone Not Supported Exception { Internal Error error = new Internal Error error init Cause error } } String to String { String Builder buf = new String Builder buf append ' ' for i=0 < 3 i++ { if != 0 { if mask == { buf append ' ' } else { continue } } buf append 'x' buf append buf append '=' buf append buf append buf append buf append '=' buf append } buf append ' ' buf to String } } Bezier Path { } add Point2 c0 { add new Node 0 c0 c0 c0 } add Point { add new Node 0 } add mask Point2 c0 Point2 c1 Point2 c2 { add new Node mask c0 c1 c2 } set index coord Point2 { Node = get index coord = coord = } Point2 get index coord { Node = get index new Point2 coord coord } invalidate Path { general Path = outer = -1 } validate Path { if general Path == { general Path = to General Path } } General Path to General Path { General Path gp = new General Path gp set Winding Rule General Path WIND_EVEN_ODD if size == 0 { gp move To 0 0 gp line To 0 0 + 1 } else if size == 1 { Node current = get 0 gp move To float current 0 float current 0 gp line To float current 0 float current 0 + 1 } else { Node previous Node current previous = current = get 0 gp move To float current 0 float current 0 for i=1 = size < i++ { previous = current current = get if previous mask C2_MASK == 0 { if current mask C1_MASK == 0 { gp line To float current 0 float current 0 } else { gp quad To float current 1 float current 1 float current 0 float current 0 } } else { if current mask C1_MASK == 0 { gp quad To float previous 2 float previous 2 float current 0 float current 0 } else { gp curve To float previous 2 float previous 2 float current 1 float current 1 float current 0 float current 0 } } } if Closed { if size > 1 { previous = get size - 1 current = get 0 if previous mask C2_MASK == 0 { if current mask C1_MASK == 0 { gp line To float current 0 float current 0 } else { gp quad To float current 1 float current 1 float current 0 float current 0 } } else { if current mask C1_MASK == 0 { gp quad To float previous 2 float previous 2 float current 0 float current 0 } else { gp curve To float previous 2 float previous 2 float current 1 float current 1 float current 0 float current 0 } } } gp close Path } } gp } contains Point2 { validate Path general Path contains } outline Contains Point2 tolerance { validate Path Path Iterator = general Path get Path Iterator new Affine Transform tolerance coords = new 6 type = current Segment coords prev X = coords 0 prev Y = coords 1 next while ! Done { current Segment coords if Geom line Contains Point prev X prev Y coords 0 coords 1 tolerance { } prev X = coords 0 prev Y = coords 1 next } } intersects Rectangle2 { validate Path general Path intersects } Path Iterator get Path Iterator Affine Transform { validate Path general Path get Path Iterator } contains Rectangle2 { validate Path general Path contains } Path Iterator get Path Iterator Affine Transform flatness { validate Path general Path get Path Iterator flatness } intersects { validate Path general Path intersects } Rectangle2 get Bounds2 { validate Path general Path get Bounds2 } Rectangle2 get Bounds2 { validate Path Rectangle2 = general Path get Bounds2 if instanceof Rectangle2 { Rectangle2 } else { new Rectangle2 get X get Y get Width get Height } } Rectangle get Bounds { validate Path general Path get Bounds } contains { validate Path general Path contains } contains { validate Path general Path contains } set Closed new Value { if Closed != new Value { Closed = new Value invalidate Path } } Closed { Closed } Object clone { Bezier Path that = Bezier Path super clone for i=0 = this size < i++ { that set Node this get clone } that } transform Affine Transform tx { Point2 = new Point2 for Node cp this { for i=0 < 3 i++ { = cp = cp tx transform cp = cp = } } invalidate Path } set To Bezier Path that { while that size < size { remove size - 1 } for i=0 = size < i++ { get set To that get } while size < that size { add Node that get size clone } } Point2 get Center { sx = 0 = 0 for Node this { sx += 0 += 0 } = size new Point2 sx / / } Point2 chop Point2 { validate Path Geom chop general Path } index Of Outermost Node { if outer == -1 { Point2 ctr = get Center outer = 0 dist = 0 for = 0 = size < i++ { Node cp = get = Geom length2 ctr ctr cp 0 cp 0 if > dist { dist = outer = } } } outer } Point2 get Point On Path relative flatness { if size == 0 { } else if size == 1 { get 0 get Control Point 0 } if relative <= 0 { get 0 get Control Point 0 } else if relative >= 1 { get size - 1 get Control Point 0 } validate Path len = 0 Path Iterator = general Path get Path Iterator new Affine Transform flatness coords = new 6 type = current Segment coords prev X = coords 0 prev Y = coords 1 next for ! Done next { current Segment coords len += Geom length prev X prev Y coords 0 coords 1 prev X = coords 0 prev Y = coords 1 } relative Len = len * relative pos = 0 = general Path get Path Iterator new Affine Transform flatness type = current Segment coords prev X = coords 0 prev Y = coords 1 next for ! Done next { current Segment coords seg Len = Geom length prev X prev Y coords 0 coords 1 if pos + seg Len >= relative Len { factor = relative Len - pos / seg Len new Point2 prev X * 1 - factor + coords 0 * factor prev Y * 1 - factor + coords 1 * factor } pos += seg Len prev X = coords 0 prev Y = coords 1 } new Internal Error We should never get here } find Segment Point2 find float tolerance { Node v1 v2 Bezier Path temp Path = new Bezier Path Node t1 t2 temp Path add t1 = new Node temp Path add t2 = new Node for = 0 = size -1 < i++ { v1 = get v2 = get i+1 if v1 mask == 0 v2 mask == 0 { if Geom line Contains Point v1 0 v1 0 v2 0 v2 0 find find tolerance { } } else { t1 set To v1 t2 set To v2 temp Path invalidate Path if temp Path outline Contains find tolerance { } } } if Closed size > 1 { v1 = get size - 1 v2 = get 0 if v1 mask == 0 v2 mask == 0 { if Geom line Contains Point v1 0 v1 0 v2 0 v2 0 find find tolerance { size - 1 } } else { t1 set To v1 t2 set To v2 temp Path invalidate Path if temp Path outline Contains find tolerance { size - 1 } } } -1 } join Segments Point2 join float tolerance { for i=0 < size i++ { Node = get if Geom length 0 0 join join < tolerance { remove } } -1 } split Segment Point2 split float tolerance { = find Segment split tolerance next I = + 1 % size if != -1 { if get mask C2_MASK == C2_MASK get next I mask C1_MASK == 0 { add + 1 new Node C2_MASK split split split } else if get mask C2_MASK == 0 get next I mask C1_MASK == C1_MASK { add + 1 new Node C2_MASK split split split } else if get mask C2_MASK == C2_MASK get next I mask C1_MASK == C2_MASK { add + 1 new Node C1_MASK | C2_MASK split split split } else { add + 1 new Node split } } i+1 } move To x1 y1 { if size != 0 { new Illegal Path State Exception move To only allowed when empty } add new Node x1 y1 } line To x1 y1 { if size == 0 { new Illegal Path State Exception line To only allowed when not empty } add new Node x1 y1 } quad To x1 y1 x2 y2 { if size == 0 { new Illegal Path State Exception quad To only allowed when not empty } add new Node C1_MASK x2 y2 x1 y1 x2 y2 } curve To x1 y1 x2 y2 x3 y3 { if size == 0 { new Illegal Path State Exception curve To only allowed when not empty } Node last Point = get size - 1 last Point mask |= C2_MASK last Point 2 = x1 last Point 2 = y1 add new Node C1_MASK x3 y3 x2 y2 x3 y3 } Point2 to Polygon Array { Point2 points = new Point2 size for i=0 = size < i++ { points = new Point2 get 0 get 0 } points } } 