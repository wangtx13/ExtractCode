org jhotdraw geom import awt * import awt geom * Geom { private Geom {} line Contains Point x1 y1 x2 y2 px py { line Contains Point x1 y1 x2 y2 px py 3d } line Contains Point x1 y1 x2 y2 px py tolerance { Rectangle = new Rectangle new Point x1 y1 add x2 y2 grow Math max 2 Math ceil tolerance Math max 2 Math ceil tolerance if ! contains px py { } if x1 == x2 { Math px - x1 <= tolerance } if y1 == y2 { Math py - y1 <= tolerance } = y1 - y2 / x1 - x2 = y1 - * x1 = py - / = * px + Math min Math - px Math - py <= tolerance } line Contains Point x1 y1 x2 y2 px py tolerance { Rectangle2 = new Rectangle2 x1 y1 0 0 add x2 y2 grow = Math max 2 Math ceil tolerance -= grow -= grow width += grow * 2 height += grow * 2 if ! contains px py { } if x1 == x2 { Math px - x1 <= tolerance } if y1 == y2 { Math py - y1 <= tolerance } = y1 - y2 / x1 - x2 = y1 - * x1 = py - / = * px + Math min Math - px Math - py <= tolerance } OUT_TOP = Rectangle2 OUT_TOP OUT_BOTTOM = Rectangle2 OUT_BOTTOM OUT_LEFT = Rectangle2 OUT_LEFT OUT_RIGHT = Rectangle2 OUT_RIGHT direction x1 y1 x2 y2 { direction = 0 vx = x2 - x1 vy = y2 - y1 if vy < vx vx > -vy { direction = OUT_RIGHT } else if vy > vx vy > -vx { direction = OUT_TOP } else if vx < vy vx < -vy { direction = OUT_LEFT } else { direction = OUT_BOTTOM } direction } direction x1 y1 x2 y2 { direction = 0 vx = x2 - x1 vy = y2 - y1 if vy < vx vx > -vy { direction = OUT_RIGHT } else if vy > vx vy > -vx { direction = OUT_TOP } else if vx < vy vx < -vy { direction = OUT_LEFT } else { direction = OUT_BOTTOM } direction } outcode Rectangle r1 Rectangle r2 { outcode = 0 if r2 > r1 + r1 width outcode = OUT_RIGHT else if r2 + r2 width < r1 outcode = OUT_LEFT if r2 > r1 + r1 height outcode |= OUT_BOTTOM else if r2 + r2 height < r1 outcode |= OUT_TOP outcode } outcode Rectangle2 r1 Rectangle2 r2 { outcode = 0 if r2 > r1 + r1 width outcode = OUT_RIGHT else if r2 + r2 width < r1 outcode = OUT_LEFT if r2 > r1 + r1 height outcode |= OUT_BOTTOM else if r2 + r2 height < r1 outcode |= OUT_TOP outcode } Point south Rectangle { new Point + width /2 + height } Point2 south Rectangle2 { new Point2 + width /2 + height } Point center Rectangle { new Point + width /2 + height/2 } Point2 center Rectangle2 { new Point2 + width /2 + height/2 } Point2 chop Shape shape Point2 { Rectangle2 bounds = shape get Bounds2 Point2 ctr = new Point2 bounds get Center X bounds get Center Y cx = -1 cy = -1 len = MAX_VALUE Path Iterator = shape get Path Iterator new Affine Transform 1 coords = new 6 type = current Segment coords prev X = coords 0 prev Y = coords 1 move To X = prev X move To Y = prev Y next for ! Done next { switch current Segment coords { case Path Iterator SEG_MOVETO move To X = coords 0 move To Y = coords 1 break case Path Iterator SEG_CLOSE coords 0 = move To X coords 1 = move To Y break } Point2 chop = Geom intersect prev X prev Y coords 0 coords 1 ctr ctr if chop != { = Geom length2 chop chop if < len { len = cx = chop cy = chop } } prev X = coords 0 prev Y = coords 1 } if len == MAX_VALUE { = shape get Path Iterator new Affine Transform 1 for ! Done next { current Segment coords = Geom length2 ctr ctr coords 0 coords 1 if < len { len = cx = coords 0 cy = coords 1 } } } new Point2 cx cy } Point west Rectangle { new Point + height/ 2 } Point2 west Rectangle2 { new Point2 + height/ 2 } Point east Rectangle { new Point x+r width + height/ 2 } Point2 east Rectangle2 { new Point2 x+r width + height/ 2 } Point north Rectangle { new Point x+r width/2 } Point2 north Rectangle2 { new Point2 x+r width/2 } range min max value { if value < min { value = min } if value > max { value = max } value } range min max value { if value < min { value = min } if value > max { value = max } value } long length2 x1 y1 x2 y2 { x2-x1 * x2-x1 + y2-y1 * y2-y1 } long length x1 y1 x2 y2 { long Math sqrt length2 x1 y1 x2 y2 } length2 x1 y1 x2 y2 { x2-x1 * x2-x1 + y2-y1 * y2-y1 } length x1 y1 x2 y2 { Math sqrt length2 x1 y1 x2 y2 } length Point2 p1 Point2 p2 { Math sqrt length2 p1 p1 p2 p2 } Point2 cap Point2 p1 Point2 p2 radius { angle = Math P I/2 - Math atan2 p2 - p1 p2 - p1 Point2 p3 = new Point2 p2 + radius * Math cos angle p2 + radius * Math sin angle p3 } point To Angle Rectangle Point { px = - + width/2 py = - + height/2 Math atan2 py*r width px*r height } point To Angle Rectangle2 Point2 { px = - + width/2 py = - + height/2 Math atan2 py*r width px*r height } angle x1 y1 x2 y2 { Math atan2 y2 - y1 x2 - x1 } Point angle To Point Rectangle angle { = Math sin angle = Math cos angle = 0 0001 x= 0 y= 0 if Math > { x= 1 0 + co/ Math /2 0 * width x= range 0 width } else if >= 0 0 { x= width } if Math > { y= 1 0 + si/ Math /2 0 * height y= range 0 height } else if >= 0 0 { y= height } new Point + + } Point2 angle To Point Rectangle2 angle { = Math sin angle = Math cos angle = 0 0001 x= 0 = 0 if Math > { x= 1 0 + co/ Math /2 0 * width = range 0 width } else if >= 0 0 { = width } if Math > { = 1 0 + si/ Math /2 0 * height = range 0 height } else if >= 0 0 { = height } new Point2 + + } Point polar To Point angle fx fy { = Math sin angle = Math cos angle new Point fx*co+0 5 fy*si+0 5 } Point2 polar To Point2 angle fx fy { = Math sin angle = Math cos angle new Point2 fx*co+0 5 fy*si+0 5 } Point oval Angle To Point Rectangle angle { Point center = Geom center Point = Geom polar To Point angle width/2 height/2 new Point center + center + } Point2 oval Angle To Point Rectangle2 angle { Point2 center = Geom center Point2 = Geom polar To Point2 angle width/2 height/2 new Point2 center + center + } Point intersect xa ya xb yb yc xd yd { denom = xb - xa * yd - yc - yb - ya * xd - rnum = ya - yc * xd - - xa - * yd - yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < || xb < xd || xa > xb xb > || xb > xd { new Point xb yb } else { new Point xa ya } } else { } } = rnum / denom snum = ya - yc * xb - xa - xa - * yb - ya = snum / denom if 0 0 <= <= 1 0 0 0 <= <= 1 0 { px = xa + xb - xa * py = ya + yb - ya * new Point px py } else { } } Point2 intersect xa ya xb yb yc xd yd { denom = xb - xa * yd - yc - yb - ya * xd - rnum = ya - yc * xd - - xa - * yd - yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < || xb < xd || xa > xb xb > || xb > xd { new Point2 xb yb } else { new Point2 xa ya } } else { } } = rnum / denom snum = ya - yc * xb - xa - xa - * yb - ya = snum / denom if 0 0 <= <= 1 0 0 0 <= <= 1 0 { px = xa + xb - xa * py = ya + yb - ya * new Point2 px py } else { } } Point2 intersect xa ya xb yb yc xd yd limit { denom = xb - xa * yd - yc - yb - ya * xd - rnum = ya - yc * xd - - xa - * yd - yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < || xb < xd || xa > xb xb > || xb > xd { new Point2 xb yb } else { new Point2 xa ya } } else { } } = rnum / denom snum = ya - yc * xb - xa - xa - * yb - ya = snum / denom if 0 0 <= <= 1 0 0 0 <= <= 1 0 { px = xa + xb - xa * py = ya + yb - ya * new Point2 px py } else { px = xa + xb - xa * py = ya + yb - ya * if length xa ya px py <= limit || length xb yb px py <= limit || length yc px py <= limit || length xd yd px py <= limit { new Point2 px py } } } distance From Line xa ya xb yb yc { xdiff = xb - xa ydiff = yb - ya long l2 = xdiff * xdiff + ydiff * ydiff if l2 == 0 { Geom length xa ya yc } rnum = ya - yc * ya - yb - xa - * xb - xa = rnum / l2 if < 0 0 || > 1 0 { MAX_VALUE } xi = xa + * xdiff yi = ya + * ydiff xd = - xi yd = yc - yi Math sqrt xd * xd + yd * yd } grow Rectangle2 { -= -= width += * 2d height += * 2d } } 