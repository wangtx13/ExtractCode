net n3 nanoxml import io input stream import io input stream reader import io i o import io import io input stream import io not found import io line number reader import io pushback reader import io pushback input stream import io reader import io reader import io unsupported encoding import net malformed u r l import net u r l import util stack std xml reader implements i xml reader { private stacked reader { pushback reader pb reader line number reader line reader u r l } private stack readers private stacked reader current reader i xml reader reader str { new std xml reader new reader str } i xml reader reader filename not found i o { std xml reader r = new std xml reader new input stream filename r set systemid filename for i = 0 i < r readers size i++ { stacked reader sr = stacked reader r readers element at i sr = r current reader } r } std xml reader publicid systemid malformed u r l not found i o { u r l systemidas u r l = try { systemidas u r l = new u r l systemid } catch malformed u r l e { systemid = + systemid try { systemidas u r l = new u r l systemid } catch malformed u r l e2 { throw e } } this current reader = new stacked reader this readers = new stack reader reader = this open stream publicid systemidas u r l to this current reader line reader = new line number reader reader this current reader pb reader = new pushback reader this current reader line reader 2 } std xml reader reader reader { this current reader = new stacked reader this readers = new stack this current reader line reader = new line number reader reader this current reader pb reader = new pushback reader this current reader line reader 2 this current reader = try { this current reader = new u r l } catch malformed u r l e { } } finalize throwable { this current reader line reader = this current reader pb reader = this current reader = this current reader = this current reader = this readers clear super finalize } get encoding str { if ! str starts with <?xml { } index = 5 while index < str length { buffer key = new buffer while index < str length str char at index <= ' ' { index++ } while index < str length str char at index >= 'a' str char at index <= 'z' { key append str char at index index++ } while index < str length str char at index <= ' ' { index++ } if index >= str length || str char at index != '=' { break } while index < str length str char at index != '\'' str char at index != ' ' { index++ } if index >= str length { break } char delimiter = str char at index index++ index2 = str index of delimiter index if index2 < 0 { break } if key to equals encoding { str substring index index2 } index = index2 + 1 } } reader stream2reader input stream stream buffer chars read i o { pushback input stream pbstream = new pushback input stream stream b = pbstream read switch b { case 0x00 case 0x f e case 0x f f pbstream unread b new input stream reader pbstream u t f 16 case 0x e f for i = 0 i < 2 i++ { pbstream read } new input stream reader pbstream u t f 8 case 0x3 c b = pbstream read chars read append '<' while b > 0 b != 0x3 e { chars read append char b b = pbstream read } if b > 0 { chars read append char b } encoding = this get encoding chars read to if encoding == { new input stream reader pbstream u t f 8 } chars read set length 0 try { new input stream reader pbstream encoding } catch unsupported encoding e { new input stream reader pbstream u t f 8 } default chars read append char b new input stream reader pbstream u t f 8 } } std xml reader input stream stream i o { pushback input stream pbstream = new pushback input stream stream buffer chars read = new buffer reader reader = this stream2reader stream chars read this current reader = new stacked reader this readers = new stack this current reader line reader = new line number reader reader this current reader pb reader = new pushback reader this current reader line reader 2 this current reader = try { this current reader = new u r l } catch malformed u r l e { } this start new stream new reader chars read to } char read i o { ch = this current reader pb reader read while ch < 0 { if this readers empty { throw new i o unexpected e o f } this current reader pb reader close this current reader = stacked reader this readers pop ch = this current reader pb reader read } char ch } at e o f of current stream i o { ch = this current reader pb reader read if ch < 0 { } else { this current reader pb reader unread ch } } at e o f i o { ch = this current reader pb reader read while ch < 0 { if this readers empty { } this current reader pb reader close this current reader = stacked reader this readers pop ch = this current reader pb reader read } this current reader pb reader unread ch } unread char ch i o { this current reader pb reader unread ch } reader open stream publicid systemid malformed u r l not found i o { u r l url = new u r l this current reader systemid if url get ref != { ref = url get ref if url get length > 0 { url = new u r l url get protocol url get host url get port url get url = new u r l jar + url + '!' + ref } else { url = std xml reader get resource ref } } this current reader = publicid this current reader = url buffer chars read = new buffer reader reader = this stream2reader url open stream chars read if chars read length == 0 { reader } chars read str = chars read to pushback reader pbreader = new pushback reader reader chars read str length for i = chars read str length 1 i >= 0 i { pbreader unread chars read str char at i } pbreader } start new stream reader reader { this start new stream reader } start new stream reader reader is internal entity { stacked reader old reader = this current reader this readers push this current reader this current reader = new stacked reader if is internal entity { this current reader line reader = this current reader pb reader = new pushback reader reader 2 } else { this current reader line reader = new line number reader reader this current reader pb reader = new pushback reader this current reader line reader 2 } this current reader = old reader this current reader = old reader } get stream level { this readers size } get line nr { if this current reader line reader == { stacked reader sr = stacked reader this readers peek if sr line reader == { 0 } else { sr line reader get line number + 1 } } this current reader line reader get line number + 1 } set systemid systemid malformed u r l { this current reader = new u r l this current reader systemid } set publicid publicid { this current reader = publicid } get systemid { this current reader to } get publicid { this current reader } } 