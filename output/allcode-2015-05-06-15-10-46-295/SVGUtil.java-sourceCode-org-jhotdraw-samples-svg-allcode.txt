org jhotdraw samples svg import awt color import awt geom * import io * import util * import javax swing * import org jhotdraw draw * import org jhotdraw geom * import org jhotdraw samples svg figures * import org jhotdraw xml * import org jhotdraw draw attribute keys * s v g util { private color INHERIT_COLOR = new color 0xffff00 private color CURRENT_COLOR = new color 0xffff00 map< color> SVG_COLORS { linked hash map< color> map = new linked hash map< color> map put black new color 0 0 0 map put green new color 0 128 0 map put silver new color 192 192 192 map put lime new color 0 255 0 map put gray new color 128 128 128 map put olive new color 128 128 0 map put white new color 255 255 255 map put yellow new color 255 255 0 map put maroon new color 128 0 0 map put navy new color 0 0 128 map put red new color 255 0 0 map put blue new color 0 0 255 map put purple new color 128 0 128 map put teal new color 0 128 128 map put fuchsia new color 255 0 255 map put aqua new color 0 255 255 map put aliceblue new color 240 248 255 map put antiquewhite new color 250 235 215 map put aqua new color 0 255 255 map put aquamarine new color 127 255 212 map put azure new color 240 255 255 map put beige new color 245 245 220 map put bisque new color 255 228 196 map put black new color 0 0 0 map put blanchedalmond new color 255 235 205 map put blue new color 0 0 255 map put blueviolet new color 138 43 226 map put brown new color 165 42 42 map put burlywood new color 222 184 135 map put cadetblue new color 95 158 160 map put chartreuse new color 127 255 0 map put chocolate new color 210 105 30 map put coral new color 255 127 80 map put cornflowerblue new color 100 149 237 map put cornsilk new color 255 248 220 map put crimson new color 220 20 60 map put cyan new color 0 255 255 map put darkblue new color 0 0 139 map put darkcyan new color 0 139 139 map put darkgoldenrod new color 184 134 11 map put darkgray new color 169 169 169 map put darkgreen new color 0 100 0 map put darkgrey new color 169 169 169 map put darkkhaki new color 189 183 107 map put darkmagenta new color 139 0 139 map put darkolivegreen new color 85 107 47 map put darkorange new color 255 140 0 map put darkorchid new color 153 50 204 map put darkred new color 139 0 0 map put darksalmon new color 233 150 122 map put darkseagreen new color 143 188 143 map put darkslateblue new color 72 61 139 map put darkslategray new color 47 79 79 map put darkslategrey new color 47 79 79 map put darkturquoise new color 0 206 209 map put darkviolet new color 148 0 211 map put deeppink new color 255 20 147 map put deepskyblue new color 0 191 255 map put dimgray new color 105 105 105 map put dimgrey new color 105 105 105 map put dodgerblue new color 30 144 255 map put firebrick new color 178 34 34 map put floralwhite new color 255 250 240 map put forestgreen new color 34 139 34 map put fuchsia new color 255 0 255 map put gainsboro new color 220 220 220 map put ghostwhite new color 248 248 255 map put gold new color 255 215 0 map put goldenrod new color 218 165 32 map put gray new color 128 128 128 map put grey new color 128 128 128 map put green new color 0 128 0 map put greenyellow new color 173 255 47 map put honeydew new color 240 255 240 map put hotpink new color 255 105 180 map put indianred new color 205 92 92 map put indigo new color 75 0 130 map put ivory new color 255 255 240 map put khaki new color 240 230 140 map put lavender new color 230 230 250 map put lavenderblush new color 255 240 245 map put lawngreen new color 124 252 0 map put lemonchiffon new color 255 250 205 map put lightblue new color 173 216 230 map put lightcoral new color 240 128 128 map put lightcyan new color 224 255 255 map put lightgoldenrodyellow new color 250 250 210 map put lightgray new color 211 211 211 map put lightgreen new color 144 238 144 map put lightgrey new color 211 211 211 map put lightpink new color 255 182 193 map put lightsalmon new color 255 160 122 map put lightseagreen new color 32 178 170 map put lightskyblue new color 135 206 250 map put lightslategray new color 119 136 153 map put lightslategrey new color 119 136 153 map put lightsteelblue new color 176 196 222 map put lightyellow new color 255 255 224 map put lime new color 0 255 0 map put limegreen new color 50 205 50 map put linen new color 250 240 230 map put magenta new color 255 0 255 map put maroon new color 128 0 0 map put mediumaquamarine new color 102 205 170 map put mediumblue new color 0 0 205 map put mediumorchid new color 186 85 211 map put mediumpurple new color 147 112 219 map put mediumseagreen new color 60 179 113 map put mediumslateblue new color 123 104 238 map put mediumspringgreen new color 0 250 154 map put mediumturquoise new color 72 209 204 map put mediumvioletred new color 199 21 133 map put midnightblue new color 25 25 112 map put mintcream new color 245 255 250 map put mistyrose new color 255 228 225 map put moccasin new color 255 228 181 map put navajowhite new color 255 222 173 map put navy new color 0 0 128 map put oldlace new color 253 245 230 map put olive new color 128 128 0 map put olivedrab new color 107 142 35 map put orange new color 255 165 0 map put orangered new color 255 69 0 map put orchid new color 218 112 214 map put palegoldenrod new color 238 232 170 map put palegreen new color 152 251 152 map put paleturquoise new color 175 238 238 map put palevioletred new color 219 112 147 map put papayawhip new color 255 239 213 map put peachpuff new color 255 218 185 map put peru new color 205 133 63 map put pink new color 255 192 203 map put plum new color 221 160 221 map put powderblue new color 176 224 230 map put purple new color 128 0 128 map put red new color 255 0 0 map put rosybrown new color 188 143 143 map put royalblue new color 65 105 225 map put saddlebrown new color 139 69 19 map put salmon new color 250 128 114 map put sandybrown new color 244 164 96 map put seagreen new color 46 139 87 map put seashell new color 255 245 238 map put sienna new color 160 82 45 map put silver new color 192 192 192 map put skyblue new color 135 206 235 map put slateblue new color 106 90 205 map put slategray new color 112 128 144 map put slategrey new color 112 128 144 map put snow new color 255 250 250 map put springgreen new color 0 255 127 map put steelblue new color 70 130 180 map put tan new color 210 180 140 map put teal new color 0 128 128 map put thistle new color 216 191 216 map put tomato new color 255 99 71 map put turquoise new color 64 224 208 map put violet new color 238 130 238 map put wheat new color 245 222 179 map put white new color 255 255 255 map put whitesmoke new color 245 245 245 map put yellow new color 255 255 0 map put yellowgreen new color 154 205 50 map put activeborder u i manager get color active caption border map put activecaption u i manager get color active caption map put appworkspace u i manager get color window map put background u i manager get color desktop map put buttonface u i manager get color control map put buttonhighlight u i manager get color control highlight map put buttonshadow u i manager get color control shadow map put buttontext u i manager get color control text map put captiontext u i manager get color active caption text map put graytext u i manager get color text inactive text map put highlight u i manager get color text highlight map put highlighttext u i manager get color text highlight text map put inactiveborder u i manager get color inactive caption border map put inactivecaption u i manager get color inactive caption map put inactivecaptiontext u i manager get color inactive caption text map put infobackground u i manager get color info map put infotext u i manager get color info text map put menu u i manager get color menu map put menutext u i manager get color menu text map put scrollbar u i manager get color scrollbar map put threeddarkshadow u i manager get color control dk shadow map put threedface u i manager get color control map put threedhighlight u i manager get color control highlight map put threedlightshadow u i manager get color control lt highlight map put threedshadow u i manager get color control shadow map put window u i manager get color window map put windowframe u i manager get color window border map put windowtext u i manager get color window text SVG_COLORS = map } private s v g util { } affine transform get transform dom input in attribute name i o { get transform in get attribute attribute name } affine transform get transform str i o { affine transform t = new affine transform if str != { stream tokenizer tt = new stream tokenizer new reader str tt reset syntax tt word chars 'a' 'z' tt word chars ' a' ' z' tt word chars 128 + 32 255 tt whitespace chars 0 ' ' tt whitespace chars ' ' ' ' tt parse numbers while tt next token != stream tokenizer TT_EOF { if tt ttype != stream tokenizer TT_WORD { throw new i o illegal transform +str } type = tt sval if tt next token != ' ' { throw new i o ' ' not found in transform +str } if type equals matrix { m = new 6 for i=0 i < 6 i++ { if tt next token != stream tokenizer TT_NUMBER { throw new i o matrix value +i+ not found in transform +str+ token +tt ttype+ +tt sval } if tt next token == stream tokenizer TT_WORD tt sval starts with e { mantissa = tt nval tt nval = value of tt nval + tt sval } else { tt push back } m i = tt nval } t concatenate new affine transform m } else if type equals translate { tx ty if tt next token != stream tokenizer TT_NUMBER { throw new i o x translation value not found in transform +str } tx = tt nval if tt next token == stream tokenizer TT_NUMBER { ty = tt nval } else { tt push back ty = 0 } t translate tx ty } else if type equals scale { sx sy if tt next token != stream tokenizer TT_NUMBER { throw new i o x scale value not found in transform +str } sx = tt nval if tt next token == stream tokenizer TT_NUMBER { sy = tt nval } else { tt push back sy = sx } t scale sx sy } else if type equals rotate { angle cx cy if tt next token != stream tokenizer TT_NUMBER { throw new i o angle value not found in transform +str } angle = tt nval if tt next token == stream tokenizer TT_NUMBER { cx = tt nval if tt next token != stream tokenizer TT_NUMBER { throw new i o y center value not found in transform +str } cy = tt nval } else { tt push back cx = cy = 0 } t rotate angle * math p i / 180d cx * math p i / 180d cy * math p i / 180d } else if type equals skew x { angle if tt next token != stream tokenizer TT_NUMBER { throw new i o skew angle not found in transform +str } angle = tt nval t concatenate new affine transform 1 0 math tan angle * math p i / 180 1 0 0 } else if type equals skew y { angle if tt next token != stream tokenizer TT_NUMBER { throw new i o skew angle not found in transform +str } angle = tt nval t concatenate new affine transform 1 math tan angle * math p i / 180 0 1 0 0 }else { throw new i o unknown transform +type+ in +str } if tt next token != ' ' { throw new i o ' ' not found in transform +str } } } t } get dimension dom input in attribute name i o { get dimension value in in get attribute attribute name 0 } get dimension value dom input in str i o { scale factor = 1d if str == || str length == 0 { 0d } if str ends with % { str = str substring 0 str length 1 } else if str ends with px { str = str substring 0 str length 2 } else if str ends with pt { str = str substring 0 str length 2 scale factor = 1 25 } else if str ends with pc { str = str substring 0 str length 2 scale factor = 15 } else if str ends with mm { str = str substring 0 str length 2 scale factor = 3 543307 } else if str ends with cm { str = str substring 0 str length 2 scale factor = 35 43307 } else if str ends with in { str = str substring 0 str length 2 scale factor = 90 } else if str ends with em { str = str substring 0 str length 2 list< map< string>> styles = new list< map< string>> list< string> values = in get inherited attribute style for v values { styles add get styles v } value = get inherited attribute font size in styles if value != ! value ends with em { scale factor = get dimension value in value } } parse str * scale factor } list< bezier path> get path dom input in attribute name i o { from path data in get attribute attribute name } set path dom output out attribute name bezier path path { out add attribute attribute name to path data path } to path data bezier path path { builder buf = new builder if path size == 0 { } else if path size == 1 { bezier path node current = path get 0 buf append m buf append current x 0 buf append ' ' buf append current y 0 buf append l buf append current x 0 buf append ' ' buf append current y 0 + 1 } else { bezier path node previous bezier path node current previous = current = path get 0 buf append m buf append current x 0 buf append ' ' buf append current y 0 for i=1 n = path size i < n i++ { previous = current current = path get i if previous mask bezier path C2_MASK == 0 { if current mask bezier path C1_MASK == 0 { buf append l buf append current x 0 buf append ' ' buf append current y 0 } else { buf append q buf append current x 1 buf append ' ' buf append current y 1 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } } else { if current mask bezier path C1_MASK == 0 { buf append q buf append current x 2 buf append ' ' buf append current y 2 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } else { buf append c buf append previous x 2 buf append ' ' buf append previous y 2 buf append ' ' buf append current x 1 buf append ' ' buf append current y 1 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } } } if path is closed { if path size > 1 { previous = path get path size 1 current = path get 0 if previous mask bezier path C2_MASK == 0 { if current mask bezier path C1_MASK == 0 { buf append l buf append current x 0 buf append ' ' buf append current y 0 } else { buf append q buf append current x 1 buf append ' ' buf append current y 1 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } } else { if current mask bezier path C1_MASK == 0 { buf append q buf append previous x 2 buf append ' ' buf append previous y 2 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } else { buf append c buf append previous x 2 buf append ' ' buf append previous y 2 buf append ' ' buf append current x 1 buf append ' ' buf append current y 1 buf append ' ' buf append current x 0 buf append ' ' buf append current y 0 } } } buf append z } } buf to } private hash set path commands = new hash set arrays as list new { m m z z l l h h v v c c s s q q t t } list< bezier path> from path data str i o { linked list< bezier path> paths = new linked list< bezier path> bezier path path = point2 d p = new point2 d point2 d c1 = new point2 d point2 d c2 = new point2 d stream tokenizer tt = new stream tokenizer new reader str tt reset syntax tt parse numbers tt whitespace chars 0 ' ' tt whitespace chars ' ' ' ' char next command = ' m' char command = ' m' while tt next token != stream tokenizer TT_EOF { if tt ttype > 0 { command = char tt ttype } else { command = next command tt push back } bezier path node node switch command { case ' m' if path != { paths add path } path = new bezier path if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y = tt nval path move to p x p y next command = ' l' break case 'm' if path != { paths add path } path = new bezier path if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x += tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y += tt nval path move to p x p y next command = 'l' break case ' z' case 'z' p x = path get 0 x 0 p y = path get 0 y 0 path set closed break case ' l' if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y = tt nval path line to p x p y next command = ' l' break case 'l' if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x += tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y += tt nval path line to p x p y next command = 'l' break case ' h' if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x = tt nval path line to p x p y next command = ' h' break case 'h' if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x += tt nval path line to p x p y next command = 'h' break case ' v' if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y = tt nval path line to p x p y next command = ' v' break case 'v' if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y += tt nval path line to p x p y next command = 'v' break case ' c' if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c1 x = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c1 y = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c2 x = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c2 y = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y = tt nval path curve to c1 x c1 y c2 x c2 y p x p y next command = ' c' break case 'c' if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c1 x = p x + tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c1 y = p y + tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c2 x = p x + tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c2 y = p y + tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x += tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y += tt nval path curve to c1 x c1 y c2 x c2 y p x p y next command = 'c' break case ' s' node = path get path size 1 c1 x = node x 0 * 2d node x 1 c1 y = node y 0 * 2d node y 1 if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c2 x = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c2 y = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y = tt nval path curve to c1 x c1 y c2 x c2 y p x p y next command = ' s' break case 's' node = path get path size 1 c1 x = node x 0 * 2d node x 1 c1 y = node y 0 * 2d node y 1 if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c2 x = p x + tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c2 y = p y + tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x += tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y += tt nval path curve to c1 x c1 y c2 x c2 y p x p y next command = 's' break case ' q' if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c1 x = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c1 y = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y = tt nval path quad to c1 x c1 y p x p y next command = ' q' break case 'q' if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c1 x = p x + tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected c1 y = p y + tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x += tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y += tt nval path quad to c1 x c1 y p x p y next command = 'q' break case ' t' node = path get path size 1 c1 x = node x 0 * 2d node x 1 c1 y = node y 0 * 2d node y 1 if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x = tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y = tt nval path quad to c1 x c1 y p x p y next command = ' t' break case 't' node = path get path size 1 c1 x = node x 0 * 2d node x 1 c1 y = node y 0 * 2d node y 1 if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p x += tt nval if tt next token != stream tokenizer TT_NUMBER throw new i o number expected p y += tt nval path quad to c1 x c1 y p x p y next command = 's' break default throw new i o illegal command +command } } if path != { paths add path } paths } get inherited attribute name dom input in list< map< string>> styles { list< string> values = in get inherited attribute name for i=values size 1 i >= 0 i { if values get i != { values get i } if styles get i != styles get i contains key name { styles get i get name } } } read attributes figure f dom input in i o { list< map< string>> styles = new list< map< string>> list< string> values = in get inherited attribute style for v values { styles add get styles v } value value = get inherited attribute fill in styles if value != { color color = get color value if color != INHERIT_COLOR color != CURRENT_COLOR { FILL_COLOR set f color } } value = get inherited attribute fill rule in styles if value != { WINDING_RULE set f value to upper case equals n o n z e r o ? winding rule NON_ZERO winding rule EVEN_ODD } else { WINDING_RULE set f winding rule NON_ZERO } value = get inherited attribute stroke in styles if value != { color color = get color value if color != INHERIT_COLOR color != CURRENT_COLOR { STROKE_COLOR set f color } } value = get inherited attribute stroke width in styles if value != { STROKE_WIDTH set f value of value } value = get inherited attribute stroke miterlimit in styles if value != { STROKE_MITER_LIMIT_FACTOR set f value of value } value = get inherited attribute stroke dasharray in styles if value != { tokenizer tt = new tokenizer value dashes = new tt count tokens for i=0 n = dashes length i < n i++ { dashes i = value of tt next token } STROKE_DASHES set f dashes } value = get inherited attribute stroke dashoffset in styles if value != { STROKE_DASH_PHASE set f math abs value of value } value = get inherited attribute font size in styles if value != { FONT_SIZE set f get dimension value in value } value = get inherited attribute text anchor in styles if value != { s v g text TEXT_ANCHOR set f enum value of s v g text text anchor value to upper case } } map< string> get styles str i o { hash map< string> styles = new hash map< string> if str == styles stream tokenizer tt = new stream tokenizer new reader str tt reset syntax tt word chars '!' '9' tt word chars '<' '~' tt word chars 128 + 32 255 tt whitespace chars 0 ' ' while tt next token != stream tokenizer TT_EOF { if tt ttype != ' ' { key value if tt ttype != stream tokenizer TT_WORD { throw new i o key token expected in +str+ + integer to hex tt ttype } key = tt sval if tt next token != ' ' { throw new i o colon expected after +key+ in +str } if tt next token != stream tokenizer TT_WORD { throw new i o value token expected after +key+ in +str+ +tt ttype } value = tt sval while tt next token == stream tokenizer TT_WORD { value += ' ' + tt sval } tt push back styles put key value } } styles } color get color value { value = value trim to lower case if value equals none { } else if value equals current color { CURRENT_COLOR } else if value equals inherit { INHERIT_COLOR } else if SVG_COLORS contains key value { SVG_COLORS get value } else if value starts with # value length == 7 { new color integer decode value } else if value starts with # value length == 4 { th = integer decode value new color th 0xf | th 0xf << 4 | th 0xf0 << 4 | th 0xf0 << 8 | th 0xf00 << 8 | th 0xf00 << 12 } else if value starts with rgb { tokenizer tt = new tokenizer value tt next token color c = new color integer decode tt next token integer decode tt next token integer decode tt next token c } else { } } set defaults figure f { FILL_COLOR set f color black STROKE_COLOR set f STROKE_DASH_FACTOR set f 1d } write attributes figure f dom output out i o { color color dbl value color = FILL_COLOR get f if color == { value = none } else { value = 000000 + integer to hex color get r g b value = # +value substring value length 6 } out add attribute fill value if WINDING_RULE get f != winding rule NON_ZERO { out add attribute fill rule evenodd } color = STROKE_COLOR get f if color == { value = none } else { value = 000000 + integer to hex color get r g b value = # +value substring value length 6 } out add attribute stroke value out add attribute stroke width STROKE_WIDTH get f 1d out add attribute stroke miterlimit STROKE_MITER_LIMIT_FACTOR get f / STROKE_WIDTH get f 4d dashes = STROKE_DASHES get f dbl = STROKE_DASH_FACTOR get f == ? STROKE_WIDTH get f STROKE_DASH_FACTOR get f if dashes != { builder buf = new builder for i=0 i < dashes length i++ { if i != 0 { buf append ' ' buf append dashes i * dbl } out add attribute stroke dasharray buf to } } out add attribute stroke dashoffset STROKE_DASH_PHASE get f 0d out add attribute font size FONT_SIZE get f } } 