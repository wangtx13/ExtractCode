net n3 nanoxml import io i o import io output stream import io print writer import io writer import util iterator import util vector xml writer { private print writer writer xml writer writer writer { if writer instanceof print writer { this writer = print writer writer } else { this writer = new print writer writer } } xml writer output stream stream { this writer = new print writer stream } finalize throwable { this writer = super finalize } write i xml element xml i o { this write xml 0 } write i xml element xml pretty print i o { this write xml pretty print 0 } write i xml element xml pretty print indent i o { this write xml pretty print indent } write i xml element xml pretty print indent collapse empty elements i o { if pretty print { for i = 0 i < indent i++ { this writer print ' ' } } if xml get name == { if xml get content != { if pretty print { this write encoded xml get content trim writer } else { this write encoded xml get content } } } else { this writer print '<' this writer print xml get full name vector nsprefixes = new vector if xml get namespace != { if xml get name equals xml get full name { this writer print xmlns=\ + xml get namespace + ' ' } else { prefix = xml get full name prefix = prefix substring 0 prefix index of ' ' nsprefixes add element prefix this writer print xmlns + prefix this writer print =\ + xml get namespace + \ } } iterator enm = xml iterate attribute names while enm has next { key = enm next index = key index of ' ' if index >= 0 { namespace = xml get attribute namespace key if namespace != { prefix = key substring 0 index if ! nsprefixes contains prefix { this writer print xmlns + prefix this writer print =\ + namespace + ' ' nsprefixes add element prefix } } } } enm = xml iterate attribute names while enm has next { key = enm next value = xml get attribute key this writer print + key + =\ this write encoded value this writer print ' ' } if xml get content != xml get content length > 0 { writer print '>' this write encoded xml get content writer print </ + xml get full name + '>' if pretty print { writer } } else if xml has children || ! collapse empty elements { writer print '>' if pretty print { writer } enm = xml iterate children while enm has next { i xml element child = i xml element enm next this write child pretty print indent + 4 collapse empty elements } if pretty print { for i = 0 i < indent i++ { this writer print ' ' } } this writer print </ + xml get full name + > if pretty print { writer } } else { this writer print /> if pretty print { writer } } } this writer flush } private write encoded str { for i = 0 i < str length i++ { char c = str char at i switch c { case 0x0 a this writer print c break case '<' this writer print lt break case '>' this writer print break case ' ' this writer print amp break case '\'' this writer print apos break case ' ' this writer print break default if c < ' ' || c > 0x7 e { this writer print #x this writer print integer to c 16 this writer print ' ' } else { this writer print c } } } } } 