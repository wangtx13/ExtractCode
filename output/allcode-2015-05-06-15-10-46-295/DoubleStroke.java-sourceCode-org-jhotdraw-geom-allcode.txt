org jhotdraw geom import awt * import awt geom * import awt font * stroke implements stroke { private basic stroke outline stroke private float inner width private float outline width private miter limit private float dashes private float dash phase stroke float inner width float outline width { this inner width outline width basic stroke CAP_SQUARE basic stroke JOIN_BEVEL 10f 0f } stroke float inner width float outline width cap join float miter limit float dashes float dash phase { this inner width = inner width this outline width = outline width this miter limit = miter limit outline stroke = new basic stroke outline width cap basic stroke JOIN_BEVEL miter limit dashes dash phase } shape create stroked shape shape s { bezier path bp = new bezier path general path left = new general path general path right = new general path coords = new 6 for path iterator i = s get path iterator 0 1d ! i is done i next { type = i current segment coords switch type { case path iterator SEG_MOVETO if bp size != 0 { trace stroke bp left right } bp clear bp set closed bp move to coords 0 coords 1 break case path iterator SEG_LINETO if coords 0 != bp get bp size 1 x 0 || coords 1 != bp get bp size 1 y 0 { bp line to coords 0 coords 1 } break case path iterator SEG_QUADTO bp quad to coords 0 coords 1 coords 2 coords 3 break case path iterator SEG_CUBICTO bp curve to coords 0 coords 1 coords 2 coords 3 coords 4 coords 5 break case path iterator SEG_CLOSE bp set closed break } } if bp size != 0 { trace stroke bp left right } right append left outline stroke create stroked shape right } trace stroke bezier path bp general path left general path right { current corners = new 8 prev corners = new 8 point2 d intersect if bp is closed { bezier path node prev = bp get bp size 1 for i=0 i < bp size i++ { bezier path node node = bp get i if prev x 0 == node x 0 prev y 0 == node y 0 { bp remove i } else { prev = node } } } else { bezier path node prev = bp get 0 for i=1 i < bp size i++ { bezier path node node = bp get i if prev x 0 == node x 0 prev y 0 == node y 0 { bp remove i } else { prev = node } } } if bp is closed bp size > 1 { prev corners = compute thick line bp get bp size 1 x 0 bp get bp size 1 y 0 bp get 0 x 0 bp get 0 y 0 inner width prev corners current corners = compute thick line bp get 0 x 0 bp get 0 y 0 bp get 1 x 0 bp get 1 y 0 inner width current corners intersect = geom intersect prev corners 0 prev corners 1 prev corners 4 prev corners 5 current corners 0 current corners 1 current corners 4 current corners 5 miter limit if intersect != { right move to float intersect x float intersect y } else { right move to float prev corners 4 float prev corners 5 right line to float current corners 0 float current corners 1 } intersect = geom intersect prev corners 2 prev corners 3 prev corners 6 prev corners 7 current corners 2 current corners 3 current corners 6 current corners 7 miter limit if intersect != { left move to float intersect x float intersect y } else { left move to float prev corners 6 float prev corners 7 left line to float current corners 2 float current corners 3 } } else { if bp size > 1 { current corners = compute thick line bp get 0 x 0 bp get 0 y 0 bp get 1 x 0 bp get 1 y 0 inner width current corners right move to float current corners 0 float current corners 1 left move to float current corners 2 float current corners 3 } } for i=1 n = bp size 1 i < n i++ { tmp = prev corners prev corners = current corners current corners = compute thick line bp get i x 0 bp get i y 0 bp get i+1 x 0 bp get i+1 y 0 inner width tmp intersect = geom intersect prev corners 0 prev corners 1 prev corners 4 prev corners 5 current corners 0 current corners 1 current corners 4 current corners 5 miter limit if intersect != { right line to float intersect x float intersect y } else { right line to float prev corners 4 float prev corners 5 right line to float current corners 0 float current corners 1 } intersect = geom intersect prev corners 2 prev corners 3 prev corners 6 prev corners 7 current corners 2 current corners 3 current corners 6 current corners 7 miter limit if intersect != { left line to float intersect x float intersect y } else { left line to float prev corners 6 float prev corners 7 left line to float current corners 2 float current corners 3 } } if bp is closed { tmp = prev corners prev corners = current corners current corners = compute thick line bp get bp size 1 x 0 bp get bp size 1 y 0 bp get 0 x 0 bp get 0 y 0 inner width tmp intersect = geom intersect prev corners 0 prev corners 1 prev corners 4 prev corners 5 current corners 0 current corners 1 current corners 4 current corners 5 miter limit if intersect != { right line to float intersect x float intersect y } else { right line to float prev corners 4 float prev corners 5 right line to float current corners 0 float current corners 1 } intersect = geom intersect prev corners 2 prev corners 3 prev corners 6 prev corners 7 current corners 2 current corners 3 current corners 6 current corners 7 miter limit if intersect != { left line to float intersect x float intersect y } else { left line to float prev corners 6 float prev corners 7 left line to float current corners 2 float current corners 3 } right close path left close path } else { right line to float current corners 4 float current corners 5 left line to float current corners 6 float current corners 7 } } private compute thick line seg offset corners { compute thick line seg 0+offset seg 1+offset seg 2+offset seg 3+offset inner width corners } private compute thick line x1 y1 x2 y2 thickness corners { dx = x2 x1 dy = y2 y1 line length = math sqrt dx * dx + dy * dy scale = thickness / 2d * line length ddx = scale * dy ddy = scale * dx corners 0 = x1 + ddx corners 1 = y1 + ddy corners 2 = x1 ddx corners 3 = y1 ddy corners 4 = x2 + ddx corners 5 = y2 + ddy corners 6 = x2 ddx corners 7 = y2 ddy corners } } 