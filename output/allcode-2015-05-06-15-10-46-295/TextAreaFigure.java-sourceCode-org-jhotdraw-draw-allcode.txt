org jhotdraw draw import org jhotdraw util * import awt * import awt font * import awt geom * import text * import util * import io * import org jhotdraw draw attribute keys * import org jhotdraw geom * import org jhotdraw xml dom input import org jhotdraw xml dom output text area figure attributed figure implements text holder { private rectangle2 d bounds = new rectangle2 d private editable = private basic stroke dashes = new basic stroke 1f basic stroke CAP_BUTT basic stroke JOIN_BEVEL 0f new float {4f 4f} 0f transient private text layout text layout text area figure { this text } text area figure text { set text text } get text { get attribute t e x t } set text new text { set attribute t e x t new text } basic set bounds point2 d anchor point2 d { bounds x = math min anchor x x bounds y = math min anchor y y bounds width = math max 1 math abs x anchor x bounds height = math max 1 math abs y anchor y text layout = } basic transform affine transform tx { point2 d anchor = get start point point2 d = get end point basic set bounds point2 d tx transform anchor anchor point2 d tx transform } contains point2 d p { bounds contains p } insets2 d get insets { sw = math ceil STROKE_WIDTH get this / 2 insets2 d insets = new insets2 d 4 4 4 4 new insets2 d insets top+sw insets left+sw insets bottom+sw insets right+sw } get tab size { 8 } draw text graphics2 d g { if get text != || is editable { font font = get font is underlined = FONT_UNDERLINED get this insets2 d insets = get insets rectangle2 d text rect = new rectangle2 d bounds x + insets left bounds y + insets top bounds width insets left insets right bounds height insets top insets bottom float left margin = float text rect x float right margin = float math max left margin + 1 text rect x + text rect width float vertical pos = float text rect y if left margin < right margin { float tab width = float get tab size * g get font metrics font char width 'm' float tab stops = new float text rect width / tab width for i=0 i < tab stops length i++ { tab stops i = float text rect x + tab width * i + 1 } if get text != { shape saved clip area = g get clip g clip text rect paragraphs = get text split \n for i = 0 i < paragraphs length i++ { if paragraphs i length == 0 paragraphs i = attributed as = new attributed paragraphs i as add attribute text attribute f o n t font if is underlined { as add attribute text attribute u n d e r l i n e text attribute UNDERLINE_LOW_ONE_PIXEL } tab count = new tokenizer paragraphs i \t count tokens 1 vertical pos = draw paragraph g as get iterator vertical pos left margin right margin tab stops tab count if vertical pos > text rect y + text rect height { break } } g set clip saved clip area } } if left margin >= right margin || vertical pos > text rect y + text rect height { g set color color red g set stroke dashes g draw new line2 d text rect x text rect y + text rect height 1 text rect x + text rect width 1 text rect y + text rect height 1 } } } private float draw paragraph graphics2 d g attributed character iterator styled text float vertical pos float left margin float right margin float tab stops tab count { tab locations = new tab count+1 i = 0 for char c = styled text first c != styled text d o n e c = styled text next { if c == '\t' { tab locations i++ = styled text get index } } tab locations tab count = styled text get end index 1 line break measurer measurer = new line break measurer styled text get font render context current tab = 0 while measurer get position < styled text get end index { line contains text = line complete = float max ascent = 0 max descent = 0 float horizontal pos = left margin linked list< text layout> layouts = new linked list< text layout> linked list< float> pen positions = new linked list< float> while !line complete { float wrapping width = right margin horizontal pos text layout layout = layout = measurer next layout wrapping width tab locations current tab +1 line contains text if layout != { layouts add layout pen positions add horizontal pos horizontal pos += layout get advance max ascent = math max max ascent layout get ascent max descent = math max max descent layout get descent + layout get leading } else { line complete = } line contains text = if measurer get position == tab locations current tab +1 { current tab++ } if measurer get position == styled text get end index line complete = else if tab stops length == 0 || horizontal pos >= tab stops tab stops length 1 line complete = if !line complete { j for j=0 horizontal pos >= tab stops j j++ {} horizontal pos = tab stops j } } vertical pos += max ascent iterator< text layout> layout enum = layouts iterator iterator< float> position enum = pen positions iterator while layout enum has next { text layout next layout = layout enum next float next position = position enum next next layout draw g next position vertical pos } vertical pos += max descent } vertical pos } draw fill graphics2 d g { g fill bounds } draw stroke graphics2 d g { g draw bounds } rectangle2 d get bounds { rectangle2 d bounds get bounds2 d } collection< handle> create handles detail level { linked list< handle> handles = linked list< handle> super create handles detail level if detail level == 0 { handles add new font size handle this } handles } validate { super validate text layout = } is editable { editable } set editable b { this editable = b } get text columns { get text == ? 4 math max get text length 4 } tool get tool point2 d p { is editable contains p ? new text area tool this } read bounds dom input in i o { bounds x = in get attribute x 0d bounds y = in get attribute y 0d bounds width = in get attribute w 0d bounds height = in get attribute h 0d } write bounds dom output out i o { out add attribute x bounds x out add attribute y bounds y out add attribute w bounds width out add attribute h bounds height } read dom input in i o { read bounds in read attributes in text layout = } write dom output out i o { write bounds out write attributes out } text area figure clone { text area figure that = text area figure super clone that bounds = rectangle2 d this bounds clone that } text holder get label for { this } restore to geometry { rectangle2 d r = rectangle2 d geometry bounds x = r x bounds y = r y bounds width = r width bounds height = r height } get restore data { bounds clone } font get font { attribute keys get font this } color get text color { TEXT_COLOR get this } color get fill color { FILL_COLOR get this } set font size float size { FONT_SIZE set this new size } float get font size { FONT_SIZE get this float value } } 