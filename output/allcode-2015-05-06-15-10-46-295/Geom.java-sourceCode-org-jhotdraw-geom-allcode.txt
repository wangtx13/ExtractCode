org jhotdraw geom import awt * import awt geom * geom { private geom {} line contains point x1 y1 x2 y2 px py { line contains point x1 y1 x2 y2 px py 3d } line contains point x1 y1 x2 y2 px py tolerance { rectangle r = new rectangle new point x1 y1 r add x2 y2 r grow math max 2 math ceil tolerance math max 2 math ceil tolerance if ! r contains px py { } a b x y if x1 == x2 { math abs px x1 <= tolerance } if y1 == y2 { math abs py y1 <= tolerance } a = y1 y2 / x1 x2 b = y1 a * x1 x = py b / a y = a * px + b math min math abs x px math abs y py <= tolerance } line contains point x1 y1 x2 y2 px py tolerance { rectangle2 d r = new rectangle2 d x1 y1 0 0 r add x2 y2 grow = math max 2 math ceil tolerance r x = grow r y = grow r width += grow * 2 r height += grow * 2 if ! r contains px py { } a b x y if x1 == x2 { math abs px x1 <= tolerance } if y1 == y2 { math abs py y1 <= tolerance } a = y1 y2 / x1 x2 b = y1 a * x1 x = py b / a y = a * px + b math min math abs x px math abs y py <= tolerance } OUT_TOP = rectangle2 d OUT_TOP OUT_BOTTOM = rectangle2 d OUT_BOTTOM OUT_LEFT = rectangle2 d OUT_LEFT OUT_RIGHT = rectangle2 d OUT_RIGHT direction x1 y1 x2 y2 { direction = 0 vx = x2 x1 vy = y2 y1 if vy < vx vx > vy { direction = OUT_RIGHT } else if vy > vx vy > vx { direction = OUT_TOP } else if vx < vy vx < vy { direction = OUT_LEFT } else { direction = OUT_BOTTOM } direction } direction x1 y1 x2 y2 { direction = 0 vx = x2 x1 vy = y2 y1 if vy < vx vx > vy { direction = OUT_RIGHT } else if vy > vx vy > vx { direction = OUT_TOP } else if vx < vy vx < vy { direction = OUT_LEFT } else { direction = OUT_BOTTOM } direction } outcode rectangle r1 rectangle r2 { outcode = 0 if r2 x > r1 x + r1 width outcode = OUT_RIGHT else if r2 x + r2 width < r1 x outcode = OUT_LEFT if r2 y > r1 y + r1 height outcode |= OUT_BOTTOM else if r2 y + r2 height < r1 y outcode |= OUT_TOP outcode } outcode rectangle2 d r1 rectangle2 d r2 { outcode = 0 if r2 x > r1 x + r1 width outcode = OUT_RIGHT else if r2 x + r2 width < r1 x outcode = OUT_LEFT if r2 y > r1 y + r1 height outcode |= OUT_BOTTOM else if r2 y + r2 height < r1 y outcode |= OUT_TOP outcode } point south rectangle r { new point r x + r width /2 r y + r height } point2 d south rectangle2 d r { new point2 d r x + r width /2 r y + r height } point center rectangle r { new point r x + r width /2 r y + r height/2 } point2 d center rectangle2 d r { new point2 d r x + r width /2 r y + r height/2 } point2 d chop shape shape point2 d p { rectangle2 d bounds = shape get bounds2 d point2 d ctr = new point2 d bounds get center x bounds get center y cx = 1 cy = 1 len = MAX_VALUE path iterator i = shape get path iterator new affine transform 1 coords = new 6 type = i current segment coords prev x = coords 0 prev y = coords 1 move to x = prev x move to y = prev y i next for ! i is done i next { switch i current segment coords { case path iterator SEG_MOVETO move to x = coords 0 move to y = coords 1 break case path iterator SEG_CLOSE coords 0 = move to x coords 1 = move to y break } point2 d chop = geom intersect prev x prev y coords 0 coords 1 p x p y ctr x ctr y if chop != { cl = geom length2 chop x chop y p x p y if cl < len { len = cl cx = chop x cy = chop y } } prev x = coords 0 prev y = coords 1 } if len == MAX_VALUE { i = shape get path iterator new affine transform 1 for ! i is done i next { i current segment coords l = geom length2 ctr x ctr y coords 0 coords 1 if l < len { len = l cx = coords 0 cy = coords 1 } } } new point2 d cx cy } point west rectangle r { new point r x r y + r height/ 2 } point2 d west rectangle2 d r { new point2 d r x r y + r height/ 2 } point east rectangle r { new point r x+r width r y + r height/ 2 } point2 d east rectangle2 d r { new point2 d r x+r width r y + r height/ 2 } point north rectangle r { new point r x+r width/2 r y } point2 d north rectangle2 d r { new point2 d r x+r width/2 r y } range min max value { if value < min { value = min } if value > max { value = max } value } range min max value { if value < min { value = min } if value > max { value = max } value } long length2 x1 y1 x2 y2 { x2 x1 * x2 x1 + y2 y1 * y2 y1 } long length x1 y1 x2 y2 { long math sqrt length2 x1 y1 x2 y2 } length2 x1 y1 x2 y2 { x2 x1 * x2 x1 + y2 y1 * y2 y1 } length x1 y1 x2 y2 { math sqrt length2 x1 y1 x2 y2 } length point2 d p1 point2 d p2 { math sqrt length2 p1 x p1 y p2 x p2 y } point2 d cap point2 d p1 point2 d p2 radius { angle = math p i/2 math atan2 p2 x p1 x p2 y p1 y point2 d p3 = new point2 d p2 x + radius * math cos angle p2 y + radius * math sin angle p3 } point to angle rectangle r point p { px = p x r x + r width/2 py = p y r y + r height/2 math atan2 py*r width px*r height } point to angle rectangle2 d r point2 d p { px = p x r x + r width/2 py = p y r y + r height/2 math atan2 py*r width px*r height } angle x1 y1 x2 y2 { math atan2 y2 y1 x2 x1 } point angle to point rectangle r angle { si = math sin angle co = math cos angle e = 0 0001 x= 0 y= 0 if math abs si > e { x= 1 0 + co/ math abs si /2 0 * r width x= range 0 r width x } else if co >= 0 0 { x= r width } if math abs co > e { y= 1 0 + si/ math abs co /2 0 * r height y= range 0 r height y } else if si >= 0 0 { y= r height } new point r x + x r y + y } point2 d angle to point rectangle2 d r angle { si = math sin angle co = math cos angle e = 0 0001 x= 0 y = 0 if math abs si > e { x= 1 0 + co/ math abs si /2 0 * r width x = range 0 r width x } else if co >= 0 0 { x = r width } if math abs co > e { y = 1 0 + si/ math abs co /2 0 * r height y = range 0 r height y } else if si >= 0 0 { y = r height } new point2 d r x + x r y + y } point polar to point angle fx fy { si = math sin angle co = math cos angle new point fx*co+0 5 fy*si+0 5 } point2 d polar to point2 d angle fx fy { si = math sin angle co = math cos angle new point2 d fx*co+0 5 fy*si+0 5 } point oval angle to point rectangle r angle { point center = geom center r point p = geom polar to point angle r width/2 r height/2 new point center x + p x center y + p y } point2 d oval angle to point rectangle2 d r angle { point2 d center = geom center r point2 d p = geom polar to point2 d angle r width/2 r height/2 new point2 d center x + p x center y + p y } point intersect xa ya xb yb xc yc xd yd { denom = xb xa * yd yc yb ya * xd xc rnum = ya yc * xd xc xa xc * yd yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < xc || xb < xd || xa > xb xb > xc || xb > xd { new point xb yb } else { new point xa ya } } else { } } r = rnum / denom snum = ya yc * xb xa xa xc * yb ya s = snum / denom if 0 0 <= r r <= 1 0 0 0 <= s s <= 1 0 { px = xa + xb xa * r py = ya + yb ya * r new point px py } else { } } point2 d intersect xa ya xb yb xc yc xd yd { denom = xb xa * yd yc yb ya * xd xc rnum = ya yc * xd xc xa xc * yd yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < xc || xb < xd || xa > xb xb > xc || xb > xd { new point2 d xb yb } else { new point2 d xa ya } } else { } } r = rnum / denom snum = ya yc * xb xa xa xc * yb ya s = snum / denom if 0 0 <= r r <= 1 0 0 0 <= s s <= 1 0 { px = xa + xb xa * r py = ya + yb ya * r new point2 d px py } else { } } point2 d intersect xa ya xb yb xc yc xd yd limit { denom = xb xa * yd yc yb ya * xd xc rnum = ya yc * xd xc xa xc * yd yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < xc || xb < xd || xa > xb xb > xc || xb > xd { new point2 d xb yb } else { new point2 d xa ya } } else { } } r = rnum / denom snum = ya yc * xb xa xa xc * yb ya s = snum / denom if 0 0 <= r r <= 1 0 0 0 <= s s <= 1 0 { px = xa + xb xa * r py = ya + yb ya * r new point2 d px py } else { px = xa + xb xa * r py = ya + yb ya * r if length xa ya px py <= limit || length xb yb px py <= limit || length xc yc px py <= limit || length xd yd px py <= limit { new point2 d px py } } } distance from line xa ya xb yb xc yc { xdiff = xb xa ydiff = yb ya long l2 = xdiff * xdiff + ydiff * ydiff if l2 == 0 { geom length xa ya xc yc } rnum = ya yc * ya yb xa xc * xb xa r = rnum / l2 if r < 0 0 || r > 1 0 { MAX_VALUE } xi = xa + r * xdiff yi = ya + r * ydiff xd = xc xi yd = yc yi math sqrt xd * xd + yd * yd } grow rectangle2 d r h v { r x = h r y = v r width += h * 2d r height += v * 2d } } 