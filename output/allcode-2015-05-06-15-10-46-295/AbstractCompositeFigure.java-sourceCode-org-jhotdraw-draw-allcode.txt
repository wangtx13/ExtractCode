org jhotdraw draw import io i o import org jhotdraw util * import org jhotdraw util * import awt * import awt geom * import util * import javax swing event * import javax swing undo * import org jhotdraw geom * import org jhotdraw xml dom input import org jhotdraw xml dom output composite figure figure implements composite figure { private linked list< figure> children = new linked list< figure> private rectangle2 d draw bounds private rectangle2 d bounds private layouter layouter private child handler child handler = new child handler this private child handler implements figure listener undoable edit listener { private composite figure owner private child handler composite figure owner { this owner = owner } figure request remove figure event e { owner remove e get figure } figure removed figure event evt { } figure changed figure event e { if ! owner is changing { owner will change owner fire figure changed e owner changed } } figure added figure event e { } figure attribute changed figure event e { } figure area invalidated figure event e { if ! owner is changing { owner fire area invalidated e get invalidated area } } undoable edit happened undoable edit event e { owner fire undoable edit happened e get edit } } composite figure { } collection< handle> create handles detail level { if detail level == 0 { super create handles 0 } linked list< handle> handles = new linked list< handle> handles } add figure figure { add get child count figure } add index figure figure { will change basic add index figure if get drawing != { figure add notify get drawing } changed } add all collection< figure> new figures { will change for figure f new figures { basic add get child count f if get drawing != { f add notify get drawing } } changed } basic add figure figure { basic add get child count figure } basic add index figure figure { children add index figure figure add figure listener child handler figure add undoable edit listener child handler } basic add all collection< figure> new figures { for figure f new figures { basic add get child count f } } add notify drawing drawing { super add notify drawing for figure child children { child add notify drawing } } remove notify drawing drawing { for figure child new linked list< figure> children { child remove notify drawing } super remove notify drawing } remove figure figure { index = children index of figure if index == 1 { } else { will change basic remove child index if get drawing != { figure remove notify get drawing } changed } } figure remove child index { will change figure removed = basic remove child index if get drawing != { removed remove notify get drawing } changed removed } basic remove figure figure { index = children index of figure if index == 1 { } else { basic remove child index } } figure basic remove child index { figure figure = children remove index figure remove figure listener child handler figure remove undoable edit listener child handler figure } remove all children { will change while children size > 0 { figure f = basic remove child children size 1 if get drawing != { f add notify get drawing } } changed } basic remove all children { while children size > 0 { figure f = basic remove child children size 1 } } synchronized send to back figure figure { if children remove figure { children add 0 figure figure invalidate } } synchronized send to front figure figure { if children remove figure { children add figure figure invalidate } } basic transform affine transform tx { for figure f children { f basic transform tx } invalidate bounds } basic set bounds point2 d anchor point2 d { rectangle2 d old bounds = get bounds rectangle2 d new bounds = new rectangle2 d math min anchor x x math min anchor y y math abs anchor x x math abs anchor y y sx = new bounds width / old bounds width sy = new bounds height / old bounds height affine transform tx = new affine transform tx translate old bounds x old bounds y if ! is na n sx ! is na n sy sx != 1d || sy != 1d ! sx < 0 0001 ! sy < 0 0001 { basic transform tx tx set to identity tx scale sx sy basic transform tx tx set to identity } tx translate new bounds x new bounds y basic transform tx } undoable edit happened undoable edit event e { fire undoable edit happened e get edit } util list< figure> get children { collections unmodifiable list children } get child count { children size } figure get child index { children get index } util list< figure> get children front to back { children == ? new linked list< figure> new reversed list< figure> children } set attribute attribute key name value { will change for figure child children { child set attribute name value } changed } basic set attribute attribute key name value { for figure child children { child basic set attribute name value } } get attribute attribute key name { } contains point2 d p { if get draw bounds contains p { for figure child get children front to back { if child is visible child contains p } } } figure find figure inside point2 d p { if get draw bounds contains p { figure found = for figure child get children front to back { if child is visible { found = child find figure inside p if found != { found } } } } } figure find child point2 d p { if get bounds contains p { figure found = for figure child get children front to back { if child is visible child contains p { child } } } } find child index point2 d p { figure child = find child p child == ? 1 children index of child } layouter get layouter { layouter } layout { if get layouter != { rectangle2 d bounds = get bounds point2 d p = new point2 d bounds x bounds y rectangle2 d r = get layouter layout this p p basic set bounds new point2 d r x r y new point2 d r x + r width r y + r height invalidate bounds } } set layouter layouter new layouter { this layouter = new layouter } dimension2 d get preferred size { if this layouter != { rectangle2 d r = layouter calculate layout this get start point get end point new dimension2 d r width r height } else { super get preferred size } } rectangle2 d get figure draw bounds { if draw bounds == { for figure child get children front to back { if child is visible { rectangle2 d child bounds = child get draw bounds if ! child bounds is empty { if draw bounds == { draw bounds = child bounds } else { draw bounds add child bounds } } } } } draw bounds == ? new rectangle2 d 0 0 1 1 rectangle2 d draw bounds clone } rectangle2 d get bounds { if bounds == { for figure child get children front to back { if child is visible { if bounds == { bounds = child get bounds } else { bounds add child get bounds } } } } bounds == ? new rectangle2 d 0 0 1 1 rectangle2 d bounds clone } draw figure graphics2 d g { for figure child children { if child is visible { child draw g } } if is connectors visible { draw connectors g } } draw connectors graphics2 d g { } composite figure clone { composite figure that = composite figure super clone that child handler = new child handler that that children = new linked list< figure> for figure this child this children { figure that child = figure this child clone that children add that child that child add figure listener that child handler that child add undoable edit listener that child handler } that } invalidate bounds { bounds = draw bounds = } collection< figure> get decomposition { linked list< figure> list = new linked list< figure> list add this list add all get children list } read dom input in i o { in open element children for i=0 i < in get element count i++ { add figure in read i } in close element } write dom output out i o { out open element children for figure child get children { out write child } out close element } map< attribute key object> get attributes { new hash map< attribute key object> } restore to geometry { linked list list = linked list geometry index = 0 for geom list { get child index restore to geom index++ } invalidate bounds } get restore data { linked list< object> list = new linked list< object> for figure child children { list add child get restore data } list } will change { super will change if get changing depth == 1 { for figure child children { child will change } } } changed { if get changing depth == 1 { for figure child children { child changed } } super changed } invalidate { super invalidate invalidate bounds } validate { super validate layout invalidate bounds } remove attribute attribute key key { } has attribute attribute key key { } } 