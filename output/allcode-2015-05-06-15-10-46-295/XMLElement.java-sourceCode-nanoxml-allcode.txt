nanoxml import io * import util * xml element { long serial uid = 6685035139346394777 l NANOXML_MAJOR_VERSION = 2 NANOXML_MINOR_VERSION = 2 private hash map attributes private list children private name private contents private hash map entities private line nr private ignore case private ignore whitespace private char char read too much private reader reader private parser line nr private is encode unicode characters = xml element { this new hash map } xml element hash map entities { this entities } xml element skip leading whitespace { this new hash map skip leading whitespace } xml element hash map entities skip leading whitespace { this entities skip leading whitespace } xml element hash map entities skip leading whitespace ignore case { this entities skip leading whitespace ignore case } xml element hash map entities skip leading whitespace fill basic conversion table ignore case { this entities skip leading whitespace fill basic conversion table ignore case } xml element hash map entities skip leading whitespace fill basic conversion table ignore case encode unicode characters { this ignore whitespace = skip leading whitespace this ignore case = ignore case this name = this contents = this attributes = new hash map this children = new list this entities = entities this line nr = 0 this is encode unicode characters = encode unicode characters iterator iter = this entities key set iterator while iter has next { key = iter next value = this entities get key if value instanceof { value = value to char this entities put key value } } if fill basic conversion table { this entities put amp new char { ' ' } this entities put new char { ' ' } this entities put apos new char { '\'' } this entities put lt new char { '<' } this entities put new char { '>' } } } add child xml element child { this children add child } set attribute name value { if this ignore case { name = name to upper case } this attributes put name value to } set attribute name value { if this ignore case { name = name to upper case } this attributes put name integer to value } set attribute name value { if this ignore case { name = name to upper case } this attributes put name to value } count children { this children size } iterator enumerate attribute names { this attributes key set iterator } iterator iterate children { this children iterator } list get children { try { list this children clone } catch e { } } get content { this contents } get line nr { this line nr } get attribute name { this get attribute name } get attribute name default value { if this ignore case { name = name to upper case } value = this attributes get name if value == { value = default value } value } get attribute name map value set default key allow literals { if this ignore case { name = name to upper case } key = this attributes get name result if key == { key = default key } result = value set get key if result == { if allow literals { result = key } else { throw this invalid value name key } } result } get attribute name { this get attribute name } get attribute name default value { this get attribute name default value } get attribute name hash map value set default key allow literals { this get attribute name value set default key allow literals } get attribute name { this get attribute name 0 } get attribute name default value { if this ignore case { name = name to upper case } value = this attributes get name if value == { default value } else { try { integer parse value } catch number format e { throw this invalid value name value } } } get attribute name min max default value { v = get attribute name default value if v < min min if v > max max v } get attribute name hash map value set default key allow literal numbers { if this ignore case { name = name to upper case } key = this attributes get name integer result if key == { key = default key } try { result = integer value set get key } catch cast e { throw this invalid value set name } if result == { if ! allow literal numbers { throw this invalid value name key } try { result = integer value of key } catch number format e { throw this invalid value name key } } result value } get attribute name { this get attribute name 0 } get attribute name default value { if this ignore case { name = name to upper case } value = this attributes get name if value == { default value } else { try { value of value value } catch number format e { throw this invalid value name value } } } get attribute name hash map value set default key allow literal numbers { if this ignore case { name = name to upper case } key = this attributes get name result if key == { key = default key } try { result = value set get key } catch cast e { throw this invalid value set name } if result == { if ! allow literal numbers { throw this invalid value name key } try { result = value of key } catch number format e { throw this invalid value name key } } result value } get attribute name value value default value { if this ignore case { name = name to upper case } value = this attributes get name if value == { default value } else if value equals value { } else if value equals value { } else { throw this invalid value name value } } get attribute name default value { get attribute name default value } get name { this name } parse from reader reader reader i o xml parse { this parse from reader reader 1 } parse from reader reader reader starting line nr i o xml parse { this name = this contents = this attributes = new hash map this children = new list this char read too much = '\0' this reader = reader this parser line nr = starting line nr for { char ch = this scan whitespace if ch != '<' { throw this expected input < } ch = this read char if ch == '!' || ch == '?' { this skip special tag 0 } else { this unread char ch this scan element this } } } parse xml parse { try { this parse from reader new reader 1 } catch i o e { } } parse offset xml parse { this parse substring offset } parse offset end xml parse { this parse substring offset end } parse offset end starting line nr xml parse { = substring offset end try { this parse from reader new reader starting line nr } catch i o e { } } parse char char input offset end xml parse { this parse char input offset end 1 } parse char char input offset end starting line nr xml parse { try { reader reader = new char reader input offset end this parse from reader reader starting line nr } catch i o e { } } remove child xml element child { this children remove child } remove attribute name { if this ignore case { name = name to upper case } this attributes remove name } xml element create element name { xml element elem = create element elem set name name elem } xml element create element { new xml element this entities this ignore whitespace this ignore case this is encode unicode characters } set content content { this contents = content } set name name { this name = name } to { try { byte output stream out = new byte output stream output stream writer writer = new output stream writer out this write writer writer flush new out to byte } catch i o e { super to } } write writer writer i o { if this name == { this write encoded writer this contents } writer write '<' writer write this name if ! this attributes is empty { iterator iter = this attributes key set iterator while iter has next { writer write ' ' key = iter next value = this attributes get key writer write key writer write '=' writer write ' ' this write encoded writer value writer write ' ' } } if this contents != this contents length > 0 { writer write '>' this write encoded writer this contents writer write '<' writer write '/' writer write this name writer write '>' } else if this children is empty { writer write '/' writer write '>' } else { writer write '>' iterator iter = this iterate children while iter has next { xml element child = xml element iter next child write writer } writer write '<' writer write '/' writer write this name writer write '>' } } print print writer writer { print writer 0 } print print writer writer indent { try { if this name == { this write encoded writer this contents } char spaces = new char indent * 2 arrays fill spaces ' ' writer write spaces writer write '<' writer write this name if ! this attributes is empty { iterator enm = this attributes key set iterator while enm has next { writer write ' ' key = enm next value = this attributes get key writer write key writer write '=' writer write ' ' this write encoded writer value writer write ' ' } } if this contents != this contents length > 0 { writer write '>' this write encoded writer this contents writer write '<' writer write '/' writer write this name writer write '>' } else if this children is empty { writer write '/' writer write '>' } else { writer write '>' writer write '\n' iterator enm = this get children iterator while enm has next { xml element child = xml element enm next child print writer indent + 1 } writer write spaces writer write '<' writer write '/' writer write this name writer write '>' } writer write '\n' } catch i o e { internal = new internal e get message init cause e throw } } write encoded writer writer str i o { for i = 0 i < str length i += 1 { char ch = str char at i switch ch { case '<' writer write ' ' writer write 'l' writer write 't' writer write ' ' break case '>' writer write ' ' writer write 'g' writer write 't' writer write ' ' break case ' ' writer write ' ' writer write 'a' writer write 'm' writer write 'p' writer write ' ' break case ' ' writer write ' ' writer write 'q' writer write 'u' writer write 'o' writer write 't' writer write ' ' break case '\'' writer write ' ' writer write 'a' writer write 'p' writer write 'o' writer write 's' writer write ' ' break default unicode = ch if unicode < 32 || is encode unicode characters unicode > 126 { writer write ' ' writer write '#' writer write 'x' writer write integer to unicode 16 writer write ' ' } else { writer write ch } } } } scan identifier buffer result i o { for { char ch = this read char if ch < ' a' || ch > ' z' ch < 'a' || ch > 'z' ch < '0' || ch > '9' ch != '_' ch != ' ' ch != ' ' ch != ' ' ch <= '\u007 e' { this unread char ch } result append ch } } char scan whitespace i o { for { char ch = this read char switch ch { case ' ' case '\t' case '\n' case '\r' break default ch } } } char scan whitespace buffer result i o { for { char ch = this read char switch ch { case ' ' case '\t' case '\n' result append ch case '\r' break default ch } } } scan buffer i o { char delimiter = this read char if delimiter != '\'' delimiter != ' ' { throw this expected input ' or \ } for { char ch = this read char if ch == delimiter { } else if ch == ' ' { this resolve entity } else { append ch } } } scan p c data buffer data i o { for { char ch = this read char if ch == '<' { ch = this read char if ch == '!' { this check c d a t a data } else { this unread char ch } } else if ch == ' ' { this resolve entity data } else { data append ch } } } check c d a t a buffer buf i o { char ch = this read char if ch != ' ' { this unread char ch this skip special tag 0 } else if ! this check literal c d a t a { this skip special tag 1 } else { delimiter chars skipped = 0 while delimiter chars skipped < 3 { ch = this read char switch ch { case ' ' if delimiter chars skipped < 2 { delimiter chars skipped += 1 } else { buf append ' ' buf append ' ' delimiter chars skipped = 0 } break case '>' if delimiter chars skipped < 2 { for i = 0 i < delimiter chars skipped i++ { buf append ' ' } delimiter chars skipped = 0 buf append '>' } else { delimiter chars skipped = 3 } break default for i = 0 i < delimiter chars skipped i += 1 { buf append ' ' } buf append ch delimiter chars skipped = 0 } } } } skip comment i o { dashes to read = 2 while dashes to read > 0 { char ch = this read char if ch == ' ' { dashes to read = 1 } else { dashes to read = 2 } } if this read char != '>' { throw this expected input > } } skip special tag bracket level i o { tag level = 1 char delimiter = '\0' if bracket level == 0 { char ch = this read char if ch == ' ' { bracket level += 1 } else if ch == ' ' { ch = this read char if ch == ' ' { bracket level += 1 } else if ch == ' ' { bracket level = 1 } else if ch == ' ' { this skip comment } } } while tag level > 0 { char ch = this read char if delimiter == '\0' { if ch == ' ' || ch == '\'' { delimiter = ch } else if bracket level <= 0 { if ch == '<' { tag level += 1 } else if ch == '>' { tag level = 1 } } if ch == ' ' { bracket level += 1 } else if ch == ' ' { bracket level = 1 } } else { if ch == delimiter { delimiter = '\0' } } } } check literal literal i o { length = literal length for i = 0 i < length i += 1 { if this read char != literal char at i { } } } char read char i o { if this char read too much != '\0' { char ch = this char read too much this char read too much = '\0' ch } else { i = this reader read if i < 0 { throw this unexpected end of data } else if i == 10 { this parser line nr += 1 '\n' } else { char i } } } scan element xml element elt i o { buffer buf = new buffer this scan identifier buf name = buf to elt set name name char ch = this scan whitespace while ch != '>' ch != '/' { buf set length 0 this unread char ch this scan identifier buf key = buf to ch = this scan whitespace if ch != '=' { throw this expected input = } this unread char this scan whitespace buf set length 0 this scan buf elt set attribute key buf ch = this scan whitespace } if ch == '/' { ch = this read char if ch != '>' { throw this expected input > } } buf set length 0 ch = this scan whitespace buf if ch != '<' { this unread char ch this scan p c data buf } else { for { ch = this read char if ch == '!' { if this check c d a t a buf { this scan p c data buf break } else { ch = this scan whitespace buf if ch != '<' { this unread char ch this scan p c data buf break } } } else { if ch != '/' || this ignore whitespace { buf set length 0 } if ch == '/' { this unread char ch } break } } } if buf length == 0 { while ch != '/' { if ch == '!' { ch = this read char if ch != ' ' { throw this expected input comment or element } ch = this read char if ch != ' ' { throw this expected input comment or element } this skip comment } else { this unread char ch xml element child = this create element this scan element child elt add child child } ch = this scan whitespace if ch != '<' { throw this expected input < } ch = this read char } this unread char ch } else { if this ignore whitespace { elt set content buf to trim } else { elt set content buf to } } ch = this read char if ch != '/' { throw this expected input / } this unread char this scan whitespace if ! this check literal name { throw this expected input name } if this scan whitespace != '>' { throw this expected input > } } resolve entity buffer buf i o { char ch = '\0' buffer key buf = new buffer for { ch = this read char if ch == ' ' { break } key buf append ch } key = key buf to if key char at 0 == '#' { try { if key char at 1 == 'x' { ch = char integer parse key substring 2 16 } else { ch = char integer parse key substring 1 10 } } catch number format e { throw this unknown entity key } buf append ch } else { char value = char this entities get key if value == { throw this unknown entity key } buf append value } } unread char char ch { this char read too much = ch } xml parse invalid value set name { msg = invalid value set entity name = \ + name + \ new xml parse this get name this parser line nr msg } xml parse invalid value name value { msg = attribute \ + name + \ does not contain a valid + value \ + value + \ new xml parse this get name this parser line nr msg } xml parse unexpected end of data { msg = unexpected end of data reached new xml parse this get name this parser line nr msg } xml parse syntax context { msg = syntax while parsing + context new xml parse this get name this parser line nr msg } xml parse expected input char set { msg = expected + char set new xml parse this get name this parser line nr msg } xml parse unknown entity name { msg = unknown or invalid entity + name + new xml parse this get name this parser line nr msg } } 