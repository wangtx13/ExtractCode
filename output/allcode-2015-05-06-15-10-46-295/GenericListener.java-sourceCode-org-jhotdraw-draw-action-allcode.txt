org jhotdraw draw action import lang reflect * generic listener { create listener listener name target target name { listener = get listener listener listener name target = get target target target name listener get parameter types if target == { target = get target target target name new 0 } if target == { throw new runtime no such +target name+ in +target get } create listener target target } create listener target target { invocation handler handler = new default invoker { proxy args throwable { if listener equals { if target get parameter types length == 0 { target target new 0 } else { target target args } } else { super proxy args } } } cls = listener get declaring loader cl = cls get loader proxy new proxy instance cl new {cls} handler } private default invoker implements invocation handler { proxy args throwable { if get declaring == { name = get name if name equals hash { proxy hash proxy } else if name equals equals { proxy equals proxy args 0 } else if name equals to { proxy to proxy } } value of get type } integer proxy hash proxy { new integer identity hash proxy } proxy equals proxy other { proxy == other ? t r u e f a l s e } proxy to proxy { proxy get get name + '@' + integer to hex proxy hash } private character char_0 = new character char 0 private byte byte_0 = new byte byte 0 private value of rt { if !rt is primitive { } else if rt == { } else if rt == { f a l s e } else if rt == char { char_0 } else { byte_0 } } } private get listener listener listener name { m = listener get result = for i = 0 i < m length i++ { if listener name equals m i get name { if result != { throw new runtime ambiguous +m i + vs +result } result = m i } } if result == { throw new runtime no such +listener name+ in +listener } result } private get target target target name parameter types { m = target get get result = each for i = 0 i < m length i++ { if !target name equals m i get name continue each p = m i get parameter types if p length != parameter types length continue each for j = 0 j < p length j++ { if !p j is assignable from parameter types j continue each } if result != { throw new runtime ambiguous +m i + vs +result } result = m i } if result == { } result = raise to result if result != result = result result } private raise to m { c = m get declaring if modifier is m get modifiers modifier is c get modifiers m sc = c get superclass if sc != { sm = raise to m sc if sm != sm } ints = c get for i = 0 i < ints length i++ { im = raise to m ints i if im != im } } private raise to m c { try { sm = c get m get name m get parameter types raise to sm } catch no such ee { } } private generic listener {} } 