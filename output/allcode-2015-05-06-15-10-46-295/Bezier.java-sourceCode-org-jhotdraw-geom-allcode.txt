org jhotdraw geom import org jhotdraw util * import awt * import awt geom * bezier { private m a x p o i n t s = 1000 private bezier { } args { point2 d d = {	 new point2 d 0 0 0 0 new point2 d 0 0 0 5 new point2 d 1 1 1 4 new point2 d 2 1 1 6 new point2 d 3 2 1 1 new point2 d 4 0 0 2 new point2 d 4 0 0 0 } double	error = 4 0 		 general path path = fit curve d 	 out path } general path fit curve polygon p { point2 d d = new point2 d p npoints for i=0 i < d length i++ { d i = new point2 d p xpoints i p ypoints i } fit curve d } general path fit curve point2 d d { point2 d t hat1 = new point2 d point2 d t hat2 = new point2 d general path bezier path = new general path bezier path move to float d 0 x float d 0 y t hat1 = compute left tangent d 0 t hat2 = compute right tangent d d length 1 fit cubic d 0 d length 1 t hat1 t hat2 bezier path bezier path } bezier path fit bezier curve bezier path path { point2 d d = path to polygon point2 d t hat1 = new point2 d point2 d t hat2 = new point2 d bezier path bezier path = new bezier path bezier path add new bezier path node d 0 t hat1 = compute left tangent d 0 t hat2 = compute right tangent d d length 1 fit cubic d 0 d length 1 t hat1 t hat2 bezier path bezier path set closed path is closed bezier path } private fit cubic point2 d d first last point2 d t hat1 point2 d t hat2 general path bezier path { point2 d bez curve u 		 u prime 	 double	max 	 	split point = new 1 int	n pts 		 double	iteration int	max iterations = 4 point2 d double	t hat center = new point2 d int	i iteration = * n pts = last first + 1 if n pts == 2 { dist = v2 distance between2 points d last d first / 3 0 bez curve = new point2 d 4 for i=0 i < bez curve length i++ { bez curve i = new point2 d } bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bezier path curve to float bez curve 1 x float bez curve 1 y float bez curve 2 x float bez curve 2 y float bez curve 3 x float bez curve 3 y } u = chord length parameterize d first last bez curve = generate bezier d first last u t hat1 t hat2 max = compute max d first last bez curve u split point if max < { bezier path curve to float bez curve 1 x float bez curve 1 y float bez curve 2 x float bez curve 2 y float bez curve 3 x float bez curve 3 y } if max < iteration { for i = 0 i < max iterations i++ { u prime = reparameterize d first last u bez curve bez curve = generate bezier d first last u prime t hat1 t hat2 max = compute max d first last bez curve u prime split point if max < { bezier path curve to float bez curve 1 x float bez curve 1 y float bez curve 2 x float bez curve 2 y float bez curve 3 x float bez curve 3 y } u = u prime } } t hat center = compute center tangent d split point 0 fit cubic d first split point 0 t hat1 t hat center bezier path v2 negate t hat center fit cubic d split point 0 last t hat center t hat2 bezier path } private fit cubic point2 d d first last point2 d t hat1 point2 d t hat2 bezier path bezier path { point2 d bez curve u 		 u prime 	 double	max 	 	split point = new 1 int	n pts 		 double	iteration int	max iterations = 4 point2 d double	t hat center = new point2 d int	i iteration = * n pts = last first + 1 if n pts == 2 { dist = v2 distance between2 points d last d first / 3 0 bez curve = new point2 d 4 for i=0 i < bez curve length i++ { bez curve i = new point2 d } bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bezier path curve to bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y } u = chord length parameterize d first last bez curve = generate bezier d first last u t hat1 t hat2 max = compute max d first last bez curve u split point if max < { bezier path curve to bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y } if max < iteration { for i = 0 i < max iterations i++ { u prime = reparameterize d first last u bez curve bez curve = generate bezier d first last u prime t hat1 t hat2 max = compute max d first last bez curve u prime split point if max < { bezier path curve to bez curve 1 x bez curve 1 y bez curve 2 x bez curve 2 y bez curve 3 x bez curve 3 y } u = u prime } } t hat center = compute center tangent d split point 0 fit cubic d first split point 0 t hat1 t hat center bezier path v2 negate t hat center fit cubic d split point 0 last t hat center t hat2 bezier path } private point2 d generate bezier point2 d d first last u prime point2 d t hat1 point2 d t hat2 { 	i point2 d a = new point2 d m a x p o i n t s 2 	n pts 			 c = new 2 2 x = new 2 	 	det_C0_C1 		 det_C0_X det_X_C1 	alpha_l 		 alpha_r point2 d 	tmp = new point2 d point2 d bez curve 	 bez curve = new point2 d 4 for i=0 i < bez curve length i++ { bez curve i = new point2 d } n pts = last first + 1 for i = 0 i < n pts i++ { point2 d v1 v2 v1 = point2 d t hat1 clone v2 = point2 d t hat2 clone v2 scale v1 b1 u prime i v2 scale v2 b2 u prime i a i 0 = v1 a i 1 = v2 } c 0 0 = 0 0 c 0 1 = 0 0 c 1 0 = 0 0 c 1 1 = 0 0 x 0 = 0 0 x 1 = 0 0 for i = 0 i < n pts i++ { c 0 0 += v2 dot a i 0 a i 0 c 0 1 += v2 dot a i 0 a i 1 c 1 0 = c 0 1 c 1 1 += v2 dot a i 1 a i 1 tmp = v2 sub i i d first + i v2 add i i v2 scale i i i d first b0 u prime i v2 add i i v2 scale i i i d first b1 u prime i v2 add i i v2 scale i i i d last b2 u prime i v2 scale i i i d last b3 u prime i x 0 += v2 dot a i 0 tmp x 1 += v2 dot a i 1 tmp } det_C0_C1 = c 0 0 * c 1 1 c 1 0 * c 0 1 det_C0_X = c 0 0 * x 1 c 0 1 * x 0 det_X_C1 = x 0 * c 1 1 x 1 * c 0 1 if det_C0_C1 == 0 0 { det_C0_C1 = c 0 0 * c 1 1 * 10e 12 } alpha_l = det_X_C1 / det_C0_C1 alpha_r = det_C0_X / det_C0_C1 if alpha_l < 1 0e 6 || alpha_r < 1 0e 6 { dist = v2 distance between2 points d last d first / 3 0 bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 dist bez curve 1 v2 add bez curve 3 v2 scale t hat2 dist bez curve 2 bez curve } bez curve 0 = d first bez curve 3 = d last v2 add bez curve 0 v2 scale t hat1 alpha_l bez curve 1 v2 add bez curve 3 v2 scale t hat2 alpha_r bez curve 2 bez curve } private reparameterize point2 d d first last u point2 d bez curve { 	n pts = last first+1 	i u prime u prime = new n pts for i = first i <= last i++ { u prime i first = newton raphson root find bez curve d i u i first } u prime } private newton raphson root find point2 d q point2 d p u { 		numerator denominator point2 d q1 = new point2 d 3 q2 = new point2 d 2 	 point2 d Double	Q_u = new point2 d Q1_u = new point2 d Q2_u = new point2 d 		u prime 		 		i Q_u = bezier i i 3 q u for i = 0 i <= 2 i++ { q1 i = new point2 d q i+1 x q i x * 3 0 q i+1 y q i y * 3 0 } for i = 0 i <= 1 i++ { q2 i = new point2 d q1 i+1 x q1 i x * 2 0 q1 i+1 y q1 i y * 2 0 } Q1_u = bezier i i 2 q1 u Q2_u = bezier i i 1 q2 u numerator = Q_u x p x * Q1_u x + Q_u y p y * Q1_u y denominator = Q1_u x * Q1_u x + Q1_u y * Q1_u y + Q_u x p x * Q2_u x + Q_u y p y * Q2_u y u prime = u numerator/denominator u prime } private point2 d bezier i i degree point2 d v t { 	i j point2 d q point2 d vtemp vtemp = new point2 d degree+1 for i = 0 i <= degree i++ { vtemp i = point2 d v i clone } for i = 1 i <= degree i++ { for j = 0 j <= degree i j++ { vtemp j x = 1 0 t * vtemp j x + t * vtemp j+1 x vtemp j y = 1 0 t * vtemp j y + t * vtemp j+1 y } } q = vtemp 0 q } private b0 u { tmp = 1 0 u tmp * tmp * tmp } private b1 u { tmp = 1 0 u 3 * u * tmp * tmp } private b2 u { tmp = 1 0 u 3 * u * u * tmp } private b3 u { u * u * u } private point2 d compute left tangent point2 d d end { point2 d double	t hat1 = new point2 d t hat1 = v2 sub i i d end+1 d end t hat1 = v2 normalize t hat1 t hat1 } private point2 d compute right tangent point2 d d end { point2 d t hat2 = new point2 d t hat2 = v2 sub i i d end 1 d end t hat2 = v2 normalize t hat2 t hat2 } private point2 d compute center tangent point2 d d center { point2 d v1 = new point2 d v2 = new point2 d t hat center = new point2 d v1 = v2 sub i i d center 1 d center v2 = v2 sub i i d center d center+1 t hat center x = v1 x + v2 x /2 0 t hat center y = v1 y + v2 y /2 0 t hat center = v2 normalize t hat center t hat center } private chord length parameterize point2 d d first last { int	i u 	 u = new last first+1 u 0 = 0 0 for i = first+1 i <= last i++ { u i first = u i first 1 + v2 distance between2 points d i d i 1 } for i = first + 1 i <= last i++ { u i first = u i first / u last first } u } private compute max point2 d d first last point2 d bez curve u split point { int		i double	max dist 		 double	dist 		 point2 d double	 p = new point2 d point2 d double	v = new point2 d split point 0 = last first + 1 /2 max dist = 0 0 for i = first + 1 i < last i++ { p = bezier i i 3 bez curve u i first v = v2 sub i i p d i dist = v2 squared length v if dist >= max dist { max dist = dist split point 0 = i } } max dist } private point2 d v2 add i i point2 d a point2 d b { point2 d c = new point2 d c x = a x + b x c y = a y + b y c } private point2 d v2 scale i i i point2 d v s { point2 d result = new point2 d result x = v x * s result y = v y * s result } private point2 d v2 sub i i point2 d a point2 d b { point2 d c = new point2 d c x = a x b x c y = a y b y c } private v2 distance between2 points point2 d a point2 d b { dx = a x b x dy = a y b y math sqrt dx*dx + dy*dy } private point2 d v2 scale point2 d v newlen { len = v2 length v if len != 0 0 { v x *= newlen/len v y *= newlen/len } v } private v2 length point2 d a { math sqrt v2 squared length a } private v2 squared length point2 d a { a x * a x + a y * a y } private point2 d v2 add point2 d a point2 d b point2 d c { c x = a x+b x c y = a y+b y c } private point2 d v2 negate point2 d v { v x = v x v y = v y v } private v2 dot point2 d a point2 d b { a x*b x + a y*b y } private point2 d v2 normalize point2 d v { len = v2 length v if len != 0 0 { v x /= len v y /= len } v } } 