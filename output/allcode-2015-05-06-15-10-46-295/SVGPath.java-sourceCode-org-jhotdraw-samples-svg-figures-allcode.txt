org jhotdraw samples svg figures import awt * import awt event * import awt geom * import io * import util * import javax swing * import org jhotdraw draw * import org jhotdraw draw action * import org jhotdraw geom * import org jhotdraw samples svg * import org jhotdraw util * import org jhotdraw xml * import org jhotdraw draw attribute keys * s v g path attributed composite figure implements s v g figure { private general path path s v g path { add new bezier figure s v g util set defaults this } draw figure graphics2 d g { validate path if attribute keys FILL_COLOR get this != { g set color attribute keys FILL_COLOR get this draw fill g } if STROKE_COLOR get this != { g set stroke attribute keys get stroke this g set color STROKE_COLOR get this draw stroke g } if is connectors visible { draw connectors g } } draw fill graphics2 d g { if get children size > 0 { g fill path } } draw stroke graphics2 d g { g draw path } invalidate { super invalidate invalidate path } validate { validate path super validate } validate path { if path == { path = new general path path set winding rule WINDING_RULE get this == winding rule EVEN_ODD ? general path WIND_EVEN_ODD general path WIND_NON_ZERO for figure child get children { bezier figure b = bezier figure child path append b get bezier path } } } invalidate path { path = } @ override write dom output out i o { write points out write attributes out } write points dom output out { builder buf = new builder for figure child get children { bezier figure b = bezier figure child buf append s v g util to path data b get bezier path } out add attribute d buf to } write attributes dom output out i o { s v g util write attributes this out } @ override read dom input in i o { read points in read attributes in affine transform tx = s v g util get transform in transform basic transform tx } read points dom input in i o { remove all children if in get tag name equals polyline { bezier path b = new bezier path points = in get attribute points tokenizer tt = new tokenizer points while tt has more tokens { b add new bezier path node value of tt next token value of tt next token } bezier figure child = new bezier figure child basic set bezier path b basic add child } else if in get tag name equals polygon { bezier path b = new bezier path b set closed points = in get attribute points tokenizer tt = new tokenizer points while tt has more tokens { b add new bezier path node value of tt next token value of tt next token } bezier figure child = new bezier figure child basic set bezier path b basic add child } else { util list< bezier path> paths = s v g util get path in d for bezier path b paths { bezier figure child = new bezier figure child basic set bezier path b basic add child } if paths size == 0 { bezier figure child = new bezier figure basic add child } } } read attributes dom input in i o { s v g util read attributes this in } basic transform affine transform tx { super basic transform tx invalidate path } is empty { for figure child get children { bezier figure b = bezier figure child if b get point count > 0 { } } } @ override linked list< handle> create handles detail level { linked list< handle> handles if detail level == 0 { handles = linked list< handle> super create handles detail level handles add new rotate handle this } else { handles = new linked list< handle> for figure child get children { handles add all child create handles detail level } } handles } @ override collection< action> get actions point2 d p { resource bundle util labels = resource bundle util get l a f bundle org jhotdraw samples svg labels linked list< action> actions = new linked list< action> actions add new action labels get close path { action performed action event evt { for figure child get children { bezier figure b = bezier figure child b set closed } } } actions add new action labels get open path { action performed action event evt { for figure child get children { bezier figure b = bezier figure child b set closed } } } actions add new action labels get winding even odd { action performed action event evt { WINDING_RULE set s v g path this winding rule EVEN_ODD } } actions add new action labels get winding non zero { action performed action event evt { WINDING_RULE set s v g path this winding rule NON_ZERO } } actions } } 