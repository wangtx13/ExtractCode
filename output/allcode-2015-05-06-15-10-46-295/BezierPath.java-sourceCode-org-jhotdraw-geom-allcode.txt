org jhotdraw geom import awt * import awt geom * import util * bezier path list< bezier path node> implements shape { C1_MASK = 1 C2_MASK = 2 C1C2_MASK = C1_MASK | C2_MASK private transient general path general path private outer = 1 private is closed node implements cloneable { mask = 0 x = new 3 y = new 3 keep colinear = node { mask = 1 } node node that { set to that } set to node that { this mask = that mask this keep colinear = that keep colinear arraycopy that x 0 this x 0 3 arraycopy that y 0 this y 0 3 } node point2 d c0 { this mask = 0 x 0 = c0 x y 0 = c0 y x 1 = c0 x y 1 = c0 y x 2 = c0 x y 2 = c0 y } node mask point2 d c0 point2 d c1 point2 d c2 { this mask = mask x 0 = c0 x y 0 = c0 y x 1 = c1 x y 1 = c1 y x 2 = c2 x y 2 = c2 y } node x0 y0 { this mask = 0 x 0 = x0 y 0 = y0 x 1 = x0 y 1 = y0 x 2 = x0 y 2 = y0 } node mask x0 y0 x1 y1 x2 y2 { this mask = mask x 0 = x0 y 0 = y0 x 1 = x1 y 1 = y1 x 2 = x2 y 2 = y2 } get mask { mask } set mask new value { mask = new value } set control point index point2 d p { x index = p x y index = p y } point2 d get control point index { new point2 d x index y index } move to point2 d p { move by p x x 0 p y y 0 } move to x y { move by x this x 0 y this y 0 } move by dx dy { for i=0 i < 3 i++ { x i += dx y i += dy } } clone { try { node that = node super clone that x = this x clone that y = this y clone that } catch clone not supported e { internal = new internal init cause e throw } } to { builder buf = new builder buf append ' ' for i=0 i < 3 i++ { if i != 0 { if mask i == i { buf append ' ' } else { continue } } buf append 'x' buf append i buf append '=' buf append x i buf append y buf append i buf append '=' buf append y i } buf append ' ' buf to } } bezier path { } add point2 d c0 { add new node 0 c0 c0 c0 } add point x y { add new node 0 x y x y x y } add mask point2 d c0 point2 d c1 point2 d c2 { add new node mask c0 c1 c2 } set index coord point2 d p { node c = get index c x coord = p x c y coord = p y } point2 d get index coord { node c = get index new point2 d c x coord c y coord } invalidate path { general path = outer = 1 } validate path { if general path == { general path = to general path } } general path to general path { general path gp = new general path gp set winding rule general path WIND_EVEN_ODD if size == 0 { gp move to 0 0 gp line to 0 0 + 1 } else if size == 1 { node current = get 0 gp move to float current x 0 float current y 0 gp line to float current x 0 float current y 0 + 1 } else { node previous node current previous = current = get 0 gp move to float current x 0 float current y 0 for i=1 n = size i < n i++ { previous = current current = get i if previous mask C2_MASK == 0 { if current mask C1_MASK == 0 { gp line to float current x 0 float current y 0 } else { gp quad to float current x 1 float current y 1 float current x 0 float current y 0 } } else { if current mask C1_MASK == 0 { gp quad to float previous x 2 float previous y 2 float current x 0 float current y 0 } else { gp curve to float previous x 2 float previous y 2 float current x 1 float current y 1 float current x 0 float current y 0 } } } if is closed { if size > 1 { previous = get size 1 current = get 0 if previous mask C2_MASK == 0 { if current mask C1_MASK == 0 { gp line to float current x 0 float current y 0 } else { gp quad to float current x 1 float current y 1 float current x 0 float current y 0 } } else { if current mask C1_MASK == 0 { gp quad to float previous x 2 float previous y 2 float current x 0 float current y 0 } else { gp curve to float previous x 2 float previous y 2 float current x 1 float current y 1 float current x 0 float current y 0 } } } gp close path } } gp } contains point2 d p { validate path general path contains p } outline contains point2 d p tolerance { validate path path iterator i = general path get path iterator new affine transform tolerance coords = new 6 type = i current segment coords prev x = coords 0 prev y = coords 1 i next while ! i is done { i current segment coords if geom line contains point prev x prev y coords 0 coords 1 p x p y tolerance { } prev x = coords 0 prev y = coords 1 i next } } intersects rectangle2 d r { validate path general path intersects r } path iterator get path iterator affine transform at { validate path general path get path iterator at } contains rectangle2 d r { validate path general path contains r } path iterator get path iterator affine transform at flatness { validate path general path get path iterator at flatness } intersects x y w h { validate path general path intersects x y w h } rectangle2 d get bounds2 d { validate path general path get bounds2 d } rectangle2 d get bounds2 d { validate path rectangle2 d r = general path get bounds2 d if r instanceof rectangle2 d { rectangle2 d r } else { new rectangle2 d r get x r get y r get width r get height } } rectangle get bounds { validate path general path get bounds } contains x y w h { validate path general path contains x y w h } contains x y { validate path general path contains x y } set closed new value { if is closed != new value { is closed = new value invalidate path } } is closed { is closed } clone { bezier path that = bezier path super clone for i=0 n = this size i < n i++ { that set i node this get i clone } that } transform affine transform tx { point2 d p = new point2 d for node cp this { for i=0 i < 3 i++ { p x = cp x i p y = cp y i tx transform p p cp x i = p x cp y i = p y } } invalidate path } set to bezier path that { while that size < size { remove size 1 } for i=0 n = size i < n i++ { get i set to that get i } while size < that size { add node that get size clone } } point2 d get center { sx = 0 sy = 0 for node p this { sx += p x 0 sy += p y 0 } n = size new point2 d sx / n sy / n } point2 d chop point2 d p { validate path geom chop general path p } index of outermost node { if outer == 1 { point2 d ctr = get center outer = 0 dist = 0 for i = 0 n = size i < n i++ { node cp = get i d = geom length2 ctr x ctr y cp x 0 cp y 0 if d > dist { dist = d outer = i } } } outer } point2 d get point on path relative flatness { if size == 0 { } else if size == 1 { get 0 get control point 0 } if relative <= 0 { get 0 get control point 0 } else if relative >= 1 { get size 1 get control point 0 } validate path len = 0 path iterator i = general path get path iterator new affine transform flatness coords = new 6 type = i current segment coords prev x = coords 0 prev y = coords 1 i next for ! i is done i next { i current segment coords len += geom length prev x prev y coords 0 coords 1 prev x = coords 0 prev y = coords 1 } relative len = len * relative pos = 0 i = general path get path iterator new affine transform flatness type = i current segment coords prev x = coords 0 prev y = coords 1 i next for ! i is done i next { i current segment coords seg len = geom length prev x prev y coords 0 coords 1 if pos + seg len >= relative len { factor = relative len pos / seg len new point2 d prev x * 1 factor + coords 0 * factor prev y * 1 factor + coords 1 * factor } pos += seg len prev x = coords 0 prev y = coords 1 } throw new internal we should never get here } find segment point2 d find float tolerance { node v1 v2 bezier path temp path = new bezier path node t1 t2 temp path add t1 = new node temp path add t2 = new node for i = 0 n = size 1 i < n i++ { v1 = get i v2 = get i+1 if v1 mask == 0 v2 mask == 0 { if geom line contains point v1 x 0 v1 y 0 v2 x 0 v2 y 0 find x find y tolerance { i } } else { t1 set to v1 t2 set to v2 temp path invalidate path if temp path outline contains find tolerance { i } } } if is closed size > 1 { v1 = get size 1 v2 = get 0 if v1 mask == 0 v2 mask == 0 { if geom line contains point v1 x 0 v1 y 0 v2 x 0 v2 y 0 find x find y tolerance { size 1 } } else { t1 set to v1 t2 set to v2 temp path invalidate path if temp path outline contains find tolerance { size 1 } } } 1 } join segments point2 d join float tolerance { for i=0 i < size i++ { node p = get i if geom length p x 0 p y 0 join x join y < tolerance { remove i i } } 1 } split segment point2 d split float tolerance { i = find segment split tolerance next i = i + 1 % size if i != 1 { if get i mask C2_MASK == C2_MASK get next i mask C1_MASK == 0 { add i + 1 new node C2_MASK split split split } else if get i mask C2_MASK == 0 get next i mask C1_MASK == C1_MASK { add i + 1 new node C2_MASK split split split } else if get i mask C2_MASK == C2_MASK get next i mask C1_MASK == C2_MASK { add i + 1 new node C1_MASK | C2_MASK split split split } else { add i + 1 new node split } } i+1 } move to x1 y1 { if size != 0 { throw new illegal path state move to only allowed when empty } add new node x1 y1 } line to x1 y1 { if size == 0 { throw new illegal path state line to only allowed when not empty } add new node x1 y1 } quad to x1 y1 x2 y2 { if size == 0 { throw new illegal path state quad to only allowed when not empty } add new node C1_MASK x2 y2 x1 y1 x2 y2 } curve to x1 y1 x2 y2 x3 y3 { if size == 0 { throw new illegal path state curve to only allowed when not empty } node last point = get size 1 last point mask |= C2_MASK last point x 2 = x1 last point y 2 = y1 add new node C1_MASK x3 y3 x2 y2 x3 y3 } point2 d to polygon { point2 d points = new point2 d size for i=0 n = size i < n i++ { points i = new point2 d get i x 0 get i y 0 } points } } 