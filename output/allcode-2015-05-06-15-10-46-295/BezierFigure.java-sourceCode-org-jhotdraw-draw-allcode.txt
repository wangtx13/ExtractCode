org jhotdraw draw import org jhotdraw util * import awt * import awt event * import awt geom * import util * import javax swing undo * import io * import org jhotdraw draw attribute keys * import org jhotdraw geom * import org jhotdraw xml dom input import org jhotdraw xml dom output bezier figure attributed figure { attribute key< boolean> c l o s e d = new attribute key< boolean> closed bezier path path private transient bezier path capped path bezier figure { this } bezier figure is closed { path = new bezier path c l o s e d set this is closed } connector find connector point2 d p connection figure prototype { new chop bezier connector this } connector find compatible connector connector c is start { new chop bezier connector this } draw stroke graphics2 d g { if is closed { grow = attribute keys get perpendicular draw growth this if grow == 0d { g draw path } else { grow stroke gs = new grow stroke float grow float attribute keys get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this g draw gs create stroked shape path } } else { g draw get capped path } draw caps g } draw caps graphics2 d g { if get point count > 1 { if START_DECORATION get this != { bezier path cp = get capped path point2 d p1 = path get 0 0 point2 d p2 = cp get 0 0 if p2 equals p1 { p2 = path get 1 0 } START_DECORATION get this draw g this p1 p2 } if END_DECORATION get this != { bezier path cp = get capped path point2 d p1 = path get path size 1 0 point2 d p2 = cp get path size 1 0 if p2 equals p1 { p2 = path get path size 2 0 } END_DECORATION get this draw g this p1 p2 } } } draw fill graphics2 d g { if is closed { grow = attribute keys get perpendicular fill growth this if grow == 0d { g fill path } else { grow stroke gs = new grow stroke float grow float attribute keys get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this g fill gs create stroked shape path } } } contains point2 d p { if is closed { grow = attribute keys get perpendicular hit growth this if grow == 0d { path contains p } else { grow stroke gs = new grow stroke float grow float attribute keys get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this gs create stroked shape path contains p } } else { tolerance = math max 2f attribute keys get stroke total width this / 2 if get capped path outline contains p tolerance { } if START_DECORATION get this != { bezier path cp = get capped path point2 d p1 = path get 0 0 point2 d p2 = cp get 0 0 if geom line contains point p1 x p1 y p2 x p2 y p x p y tolerance { } } if END_DECORATION get this != { bezier path cp = get capped path point2 d p1 = path get path size 1 0 point2 d p2 = cp get path size 1 0 if geom line contains point p1 x p1 y p2 x p2 y p x p y tolerance { } } } } can connect { is closed } collection< handle> create handles detail level { linked list< handle> handles = new linked list< handle> switch detail level { case 0 box handle kit add box handles this handles handles add new bezier scale handle this break case 1 for i=0 n = path size i < n i++ { handles add new bezier node handle this i } break } handles } rectangle2 d get bounds { rectangle2 d bounds =path get bounds2 d bounds width = math max 1 bounds width bounds height = math max 1 bounds height bounds } rectangle2 d get figure draw bounds { rectangle2 d r = super get figure draw bounds if get node count > 1 { if START_DECORATION get this != { point2 d p1 = get point 0 0 point2 d p2 = get point 1 0 r add START_DECORATION get this get draw bounds this p1 p2 } if END_DECORATION get this != { point2 d p1 = get point get node count 1 0 point2 d p2 = get point get node count 2 0 r add END_DECORATION get this get draw bounds this p1 p2 } } r } validate { super validate path invalidate path invalidate capped path } bezier path get bezier path { bezier path path clone } point2 d get point on path float relative flatness { path get point on path relative flatness } basic set bezier path bezier path new value { this path = new value this set closed new value is closed } is closed { get attribute c l o s e d } set closed new value { c l o s e d set this new value } basic set attribute attribute key key new value { if key == c l o s e d { path set closed new value } super basic set attribute key new value } basic set bounds point2 d anchor point2 d { basic set start point anchor basic set end point invalidate } basic transform affine transform tx { path transform tx invalidate } invalidate { super invalidate path invalidate path invalidate capped path } invalidate capped path { capped path = } bezier path get capped path { if capped path == { capped path = bezier path path clone if is closed { capped path set closed } else { if capped path size > 1 { if START_DECORATION get this != { bezier path node p0 = capped path get 0 bezier path node p1 = capped path get 1 point2 d pp if p0 get mask bezier path C2_MASK != 0 { pp = p0 get control point 2 } else if p1 get mask bezier path C1_MASK != 0 { pp = p1 get control point 1 } else { pp = p1 get control point 0 } radius = START_DECORATION get this get decoration radius this line length = geom length p0 get control point 0 pp capped path set 0 0 geom cap pp p0 get control point 0 math min radius line length } if END_DECORATION get this != { bezier path node p0 = capped path get capped path size 1 bezier path node p1 = capped path get capped path size 2 point2 d pp if p0 get mask bezier path C1_MASK != 0 { pp = p0 get control point 1 } else if p1 get mask bezier path C2_MASK != 0 { pp = p1 get control point 2 } else { pp = p1 get control point 0 } radius = END_DECORATION get this get decoration radius this line length = geom length p0 get control point 0 pp capped path set capped path size 1 0 geom cap pp p0 get control point 0 math min radius line length } capped path invalidate path } } } capped path } layout { } add node bezier path node p { add node get node count p } add node index bezier path node p { bezier path node new point = new bezier path node p will change basic add node index new point layout changed fire undoable edit happened new undoable edit { get presentation name { punkt einf\u00fcgen } undo cannot undo { super undo will change basic remove node index changed } redo cannot undo { super redo will change basic add node index new point changed } } } basic add node bezier path node p { path add p invalidate } basic add node index bezier path node p { path add index p } set node index bezier path node p { will change bezier path node old value = path get index bezier path node new value = new bezier path node p basic set node index new value changed fire undoable edit happened new bezier node edit this index old value new value } basic set node index bezier path node p { path set index p } bezier path node get node index { bezier path node path get index clone } point2 d get point index { path get index get control point 0 } point2 d get point index coord { path get index get control point coord } set point index coord point2 d p { will change basic set point index coord p changed } basic set point index point2 d p { bezier path node node = path get index dx = p x node x 0 dy = p y node y 0 for i=0 i < node x length i++ { node x i += dx node y i += dy } invalidate } basic set point index coord point2 d p { bezier path node cp = new bezier path node path get index cp set control point coord p basic set node index cp } basic set start point point2 d p { basic set point 0 p } basic set end point point2 d p { basic set point get point count 1 p } point2 d get start point { get point 0 0 } point2 d get end point { get point get node count 1 0 } find node point2 d p { bezier path tp = path for i=0 i < tp size i++ { bezier path node p2 = tp get i if p2 x 0 == p x p2 y 0 == p y { i } } 1 } remove all nodes { will change basic remove all nodes changed } remove node index { bezier path node old point = new bezier path node path get index will change basic remove node index layout changed fire undoable edit happened new undoable edit { get presentation name { punkt entfernen } undo cannot undo { super undo will change basic add node index old point changed } redo cannot undo { super redo basic remove node index changed } } } find segment point2 d find { point2 d p1 p2 for i = 0 n = get node count 1 i < n i++ { p1 = path get i 0 p2 = path get i+1 0 if geom line contains point p1 x p1 y p2 x p2 y find x find y 3d { i } } 1 } basic join segments point2 d join { i = find segment join if i != 1 i > 1 { remove node i } } basic split segment point2 d split { i = find segment split if i != 1 { add node i + 1 new bezier path node split } i+1 } basic remove node index { path remove index } basic remove all nodes { path clear } get node count { path size } get point count { path size } bezier figure clone { bezier figure that = bezier figure super clone that path = bezier path this path clone that invalidate that } restore to geometry { path set to bezier path geometry } get restore data { path clone } point2 d chop point2 d p { if is closed { grow = attribute keys get perpendicular hit growth this if grow == 0d { path chop p } else { grow stroke gs = new grow stroke float grow float attribute keys get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this geom chop gs create stroked shape path p } } else { path chop p } } point2 d get center { path get center } point2 d get outermost point { path get path index of outermost node get control point 0 } basic join segments point2 d join float tolerance { path join segments join tolerance } basic split segment point2 d split float tolerance { path split segment split tolerance } handle mouse click point2 d p mouse event evt drawing view view { if evt get click count == 2 view get handle detail level == 1 { will change index = basic split segment p float 5f / view get scale factor if index != 1 { bezier path node new node = get node index fire undoable edit happened new undoable edit { redo cannot redo { super redo will change basic add node index new node changed } undo cannot undo { super undo will change basic remove node index changed } } changed } } } write dom output out i o { write points out write attributes out } write points dom output out i o { out open element points if is closed { out add attribute closed } for i=0 n = get node count i < n i++ { bezier path node node = get node i out open element p if node mask != 0 { out add attribute mask node mask } if ! node keep colinear { out add attribute colinear } out add attribute x node x 0 out add attribute y node y 0 if node x 1 != node x 0 || node y 1 != node y 0 { out add attribute c1x node x 1 out add attribute c1y node y 1 } if node x 2 != node x 0 || node y 2 != node y 0 { out add attribute c2x node x 2 out add attribute c2y node y 2 } out close element } out close element } @ override read dom input in i o { read points in read attributes in } read points dom input in i o { path clear in open element points set closed in get attribute closed for i=0 n = in get element count p i < n i++ { in open element p i bezier path node node = new bezier path node in get attribute mask 0 in get attribute x 0d in get attribute y 0d in get attribute c1x in get attribute x 0d in get attribute c1y in get attribute y 0d in get attribute c2x in get attribute x 0d in get attribute c2y in get attribute y 0d node keep colinear = in get attribute colinear path add node path invalidate path in close element } in close element } } 