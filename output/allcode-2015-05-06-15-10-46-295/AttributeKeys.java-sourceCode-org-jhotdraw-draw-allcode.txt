org jhotdraw draw import awt * import util * import org jhotdraw geom * attribute keys { attribute key< color> FILL_COLOR = new attribute key< color> fill color color white enum winding rule { EVEN_ODD NON_ZERO } attribute key< winding rule> WINDING_RULE = new attribute key< winding rule> winding rule winding rule EVEN_ODD enum underfill { n o n e c e n t e r f u l l } attribute key< underfill> FILL_UNDER_STROKE = new attribute key< underfill> fill under stroke underfill c e n t e r attribute key< color> STROKE_COLOR = new attribute key< color> stroke color color black attribute key< double> STROKE_WIDTH = new attribute key< double> stroke width 1d attribute key< double> STROKE_INNER_WIDTH_FACTOR = new attribute key< double> inner stroke width factor 2d attribute key< integer> STROKE_JOIN = new attribute key< integer> stroke join basic stroke JOIN_MITER attribute key< integer> STROKE_CAP = new attribute key< integer> stroke cap basic stroke CAP_BUTT attribute key< double> STROKE_MITER_LIMIT_FACTOR = new attribute key< double> stroke miter limit factor 3d attribute key<double > STROKE_DASHES = new attribute key<double > stroke dashes attribute key< double> STROKE_DASH_PHASE = new attribute key< double> stroke dash phase 0d attribute key< double> STROKE_DASH_FACTOR = new attribute key< double> stroke dash factor enum stroke type { b a s i c d o u b l e } attribute key< stroke type> STROKE_TYPE = new attribute key< stroke type> stroke type stroke type b a s i c enum stroke placement { c e n t e r i n sid e o u t sid e } attribute key< stroke placement> STROKE_PLACEMENT = new attribute key< stroke placement> stroke placement stroke placement c e n t e r attribute key< string> t e x t = new attribute key< string> text attribute key< color> TEXT_COLOR = new attribute key< color> text color color black attribute key< color> TEXT_SHADOW_COLOR = new attribute key< color> text shadow color attribute key< dimension2 d double> TEXT_SHADOW_OFFSET = new attribute key< dimension2 d double> text shadow offset new dimension2 d 1d 1d attribute key< font> FONT_FACE = new attribute key< font> font face new font v e r d a n a font p l a i n 10 attribute key< double> FONT_SIZE = new attribute key< double> font size 12d attribute key< boolean> FONT_BOLD = new attribute key< boolean> font bold attribute key< boolean> FONT_ITALIC = new attribute key< boolean> font italic attribute key< boolean> FONT_UNDERLINED = new attribute key< boolean> font underlined attribute key< liner> BEZIER_PATH_LAYOUTER = new attribute key< liner> bezier path layouter attribute key< line decoration> END_DECORATION = new attribute key< line decoration> end decoration attribute key< line decoration> START_DECORATION = new attribute key< line decoration> start decoration attribute key< insets2 d double> DECORATOR_INSETS = new attribute key< insets2 d double> decorator insets new insets2 d 0 0 0 0 attribute key< insets2 d double> LAYOUT_INSETS = new attribute key< insets2 d double> border insets new insets2 d 0 0 0 0 enum orientation { n o r t h NORTH_EAST e a s t SOUTH_EAST s o u t h SOUTH_WEST w e s t NORTH_WEST } attribute key< orientation> o r i e n t a t i o n = new attribute key< orientation> orientation orientation n o r t h set< attribute key> supported attributes map< attribute key> supported attribute map { hash set< attribute key> as = new hash set< attribute key> as add all arrays as list new attribute key { FILL_COLOR FILL_UNDER_STROKE STROKE_COLOR STROKE_WIDTH STROKE_INNER_WIDTH_FACTOR STROKE_JOIN STROKE_CAP STROKE_MITER_LIMIT_FACTOR STROKE_DASHES STROKE_DASH_PHASE STROKE_TYPE STROKE_PLACEMENT t e x t TEXT_COLOR TEXT_SHADOW_COLOR TEXT_SHADOW_OFFSET FONT_FACE FONT_SIZE FONT_BOLD FONT_ITALIC FONT_UNDERLINED BEZIER_PATH_LAYOUTER END_DECORATION START_DECORATION DECORATOR_INSETS o r i e n t a t i o n WINDING_RULE } supported attributes = collections unmodifiable set as hash map< attribute key> am = new hash map< attribute key> for attribute key a as { am put a get key a } supported attribute map = collections unmodifiable map am } get stroke total width figure f { switch STROKE_TYPE get f { case b a s i c default STROKE_WIDTH get f case d o u b l e STROKE_WIDTH get f * 1d + STROKE_INNER_WIDTH_FACTOR get f } } stroke get stroke figure f { stroke width = STROKE_WIDTH get f dash factor = STROKE_DASH_FACTOR get f != ? STROKE_DASH_FACTOR get f stroke width ddashes = STROKE_DASHES get f float dashes = if ddashes != { dashes = new float ddashes length for i=0 i < dashes length i++ { dashes i = float ddashes i * dash factor } } switch STROKE_TYPE get f { case b a s i c default new basic stroke float stroke width basic stroke CAP_BUTT STROKE_JOIN get f math max 1f float STROKE_MITER_LIMIT_FACTOR get f * stroke width dashes float STROKE_DASH_PHASE get f * dash factor case d o u b l e new stroke float STROKE_INNER_WIDTH_FACTOR get f * stroke width float stroke width basic stroke CAP_BUTT STROKE_JOIN get f math max 1f float STROKE_MITER_LIMIT_FACTOR get f * stroke width dashes float STROKE_DASH_PHASE get f float value * dash factor } } font get font figure f { font prototype = FONT_FACE get f if prototype == { } if get font style f != font p l a i n { prototype derive font get font style f FONT_SIZE get f float value } else { prototype derive font FONT_SIZE get f float value } } get font style figure f { style = font p l a i n if FONT_BOLD get f style |= font b o l d if FONT_ITALIC get f style |= font i t a l i c style } get perpendicular fill growth figure f { grow stroke width = attribute keys get stroke total width f stroke placement placement = STROKE_PLACEMENT get f switch FILL_UNDER_STROKE get f { case f u l l switch placement { case i n sid e grow = 0f break case o u t sid e grow = stroke width break case c e n t e r default grow = stroke width / 2d break } break case n o n e switch placement { case i n sid e grow = stroke width break case o u t sid e grow = 0f break case c e n t e r default grow = stroke width / 2d break } break case c e n t e r default switch placement { case i n sid e grow = stroke width / 2d break case o u t sid e grow = stroke width / 2d break case c e n t e r default grow = 0d break } break } grow } get perpendicular draw growth figure f { grow stroke width = attribute keys get stroke total width f stroke placement placement = STROKE_PLACEMENT get f switch placement { case i n sid e grow = stroke width / 2d break case o u t sid e grow = stroke width / 2d break case c e n t e r default grow = 0f break } grow } get perpendicular hit growth figure f { grow if STROKE_COLOR get f == { grow = get perpendicular fill growth f } else { stroke width = attribute keys get stroke total width f grow = get perpendicular draw growth f + stroke width / 2d } grow } } 