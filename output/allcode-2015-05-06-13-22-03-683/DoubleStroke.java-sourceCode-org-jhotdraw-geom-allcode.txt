org jhotdraw geom import awt * import awt geom * import awt font * DoubleStroke stroke implements stroke { private BasicStroke basic stroke outlineStroke outline stroke private float innerWidth inner width private float outlineWidth outline width private miterLimit miter limit private float dashes private float dashPhase dash phase DoubleStroke stroke float innerWidth inner width float outlineWidth outline width { this innerWidth inner width outlineWidth outline width BasicStroke basic stroke CAP_SQUARE BasicStroke basic stroke JOIN_BEVEL 10f 0f } DoubleStroke stroke float innerWidth inner width float outlineWidth outline width cap join float miterLimit miter limit float dashes float dashPhase dash phase { this innerWidth inner width = innerWidth inner width this outlineWidth outline width = outlineWidth outline width this miterLimit miter limit = miterLimit miter limit outlineStroke outline stroke = new BasicStroke basic stroke outlineWidth outline width cap BasicStroke basic stroke JOIN_BEVEL miterLimit miter limit dashes dashPhase dash phase } shape createStrokedShape create stroked shape shape { BezierPath bezier path bp = new BezierPath bezier path GeneralPath general path left = new GeneralPath general path GeneralPath general path right = new GeneralPath general path coords = new 6 for PathIterator path iterator = getPathIterator get path iterator 0 1d ! isDone done next { type = currentSegment current segment coords switch type { case PathIterator path iterator SEG_MOVETO if bp size != 0 { traceStroke trace stroke bp left right } bp clear bp setClosed set closed bp moveTo move to coords 0 coords 1 break case PathIterator path iterator SEG_LINETO if coords 0 != bp get bp size 1 0 || coords 1 != bp get bp size 1 0 { bp lineTo line to coords 0 coords 1 } break case PathIterator path iterator SEG_QUADTO bp quadTo quad to coords 0 coords 1 coords 2 coords 3 break case PathIterator path iterator SEG_CUBICTO bp curveTo curve to coords 0 coords 1 coords 2 coords 3 coords 4 coords 5 break case PathIterator path iterator SEG_CLOSE bp setClosed set closed break } } if bp size != 0 { traceStroke trace stroke bp left right } right append left outlineStroke outline stroke createStrokedShape create stroked shape right } traceStroke trace stroke BezierPath bezier path bp GeneralPath general path left GeneralPath general path right { currentCorners current corners = new 8 prevCorners prev corners = new 8 Point2D point2 intersect if bp isClosed closed { BezierPath bezier path node prev = bp get bp size 1 for i=0 < bp size i++ { BezierPath bezier path node node = bp get if prev 0 == node 0 prev 0 == node 0 { bp remove } else { prev = node } } } else { BezierPath bezier path node prev = bp get 0 for i=1 < bp size i++ { BezierPath bezier path node node = bp get if prev 0 == node 0 prev 0 == node 0 { bp remove } else { prev = node } } } if bp isClosed closed bp size > 1 { prevCorners prev corners = computeThickLine compute thick line bp get bp size 1 0 bp get bp size 1 0 bp get 0 0 bp get 0 0 innerWidth inner width prevCorners prev corners currentCorners current corners = computeThickLine compute thick line bp get 0 0 bp get 0 0 bp get 1 0 bp get 1 0 innerWidth inner width currentCorners current corners intersect = geom intersect prevCorners prev corners 0 prevCorners prev corners 1 prevCorners prev corners 4 prevCorners prev corners 5 currentCorners current corners 0 currentCorners current corners 1 currentCorners current corners 4 currentCorners current corners 5 miterLimit miter limit if intersect != { right moveTo move to float intersect float intersect } else { right moveTo move to float prevCorners prev corners 4 float prevCorners prev corners 5 right lineTo line to float currentCorners current corners 0 float currentCorners current corners 1 } intersect = geom intersect prevCorners prev corners 2 prevCorners prev corners 3 prevCorners prev corners 6 prevCorners prev corners 7 currentCorners current corners 2 currentCorners current corners 3 currentCorners current corners 6 currentCorners current corners 7 miterLimit miter limit if intersect != { left moveTo move to float intersect float intersect } else { left moveTo move to float prevCorners prev corners 6 float prevCorners prev corners 7 left lineTo line to float currentCorners current corners 2 float currentCorners current corners 3 } } else { if bp size > 1 { currentCorners current corners = computeThickLine compute thick line bp get 0 0 bp get 0 0 bp get 1 0 bp get 1 0 innerWidth inner width currentCorners current corners right moveTo move to float currentCorners current corners 0 float currentCorners current corners 1 left moveTo move to float currentCorners current corners 2 float currentCorners current corners 3 } } for i=1 = bp size 1 < i++ { tmp = prevCorners prev corners prevCorners prev corners = currentCorners current corners currentCorners current corners = computeThickLine compute thick line bp get 0 bp get 0 bp get i+1 0 bp get i+1 0 innerWidth inner width tmp intersect = geom intersect prevCorners prev corners 0 prevCorners prev corners 1 prevCorners prev corners 4 prevCorners prev corners 5 currentCorners current corners 0 currentCorners current corners 1 currentCorners current corners 4 currentCorners current corners 5 miterLimit miter limit if intersect != { right lineTo line to float intersect float intersect } else { right lineTo line to float prevCorners prev corners 4 float prevCorners prev corners 5 right lineTo line to float currentCorners current corners 0 float currentCorners current corners 1 } intersect = geom intersect prevCorners prev corners 2 prevCorners prev corners 3 prevCorners prev corners 6 prevCorners prev corners 7 currentCorners current corners 2 currentCorners current corners 3 currentCorners current corners 6 currentCorners current corners 7 miterLimit miter limit if intersect != { left lineTo line to float intersect float intersect } else { left lineTo line to float prevCorners prev corners 6 float prevCorners prev corners 7 left lineTo line to float currentCorners current corners 2 float currentCorners current corners 3 } } if bp isClosed closed { tmp = prevCorners prev corners prevCorners prev corners = currentCorners current corners currentCorners current corners = computeThickLine compute thick line bp get bp size 1 0 bp get bp size 1 0 bp get 0 0 bp get 0 0 innerWidth inner width tmp intersect = geom intersect prevCorners prev corners 0 prevCorners prev corners 1 prevCorners prev corners 4 prevCorners prev corners 5 currentCorners current corners 0 currentCorners current corners 1 currentCorners current corners 4 currentCorners current corners 5 miterLimit miter limit if intersect != { right lineTo line to float intersect float intersect } else { right lineTo line to float prevCorners prev corners 4 float prevCorners prev corners 5 right lineTo line to float currentCorners current corners 0 float currentCorners current corners 1 } intersect = geom intersect prevCorners prev corners 2 prevCorners prev corners 3 prevCorners prev corners 6 prevCorners prev corners 7 currentCorners current corners 2 currentCorners current corners 3 currentCorners current corners 6 currentCorners current corners 7 miterLimit miter limit if intersect != { left lineTo line to float intersect float intersect } else { left lineTo line to float prevCorners prev corners 6 float prevCorners prev corners 7 left lineTo line to float currentCorners current corners 2 float currentCorners current corners 3 } right closePath close path left closePath close path } else { right lineTo line to float currentCorners current corners 4 float currentCorners current corners 5 left lineTo line to float currentCorners current corners 6 float currentCorners current corners 7 } } private computeThickLine compute thick line seg offset corners { computeThickLine compute thick line seg 0+offset seg 1+offset seg 2+offset seg 3+offset innerWidth inner width corners } private computeThickLine compute thick line x1 y1 x2 y2 thickness corners { dx = x2 x1 dy = y2 y1 lineLength line length = math sqrt dx * dx + dy * dy scale = thickness / 2d * lineLength line length ddx = scale * dy ddy = scale * dx corners 0 = x1 + ddx corners 1 = y1 + ddy corners 2 = x1 ddx corners 3 = y1 ddy corners 4 = x2 + ddx corners 5 = y2 + ddy corners 6 = x2 ddx corners 7 = y2 ddy corners } } 