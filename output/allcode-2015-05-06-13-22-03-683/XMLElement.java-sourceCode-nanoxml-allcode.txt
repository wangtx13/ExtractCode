nanoxml import * import util * XMLElement xml element { long serialVersionUID serial uid = 6685035139346394777L 6685035139346394777 NANOXML_MAJOR_VERSION = 2 NANOXML_MINOR_VERSION = 2 private HashMap hash map attributes private ArrayList list children private private contents private HashMap hash map entities private lineNr line nr private ignoreCase ignore case private ignoreWhitespace ignore whitespace private char charReadTooMuch char read too much private reader reader private parserLineNr parser line nr private isEncodeUnicodeCharacters encode unicode characters = XMLElement xml element { this new HashMap hash map } XMLElement xml element HashMap hash map entities { this entities } XMLElement xml element skipLeadingWhitespace skip leading whitespace { this new HashMap hash map skipLeadingWhitespace skip leading whitespace } XMLElement xml element HashMap hash map entities skipLeadingWhitespace skip leading whitespace { this entities skipLeadingWhitespace skip leading whitespace } XMLElement xml element HashMap hash map entities skipLeadingWhitespace skip leading whitespace ignoreCase ignore case { this entities skipLeadingWhitespace skip leading whitespace ignoreCase ignore case } XMLElement xml element HashMap hash map entities skipLeadingWhitespace skip leading whitespace fillBasicConversionTable fill basic conversion table ignoreCase ignore case { this entities skipLeadingWhitespace skip leading whitespace fillBasicConversionTable fill basic conversion table ignoreCase ignore case } XMLElement xml element HashMap hash map entities skipLeadingWhitespace skip leading whitespace fillBasicConversionTable fill basic conversion table ignoreCase ignore case encodeUnicodeCharacters encode unicode characters { this ignoreWhitespace ignore whitespace = skipLeadingWhitespace skip leading whitespace this ignoreCase ignore case = ignoreCase ignore case this = this contents = this attributes = new HashMap hash map this children = new ArrayList list this entities = entities this lineNr line nr = 0 this isEncodeUnicodeCharacters encode unicode characters = encodeUnicodeCharacters encode unicode characters iterator iter = this entities keySet key set iterator while iter hasNext has next { key = iter next value = this entities get key if value instanceof { value = value toCharArray to char this entities put key value } } if fillBasicConversionTable fill basic conversion table { this entities put amp new char { ' ' } this entities put new char { ' ' } this entities put apos new char { '\'' } this entities put lt new char { '<' } this entities put new char { '>' } } } addChild add child XMLElement xml element child { this children add child } setAttribute set attribute value { if this ignoreCase ignore case { = toUpperCase to upper case } this attributes put value toString to } setIntAttribute set attribute value { if this ignoreCase ignore case { = toUpperCase to upper case } this attributes put integer toString to value } setDoubleAttribute set attribute value { if this ignoreCase ignore case { = toUpperCase to upper case } this attributes put toString to value } countChildren count children { this children size } iterator enumerateAttributeNames enumerate attribute names { this attributes keySet key set iterator } iterator iterateChildren iterate children { this children iterator } ArrayList list getChildren get children { try { ArrayList list this children clone } catch { } } getContent get content { this contents } getLineNr get line nr { this lineNr line nr } getAttribute get attribute { this getAttribute get attribute } getAttribute get attribute defaultValue default value { if this ignoreCase ignore case { = toUpperCase to upper case } value = this attributes get if value == { value = defaultValue default value } value } getAttribute get attribute map valueSet value set defaultKey default key allowLiterals allow literals { if this ignoreCase ignore case { = toUpperCase to upper case } key = this attributes get result if key == { key = defaultKey default key } result = valueSet value set get key if result == { if allowLiterals allow literals { result = key } else { this invalidValue invalid value key } } result } getStringAttribute get attribute { this getStringAttribute get attribute } getStringAttribute get attribute defaultValue default value { this getAttribute get attribute defaultValue default value } getStringAttribute get attribute HashMap hash map valueSet value set defaultKey default key allowLiterals allow literals { this getAttribute get attribute valueSet value set defaultKey default key allowLiterals allow literals } getIntAttribute get attribute { this getIntAttribute get attribute 0 } getIntAttribute get attribute defaultValue default value { if this ignoreCase ignore case { = toUpperCase to upper case } value = this attributes get if value == { defaultValue default value } else { try { integer parseInt parse value } catch NumberFormatException number format { this invalidValue invalid value value } } } getIntAttribute get attribute min max defaultValue default value { = getIntAttribute get attribute defaultValue default value if < min min if > max max } getIntAttribute get attribute HashMap hash map valueSet value set defaultKey default key allowLiteralNumbers allow literal numbers { if this ignoreCase ignore case { = toUpperCase to upper case } key = this attributes get integer result if key == { key = defaultKey default key } try { result = integer valueSet value set get key } catch ClassCastException cast { this invalidValueSet invalid value set } if result == { if ! allowLiteralNumbers allow literal numbers { this invalidValue invalid value key } try { result = integer valueOf value of key } catch NumberFormatException number format { this invalidValue invalid value key } } result intValue value } getDoubleAttribute get attribute { this getDoubleAttribute get attribute 0 } getDoubleAttribute get attribute defaultValue default value { if this ignoreCase ignore case { = toUpperCase to upper case } value = this attributes get if value == { defaultValue default value } else { try { valueOf value of value doubleValue value } catch NumberFormatException number format { this invalidValue invalid value value } } } getDoubleAttribute get attribute HashMap hash map valueSet value set defaultKey default key allowLiteralNumbers allow literal numbers { if this ignoreCase ignore case { = toUpperCase to upper case } key = this attributes get result if key == { key = defaultKey default key } try { result = valueSet value set get key } catch ClassCastException cast { this invalidValueSet invalid value set } if result == { if ! allowLiteralNumbers allow literal numbers { this invalidValue invalid value key } try { result = valueOf value of key } catch NumberFormatException number format { this invalidValue invalid value key } } result doubleValue value } getBooleanAttribute get attribute trueValue value falseValue value defaultValue default value { if this ignoreCase ignore case { = toUpperCase to upper case } value = this attributes get if value == { defaultValue default value } else if value equals trueValue value { } else if value equals falseValue value { } else { this invalidValue invalid value value } } getBooleanAttribute get attribute defaultValue default value { getBooleanAttribute get attribute defaultValue default value } getName get { this } parseFromReader parse from reader reader reader IOException XMLParseException xml parse { this parseFromReader parse from reader reader 1 } parseFromReader parse from reader reader reader startingLineNr starting line nr IOException XMLParseException xml parse { this = this contents = this attributes = new HashMap hash map this children = new ArrayList list this charReadTooMuch char read too much = '\0' this reader = reader this parserLineNr parser line nr = startingLineNr starting line nr for { char ch = this scanWhitespace scan whitespace if ch != '<' { this expectedInput expected input < } ch = this readChar read char if ch == '!' || ch == '?' { this skipSpecialTag skip special tag 0 } else { this unreadChar unread char ch this scanElement scan element this } } } parseString parse XMLParseException xml parse { try { this parseFromReader parse from reader new StringReader reader 1 } catch IOException { } } parseString parse offset XMLParseException xml parse { this parseString parse substring offset } parseString parse offset XMLParseException xml parse { this parseString parse substring offset } parseString parse offset startingLineNr starting line nr XMLParseException xml parse { = substring offset try { this parseFromReader parse from reader new StringReader reader startingLineNr starting line nr } catch IOException { } } parseCharArray parse char char input offset XMLParseException xml parse { this parseCharArray parse char input offset 1 } parseCharArray parse char char input offset startingLineNr starting line nr XMLParseException xml parse { try { reader reader = new CharArrayReader char reader input offset this parseFromReader parse from reader reader startingLineNr starting line nr } catch IOException { } } removeChild remove child XMLElement xml element child { this children remove child } removeAttribute remove attribute { if this ignoreCase ignore case { = toUpperCase to upper case } this attributes remove } XMLElement xml element createElement create element { XMLElement xml element elem = createElement create element elem setName set elem } XMLElement xml element createElement create element { new XMLElement xml element this entities this ignoreWhitespace ignore whitespace this ignoreCase ignore case this isEncodeUnicodeCharacters encode unicode characters } setContent set content content { this contents = content } setName set { this = } toString to { try { ByteArrayOutputStream byte output stream out = new ByteArrayOutputStream byte output stream OutputStreamWriter output stream writer writer = new OutputStreamWriter output stream writer out this write writer writer flush new out toByteArray to byte } catch IOException { super toString to } } write writer writer IOException { if this == { this writeEncoded write encoded writer this contents } writer write '<' writer write this if ! this attributes isEmpty empty { iterator iter = this attributes keySet key set iterator while iter hasNext has next { writer write ' ' key = iter next value = this attributes get key writer write key writer write '=' writer write ' ' this writeEncoded write encoded writer value writer write ' ' } } if this contents != this contents length > 0 { writer write '>' this writeEncoded write encoded writer this contents writer write '<' writer write '/' writer write this writer write '>' } else if this children isEmpty empty { writer write '/' writer write '>' } else { writer write '>' iterator iter = this iterateChildren iterate children while iter hasNext has next { XMLElement xml element child = XMLElement xml element iter next child write writer } writer write '<' writer write '/' writer write this writer write '>' } } PrintWriter writer writer { writer 0 } PrintWriter writer writer indent { try { if this == { this writeEncoded write encoded writer this contents } char spaces = new char indent * 2 arrays fill spaces ' ' writer write spaces writer write '<' writer write this if ! this attributes isEmpty empty { iterator enm = this attributes keySet key set iterator while enm hasNext has next { writer write ' ' key = enm next value = this attributes get key writer write key writer write '=' writer write ' ' this writeEncoded write encoded writer value writer write ' ' } } if this contents != this contents length > 0 { writer write '>' this writeEncoded write encoded writer this contents writer write '<' writer write '/' writer write this writer write '>' } else if this children isEmpty empty { writer write '/' writer write '>' } else { writer write '>' writer write '\n' iterator enm = this getChildren get children iterator while enm hasNext has next { XMLElement xml element child = XMLElement xml element enm next child writer indent + 1 } writer write spaces writer write '<' writer write '/' writer write this writer write '>' } writer write '\n' } catch IOException { InternalError internal = new InternalError internal getMessage get message initCause init cause } } writeEncoded write encoded writer writer IOException { for = 0 < length += 1 { char ch = charAt char switch ch { case '<' writer write ' ' writer write 'l' writer write 't' writer write ' ' break case '>' writer write ' ' writer write 'g' writer write 't' writer write ' ' break case ' ' writer write ' ' writer write 'a' writer write 'm' writer write 'p' writer write ' ' break case ' ' writer write ' ' writer write 'q' writer write 'u' writer write 'o' writer write 't' writer write ' ' break case '\'' writer write ' ' writer write 'a' writer write 'p' writer write 'o' writer write 's' writer write ' ' break default unicode = ch if unicode < 32 || isEncodeUnicodeCharacters encode unicode characters unicode > 126 { writer write ' ' writer write '#' writer write 'x' writer write integer toString to unicode 16 writer write ' ' } else { writer write ch } } } } scanIdentifier scan identifier StringBuffer buffer result IOException { for { char ch = this readChar read char if ch < 'A' ' a' || ch > 'Z' ' z' ch < 'a' || ch > 'z' ch < '0' || ch > '9' ch != '_' ch != ' ' ch != ' ' ch != ' ' ch <= '\u007E' '\u007 e' { this unreadChar unread char ch } result append ch } } char scanWhitespace scan whitespace IOException { for { char ch = this readChar read char switch ch { case ' ' case '\t' case '\n' case '\r' break default ch } } } char scanWhitespace scan whitespace StringBuffer buffer result IOException { for { char ch = this readChar read char switch ch { case ' ' case '\t' case '\n' result append ch case '\r' break default ch } } } scanString scan StringBuffer buffer IOException { char delimiter = this readChar read char if delimiter != '\'' delimiter != ' ' { this expectedInput expected input ' \ } for { char ch = this readChar read char if ch == delimiter { } else if ch == ' ' { this resolveEntity resolve entity } else { append ch } } } scanPCData scan data StringBuffer buffer data IOException { for { char ch = this readChar read char if ch == '<' { ch = this readChar read char if ch == '!' { this checkCDATA check data } else { this unreadChar unread char ch } } else if ch == ' ' { this resolveEntity resolve entity data } else { data append ch } } } checkCDATA check StringBuffer buffer buf IOException { char ch = this readChar read char if ch != ' ' { this unreadChar unread char ch this skipSpecialTag skip special tag 0 } else if ! this checkLiteral check literal CDATA { this skipSpecialTag skip special tag 1 } else { delimiterCharsSkipped delimiter chars skipped = 0 while delimiterCharsSkipped delimiter chars skipped < 3 { ch = this readChar read char switch ch { case ' ' if delimiterCharsSkipped delimiter chars skipped < 2 { delimiterCharsSkipped delimiter chars skipped += 1 } else { buf append ' ' buf append ' ' delimiterCharsSkipped delimiter chars skipped = 0 } break case '>' if delimiterCharsSkipped delimiter chars skipped < 2 { for = 0 < delimiterCharsSkipped delimiter chars skipped i++ { buf append ' ' } delimiterCharsSkipped delimiter chars skipped = 0 buf append '>' } else { delimiterCharsSkipped delimiter chars skipped = 3 } break default for = 0 < delimiterCharsSkipped delimiter chars skipped += 1 { buf append ' ' } buf append ch delimiterCharsSkipped delimiter chars skipped = 0 } } } } skipComment skip comment IOException { dashesToRead dashes to read = 2 while dashesToRead dashes to read > 0 { char ch = this readChar read char if ch == ' ' { dashesToRead dashes to read = 1 } else { dashesToRead dashes to read = 2 } } if this readChar read char != '>' { this expectedInput expected input > } } skipSpecialTag skip special tag bracketLevel bracket level IOException { tagLevel tag level = 1 char stringDelimiter delimiter = '\0' if bracketLevel bracket level == 0 { char ch = this readChar read char if ch == ' ' { bracketLevel bracket level += 1 } else if ch == ' ' { ch = this readChar read char if ch == ' ' { bracketLevel bracket level += 1 } else if ch == ' ' { bracketLevel bracket level = 1 } else if ch == ' ' { this skipComment skip comment } } } while tagLevel tag level > 0 { char ch = this readChar read char if stringDelimiter delimiter == '\0' { if ch == ' ' || ch == '\'' { stringDelimiter delimiter = ch } else if bracketLevel bracket level <= 0 { if ch == '<' { tagLevel tag level += 1 } else if ch == '>' { tagLevel tag level = 1 } } if ch == ' ' { bracketLevel bracket level += 1 } else if ch == ' ' { bracketLevel bracket level = 1 } } else { if ch == stringDelimiter delimiter { stringDelimiter delimiter = '\0' } } } } checkLiteral check literal literal IOException { length = literal length for = 0 < length += 1 { if this readChar read char != literal charAt char { } } } char readChar read char IOException { if this charReadTooMuch char read too much != '\0' { char ch = this charReadTooMuch char read too much this charReadTooMuch char read too much = '\0' ch } else { = this reader read if < 0 { this unexpectedEndOfData unexpected of data } else if == 10 { this parserLineNr parser line nr += 1 '\n' } else { char } } } scanElement scan element XMLElement xml element elt IOException { StringBuffer buffer buf = new StringBuffer buffer this scanIdentifier scan identifier buf = buf toString to elt setName set char ch = this scanWhitespace scan whitespace while ch != '>' ch != '/' { buf setLength set length 0 this unreadChar unread char ch this scanIdentifier scan identifier buf key = buf toString to ch = this scanWhitespace scan whitespace if ch != '=' { this expectedInput expected input = } this unreadChar unread char this scanWhitespace scan whitespace buf setLength set length 0 this scanString scan buf elt setAttribute set attribute key buf ch = this scanWhitespace scan whitespace } if ch == '/' { ch = this readChar read char if ch != '>' { this expectedInput expected input > } } buf setLength set length 0 ch = this scanWhitespace scan whitespace buf if ch != '<' { this unreadChar unread char ch this scanPCData scan data buf } else { for { ch = this readChar read char if ch == '!' { if this checkCDATA check buf { this scanPCData scan data buf break } else { ch = this scanWhitespace scan whitespace buf if ch != '<' { this unreadChar unread char ch this scanPCData scan data buf break } } } else { if ch != '/' || this ignoreWhitespace ignore whitespace { buf setLength set length 0 } if ch == '/' { this unreadChar unread char ch } break } } } if buf length == 0 { while ch != '/' { if ch == '!' { ch = this readChar read char if ch != ' ' { this expectedInput expected input comment element } ch = this readChar read char if ch != ' ' { this expectedInput expected input comment element } this skipComment skip comment } else { this unreadChar unread char ch XMLElement xml element child = this createElement create element this scanElement scan element child elt addChild add child child } ch = this scanWhitespace scan whitespace if ch != '<' { this expectedInput expected input < } ch = this readChar read char } this unreadChar unread char ch } else { if this ignoreWhitespace ignore whitespace { elt setContent set content buf toString to trim } else { elt setContent set content buf toString to } } ch = this readChar read char if ch != '/' { this expectedInput expected input / } this unreadChar unread char this scanWhitespace scan whitespace if ! this checkLiteral check literal { this expectedInput expected input } if this scanWhitespace scan whitespace != '>' { this expectedInput expected input > } } resolveEntity resolve entity StringBuffer buffer buf IOException { char ch = '\0' StringBuffer buffer keyBuf key buf = new StringBuffer buffer for { ch = this readChar read char if ch == ' ' { break } keyBuf key buf append ch } key = keyBuf key buf toString to if key charAt char 0 == '#' { try { if key charAt char 1 == 'x' { ch = char integer parseInt parse key substring 2 16 } else { ch = char integer parseInt parse key substring 1 10 } } catch NumberFormatException number format { this unknownEntity unknown entity key } buf append ch } else { char value = char this entities get key if value == { this unknownEntity unknown entity key } buf append value } } unreadChar unread char char ch { this charReadTooMuch char read too much = ch } XMLParseException xml parse invalidValueSet invalid value set { msg = invalid value set entity = \ + + \ new XMLParseException xml parse this getName get this parserLineNr parser line nr msg } XMLParseException xml parse invalidValue invalid value value { msg = attribute \ + + \ does not contain valid + value \ + value + \ new XMLParseException xml parse this getName get this parserLineNr parser line nr msg } XMLParseException xml parse unexpectedEndOfData unexpected of data { msg = unexpected of data reached new XMLParseException xml parse this getName get this parserLineNr parser line nr msg } XMLParseException xml parse syntaxError syntax context { msg = syntax while parsing + context new XMLParseException xml parse this getName get this parserLineNr parser line nr msg } XMLParseException xml parse expectedInput expected input charSet char set { msg = expected + charSet char set new XMLParseException xml parse this getName get this parserLineNr parser line nr msg } XMLParseException xml parse unknownEntity unknown entity { msg = unknown invalid entity + + new XMLParseException xml parse this getName get this parserLineNr parser line nr msg } } 