org jhotdraw draw import org jhotdraw util * import awt * import awt event * import awt geom * import util * import javax swing undo * import * import org jhotdraw draw AttributeKeys attribute keys * import org jhotdraw geom * import org jhotdraw xml DOMInput dom input import org jhotdraw xml DOMOutput dom output BezierFigure bezier figure AttributedFigure attributed figure { AttributeKey<Boolean> attribute key< boolean> CLOSED = new AttributeKey<Boolean> attribute key< boolean> closed BezierPath bezier path path private transient BezierPath bezier path cappedPath capped path BezierFigure bezier figure { this } BezierFigure bezier figure isClosed closed { path = new BezierPath bezier path CLOSED set this isClosed closed } connector findConnector find connector Point2D point2 ConnectionFigure connection figure prototype { new ChopBezierConnector chop bezier connector this } connector findCompatibleConnector find compatible connector connector isStart start { new ChopBezierConnector chop bezier connector this } drawStroke draw stroke Graphics2D graphics2 { if isClosed closed { grow = AttributeKeys attribute keys getPerpendicularDrawGrowth get perpendicular draw growth this if grow == 0d { draw path } else { GrowStroke grow stroke gs = new GrowStroke grow stroke float grow float AttributeKeys attribute keys getStrokeTotalWidth get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this draw gs createStrokedShape create stroked shape path } } else { draw getCappedPath get capped path } drawCaps draw caps } drawCaps draw caps Graphics2D graphics2 { if getPointCount get point count > 1 { if START_DECORATION get this != { BezierPath bezier path cp = getCappedPath get capped path Point2D point2 p1 = path get 0 0 Point2D point2 p2 = cp get 0 0 if p2 equals p1 { p2 = path get 1 0 } START_DECORATION get this draw this p1 p2 } if END_DECORATION get this != { BezierPath bezier path cp = getCappedPath get capped path Point2D point2 p1 = path get path size 1 0 Point2D point2 p2 = cp get path size 1 0 if p2 equals p1 { p2 = path get path size 2 0 } END_DECORATION get this draw this p1 p2 } } } drawFill draw fill Graphics2D graphics2 { if isClosed closed { grow = AttributeKeys attribute keys getPerpendicularFillGrowth get perpendicular fill growth this if grow == 0d { fill path } else { GrowStroke grow stroke gs = new GrowStroke grow stroke float grow float AttributeKeys attribute keys getStrokeTotalWidth get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this fill gs createStrokedShape create stroked shape path } } } contains Point2D point2 { if isClosed closed { grow = AttributeKeys attribute keys getPerpendicularHitGrowth get perpendicular hit growth this if grow == 0d { path contains } else { GrowStroke grow stroke gs = new GrowStroke grow stroke float grow float AttributeKeys attribute keys getStrokeTotalWidth get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this gs createStrokedShape create stroked shape path contains } } else { tolerance = math max 2f AttributeKeys attribute keys getStrokeTotalWidth get stroke total width this / 2 if getCappedPath get capped path outlineContains outline contains tolerance { } if START_DECORATION get this != { BezierPath bezier path cp = getCappedPath get capped path Point2D point2 p1 = path get 0 0 Point2D point2 p2 = cp get 0 0 if geom lineContainsPoint line contains point p1 p1 p2 p2 tolerance { } } if END_DECORATION get this != { BezierPath bezier path cp = getCappedPath get capped path Point2D point2 p1 = path get path size 1 0 Point2D point2 p2 = cp get path size 1 0 if geom lineContainsPoint line contains point p1 p1 p2 p2 tolerance { } } } } canConnect can connect { isClosed closed } Collection<Handle> collection< handle> createHandles create handles detailLevel detail level { LinkedList<Handle> linked list< handle> handles = new LinkedList<Handle> linked list< handle> switch detailLevel detail level { case 0 BoxHandleKit box handle kit addBoxHandles add box handles this handles handles add new BezierScaleHandle bezier scale handle this break case 1 for i=0 = path size < i++ { handles add new BezierNodeHandle bezier node handle this } break } handles } Rectangle2D rectangle2 getBounds get bounds { Rectangle2D rectangle2 bounds =path getBounds2DDouble get bounds2 bounds width = math max 1 bounds width bounds height = math max 1 bounds height bounds } Rectangle2D rectangle2 getFigureDrawBounds get figure draw bounds { Rectangle2D rectangle2 = super getFigureDrawBounds get figure draw bounds if getNodeCount get node count > 1 { if START_DECORATION get this != { Point2D point2 p1 = getPoint get point 0 0 Point2D point2 p2 = getPoint get point 1 0 add START_DECORATION get this getDrawBounds get draw bounds this p1 p2 } if END_DECORATION get this != { Point2D point2 p1 = getPoint get point getNodeCount get node count 1 0 Point2D point2 p2 = getPoint get point getNodeCount get node count 2 0 add END_DECORATION get this getDrawBounds get draw bounds this p1 p2 } } } validate { super validate path invalidatePath invalidate path invalidateCappedPath invalidate capped path } BezierPath bezier path getBezierPath get bezier path { BezierPath bezier path path clone } Point2D point2 getPointOnPath get point path float relative flatness { path getPointOnPath get point path relative flatness } basicSetBezierPath basic set bezier path BezierPath bezier path newValue new value { this path = newValue new value this setClosed set closed newValue new value isClosed closed } isClosed closed { getAttribute get attribute CLOSED } setClosed set closed newValue new value { CLOSED set this newValue new value } basicSetAttribute basic set attribute AttributeKey attribute key key newValue new value { if key == CLOSED { path setClosed set closed newValue new value } super basicSetAttribute basic set attribute key newValue new value } basicSetBounds basic set bounds Point2D point2 anchor Point2D point2 { basicSetStartPoint basic set start point anchor basicSetEndPoint basic set point invalidate } basicTransform basic transform AffineTransform affine transform tx { path transform tx invalidate } invalidate { super invalidate path invalidatePath invalidate path invalidateCappedPath invalidate capped path } invalidateCappedPath invalidate capped path { cappedPath capped path = } BezierPath bezier path getCappedPath get capped path { if cappedPath capped path == { cappedPath capped path = BezierPath bezier path path clone if isClosed closed { cappedPath capped path setClosed set closed } else { if cappedPath capped path size > 1 { if START_DECORATION get this != { BezierPath bezier path node p0 = cappedPath capped path get 0 BezierPath bezier path node p1 = cappedPath capped path get 1 Point2D point2 pp if p0 getMask get mask BezierPath bezier path C2_MASK != 0 { pp = p0 getControlPoint get control point 2 } else if p1 getMask get mask BezierPath bezier path C1_MASK != 0 { pp = p1 getControlPoint get control point 1 } else { pp = p1 getControlPoint get control point 0 } radius = START_DECORATION get this getDecorationRadius get decoration radius this lineLength line length = geom length p0 getControlPoint get control point 0 pp cappedPath capped path set 0 0 geom cap pp p0 getControlPoint get control point 0 math min radius lineLength line length } if END_DECORATION get this != { BezierPath bezier path node p0 = cappedPath capped path get cappedPath capped path size 1 BezierPath bezier path node p1 = cappedPath capped path get cappedPath capped path size 2 Point2D point2 pp if p0 getMask get mask BezierPath bezier path C1_MASK != 0 { pp = p0 getControlPoint get control point 1 } else if p1 getMask get mask BezierPath bezier path C2_MASK != 0 { pp = p1 getControlPoint get control point 2 } else { pp = p1 getControlPoint get control point 0 } radius = END_DECORATION get this getDecorationRadius get decoration radius this lineLength line length = geom length p0 getControlPoint get control point 0 pp cappedPath capped path set cappedPath capped path size 1 0 geom cap pp p0 getControlPoint get control point 0 math min radius lineLength line length } cappedPath capped path invalidatePath invalidate path } } } cappedPath capped path } layout { } addNode add node BezierPath bezier path node { addNode add node getNodeCount get node count } addNode add node index BezierPath bezier path node { BezierPath bezier path node newPoint new point = new BezierPath bezier path node willChange will change basicAddNode basic add node index newPoint new point layout changed fireUndoableEditHappened fire undoable edit happened new AbstractUndoableEdit undoable edit { getPresentationName get presentation { punkt einf\u00fcgen } undo CannotUndoException cannot undo { super undo willChange will change basicRemoveNode basic remove node index changed } redo CannotUndoException cannot undo { super redo willChange will change basicAddNode basic add node index newPoint new point changed } } } basicAddNode basic add node BezierPath bezier path node { path add invalidate } basicAddNode basic add node index BezierPath bezier path node { path add index } setNode set node index BezierPath bezier path node { willChange will change BezierPath bezier path node oldValue old value = path get index BezierPath bezier path node newValue new value = new BezierPath bezier path node basicSetNode basic set node index newValue new value changed fireUndoableEditHappened fire undoable edit happened new BezierNodeEdit bezier node edit this index oldValue old value newValue new value } basicSetNode basic set node index BezierPath bezier path node { path set index } BezierPath bezier path node getNode get node index { BezierPath bezier path node path get index clone } Point2D point2 getPoint get point index { path get index getControlPoint get control point 0 } Point2D point2 getPoint get point index coord { path get index getControlPoint get control point coord } setPoint set point index coord Point2D point2 { willChange will change basicSetPoint basic set point index coord changed } basicSetPoint basic set point index Point2D point2 { BezierPath bezier path node node = path get index dx = node 0 dy = node 0 for i=0 < node length i++ { node += dx node += dy } invalidate } basicSetPoint basic set point index coord Point2D point2 { BezierPath bezier path node cp = new BezierPath bezier path node path get index cp setControlPoint set control point coord basicSetNode basic set node index cp } basicSetStartPoint basic set start point Point2D point2 { basicSetPoint basic set point 0 } basicSetEndPoint basic set point Point2D point2 { basicSetPoint basic set point getPointCount get point count 1 } Point2D point2 getStartPoint get start point { getPoint get point 0 0 } Point2D point2 getEndPoint get point { getPoint get point getNodeCount get node count 1 0 } findNode find node Point2D point2 { BezierPath bezier path tp = path for i=0 < tp size i++ { BezierPath bezier path node p2 = tp get if p2 0 == p2 0 == { } } 1 } removeAllNodes remove all nodes { willChange will change basicRemoveAllNodes basic remove all nodes changed } removeNode remove node index { BezierPath bezier path node oldPoint old point = new BezierPath bezier path node path get index willChange will change basicRemoveNode basic remove node index layout changed fireUndoableEditHappened fire undoable edit happened new AbstractUndoableEdit undoable edit { getPresentationName get presentation { punkt entfernen } undo CannotUndoException cannot undo { super undo willChange will change basicAddNode basic add node index oldPoint old point changed } redo CannotUndoException cannot undo { super redo basicRemoveNode basic remove node index changed } } } findSegment find segment Point2D point2 find { Point2D point2 p1 p2 for = 0 = getNodeCount get node count 1 < i++ { p1 = path get 0 p2 = path get i+1 0 if geom lineContainsPoint line contains point p1 p1 p2 p2 find find 3d { } } 1 } basicJoinSegments basic join segments Point2D point2 join { = findSegment find segment join if != 1 > 1 { removeNode remove node } } basicSplitSegment basic split segment Point2D point2 split { = findSegment find segment split if != 1 { addNode add node + 1 new BezierPath bezier path node split } i+1 } basicRemoveNode basic remove node index { path remove index } basicRemoveAllNodes basic remove all nodes { path clear } getNodeCount get node count { path size } getPointCount get point count { path size } BezierFigure bezier figure clone { BezierFigure bezier figure that = BezierFigure bezier figure super clone that path = BezierPath bezier path this path clone that invalidate that } restoreTo restore to geometry { path setTo set to BezierPath bezier path geometry } getRestoreData get restore data { path clone } Point2D point2 chop Point2D point2 { if isClosed closed { grow = AttributeKeys attribute keys getPerpendicularHitGrowth get perpendicular hit growth this if grow == 0d { path chop } else { GrowStroke grow stroke gs = new GrowStroke grow stroke float grow float AttributeKeys attribute keys getStrokeTotalWidth get stroke total width this * STROKE_MITER_LIMIT_FACTOR get this geom chop gs createStrokedShape create stroked shape path } } else { path chop } } Point2D point2 getCenter get center { path getCenter get center } Point2D point2 getOutermostPoint get outermost point { path get path indexOfOutermostNode index of outermost node getControlPoint get control point 0 } basicJoinSegments basic join segments Point2D point2 join float tolerance { path joinSegments join segments join tolerance } basicSplitSegment basic split segment Point2D point2 split float tolerance { path splitSegment split segment split tolerance } handleMouseClick handle mouse click Point2D point2 MouseEvent mouse event evt DrawingView drawing view view { if evt getClickCount get click count == 2 view getHandleDetailLevel get handle detail level == 1 { willChange will change index = basicSplitSegment basic split segment float 5f / view getScaleFactor get scale factor if index != 1 { BezierPath bezier path node newNode new node = getNode get node index fireUndoableEditHappened fire undoable edit happened new AbstractUndoableEdit undoable edit { redo CannotRedoException cannot redo { super redo willChange will change basicAddNode basic add node index newNode new node changed } undo CannotUndoException cannot undo { super undo willChange will change basicRemoveNode basic remove node index changed } } changed } } } write DOMOutput dom output out IOException { writePoints write points out writeAttributes write attributes out } writePoints write points DOMOutput dom output out IOException { out openElement open element points if isClosed closed { out addAttribute add attribute closed } for i=0 = getNodeCount get node count < i++ { BezierPath bezier path node node = getNode get node out openElement open element if node mask != 0 { out addAttribute add attribute mask node mask } if ! node keepColinear keep colinear { out addAttribute add attribute colinear } out addAttribute add attribute node 0 out addAttribute add attribute node 0 if node 1 != node 0 || node 1 != node 0 { out addAttribute add attribute c1x node 1 out addAttribute add attribute c1y node 1 } if node 2 != node 0 || node 2 != node 0 { out addAttribute add attribute c2x node 2 out addAttribute add attribute c2y node 2 } out closeElement close element } out closeElement close element } @Override @ read DOMInput dom input IOException { readPoints read points readAttributes read attributes } readPoints read points DOMInput dom input IOException { path clear openElement open element points setClosed set closed getAttribute get attribute closed for i=0 = getElementCount get element count < i++ { openElement open element BezierPath bezier path node node = new BezierPath bezier path node getAttribute get attribute mask 0 getAttribute get attribute 0d getAttribute get attribute 0d getAttribute get attribute c1x getAttribute get attribute 0d getAttribute get attribute c1y getAttribute get attribute 0d getAttribute get attribute c2x getAttribute get attribute 0d getAttribute get attribute c2y getAttribute get attribute 0d node keepColinear keep colinear = getAttribute get attribute colinear path add node path invalidatePath invalidate path closeElement close element } closeElement close element } } 