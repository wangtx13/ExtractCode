org jhotdraw draw action import lang reflect * GenericListener generic listener { create listenerInterface listener listenerMethodName listener target targetMethodName target { listenerMethod listener = getListenerMethod get listener listenerInterface listener listenerMethodName listener targetMethod target = getTargetMethod get target target targetMethodName target listenerMethod listener getParameterTypes get types if targetMethod target == { targetMethod target = getTargetMethod get target target targetMethodName target new 0 } if targetMethod target == { new RuntimeException runtime no such +targetMethodName+ +target name+ +target getClass get } create listenerMethod listener target targetMethod target } create listenerMethod listener target targetMethod target { InvocationHandler invocation handler handler = new DefaultInvoker default invoker { proxy args throwable { if listenerMethod listener equals { if targetMethod target getParameterTypes get types length == 0 { targetMethod target target new 0 } else { targetMethod target target args } } else { super proxy args } } } cls = listenerMethod listener getDeclaringClass get declaring ClassLoader loader = cls getClassLoader get loader proxy newProxyInstance new proxy instance new {cls} handler } private DefaultInvoker default invoker implements InvocationHandler invocation handler { proxy args throwable { if getDeclaringClass get declaring == { methodName = getName get if methodName equals hashCode hash { proxyHashCode proxy hash proxy } else if methodName equals equals { proxyEquals proxy equals proxy args 0 } else if methodName equals toString to { proxyToString proxy to proxy } } nullValueOf value of getReturnType get type } integer proxyHashCode proxy hash proxy { new integer identityHashCode identity hash proxy } proxyEquals proxy equals proxy other { proxy == other ? TRUE FALSE } proxyToString proxy to proxy { proxy getClass get getName get + '@' + integer toHexString to hex proxy hashCode hash } private character char_0 = new character char 0 private byte byte_0 = new byte byte 0 private nullValueOf value of rt { if !rt isPrimitive primitive { } else if rt == { } else if rt == { FALSE } else if rt == char { char_0 } else { byte_0 } } } private getListenerMethod get listener listenerInterface listener listenerMethodName listener { = listenerInterface listener getMethods get result = for = 0 < length i++ { if listenerMethodName listener equals getName get { if result != { new RuntimeException runtime ambiguous +m + vs +result } result = } } if result == { new RuntimeException runtime no such +listenerMethodName+ +listener name+ +listenerInterface +listener } result } private getTargetMethod get target target targetMethodName target parameterTypes types { = target getClass get getMethods get result = eachMethod each for = 0 < length i++ { if !targetMethodName !target equals getName get continue eachMethod each = getParameterTypes get types if length != parameterTypes types length continue eachMethod each for = 0 < length j++ { if !p isAssignableFrom assignable from parameterTypes types continue eachMethod each } if result != { new RuntimeException runtime ambiguous +m + vs +result } result = } if result == { } publicResult result = raiseToPublicClass raise to result if publicResult result != result = publicResult result result } private raiseToPublicClass raise to { = getDeclaringClass get declaring if modifier isPublic getModifiers get modifiers modifier isPublic getModifiers get modifiers sc = getSuperclass get superclass if sc != { sm = raiseToPublicClass raise to sc if sm != sm } ints = getInterfaces get for = 0 < ints length i++ { = raiseToPublicClass raise to ints if != } } private raiseToPublicClass raise to { try { sm = getMethod get getName get getParameterTypes get types raiseToPublicClass raise to sm } catch NoSuchMethodException no such ee { } } private GenericListener generic listener {} } 