org jhotdraw geom import awt * import awt geom * import util * BezierPath bezier path ArrayList<BezierPath list< bezier path node> implements shape { C1_MASK = 1 C2_MASK = 2 C1C2_MASK = C1_MASK | C2_MASK private transient GeneralPath general path generalPath general path private outer = 1 private isClosed closed node implements cloneable { mask = 0 = new 3 = new 3 keepColinear keep colinear = node { mask = 1 } node node that { setTo set to that } setTo set to node that { this mask = that mask this keepColinear keep colinear = that keepColinear keep colinear arraycopy that 0 this 0 3 arraycopy that 0 this 0 3 } node Point2D point2 c0 { this mask = 0 0 = c0 0 = c0 1 = c0 1 = c0 2 = c0 2 = c0 } node mask Point2D point2 c0 Point2D point2 c1 Point2D point2 c2 { this mask = mask 0 = c0 0 = c0 1 = c1 1 = c1 2 = c2 2 = c2 } node x0 y0 { this mask = 0 0 = x0 0 = y0 1 = x0 1 = y0 2 = x0 2 = y0 } node mask x0 y0 x1 y1 x2 y2 { this mask = mask 0 = x0 0 = y0 1 = x1 1 = y1 2 = x2 2 = y2 } getMask get mask { mask } setMask set mask newValue new value { mask = newValue new value } setControlPoint set control point index Point2D point2 { index = index = } Point2D point2 getControlPoint get control point index { new Point2D point2 index index } moveTo move to Point2D point2 { moveBy move by 0 0 } moveTo move to { moveBy move by this 0 this 0 } moveBy move by dx dy { for i=0 < 3 i++ { += dx += dy } } clone { try { node that = node super clone that = this clone that = this clone that } catch CloneNotSupportedException clone not supported { InternalError internal = new InternalError internal initCause init cause } } toString to { StringBuilder builder buf = new StringBuilder builder buf append ' ' for i=0 < 3 i++ { if != 0 { if mask == { buf append ' ' } else { continue } } buf append 'x' buf append buf append '=' buf append buf append buf append buf append '=' buf append } buf append ' ' buf toString to } } BezierPath bezier path { } add Point2D point2 c0 { add new node 0 c0 c0 c0 } addPoint add point { add new node 0 } add mask Point2D point2 c0 Point2D point2 c1 Point2D point2 c2 { add new node mask c0 c1 c2 } set index coord Point2D point2 { node = get index coord = coord = } Point2D point2 get index coord { node = get index new Point2D point2 coord coord } invalidatePath invalidate path { generalPath general path = outer = 1 } validatePath validate path { if generalPath general path == { generalPath general path = toGeneralPath to general path } } GeneralPath general path toGeneralPath to general path { GeneralPath general path gp = new GeneralPath general path gp setWindingRule set winding rule GeneralPath general path WIND_EVEN_ODD if size == 0 { gp moveTo move to 0 0 gp lineTo line to 0 0 + 1 } else if size == 1 { node current = get 0 gp moveTo move to float current 0 float current 0 gp lineTo line to float current 0 float current 0 + 1 } else { node previous node current previous = current = get 0 gp moveTo move to float current 0 float current 0 for i=1 = size < i++ { previous = current current = get if previous mask C2_MASK == 0 { if current mask C1_MASK == 0 { gp lineTo line to float current 0 float current 0 } else { gp quadTo quad to float current 1 float current 1 float current 0 float current 0 } } else { if current mask C1_MASK == 0 { gp quadTo quad to float previous 2 float previous 2 float current 0 float current 0 } else { gp curveTo curve to float previous 2 float previous 2 float current 1 float current 1 float current 0 float current 0 } } } if isClosed closed { if size > 1 { previous = get size 1 current = get 0 if previous mask C2_MASK == 0 { if current mask C1_MASK == 0 { gp lineTo line to float current 0 float current 0 } else { gp quadTo quad to float current 1 float current 1 float current 0 float current 0 } } else { if current mask C1_MASK == 0 { gp quadTo quad to float previous 2 float previous 2 float current 0 float current 0 } else { gp curveTo curve to float previous 2 float previous 2 float current 1 float current 1 float current 0 float current 0 } } } gp closePath close path } } gp } contains Point2D point2 { validatePath validate path generalPath general path contains } outlineContains outline contains Point2D point2 tolerance { validatePath validate path PathIterator path iterator = generalPath general path getPathIterator get path iterator new AffineTransform affine transform tolerance coords = new 6 type = currentSegment current segment coords prevX prev = coords 0 prevY prev = coords 1 next while ! isDone done { currentSegment current segment coords if geom lineContainsPoint line contains point prevX prev prevY prev coords 0 coords 1 tolerance { } prevX prev = coords 0 prevY prev = coords 1 next } } intersects Rectangle2D rectangle2 { validatePath validate path generalPath general path intersects } PathIterator path iterator getPathIterator get path iterator AffineTransform affine transform { validatePath validate path generalPath general path getPathIterator get path iterator } contains Rectangle2D rectangle2 { validatePath validate path generalPath general path contains } PathIterator path iterator getPathIterator get path iterator AffineTransform affine transform flatness { validatePath validate path generalPath general path getPathIterator get path iterator flatness } intersects { validatePath validate path generalPath general path intersects } Rectangle2D rectangle2 getBounds2D get bounds2 { validatePath validate path generalPath general path getBounds2D get bounds2 } Rectangle2D rectangle2 getBounds2DDouble get bounds2 { validatePath validate path Rectangle2D rectangle2 = generalPath general path getBounds2D get bounds2 if instanceof Rectangle2D rectangle2 { Rectangle2D rectangle2 } else { new Rectangle2D rectangle2 getX get getY get getWidth get width getHeight get height } } rectangle getBounds get bounds { validatePath validate path generalPath general path getBounds get bounds } contains { validatePath validate path generalPath general path contains } contains { validatePath validate path generalPath general path contains } setClosed set closed newValue new value { if isClosed closed != newValue new value { isClosed closed = newValue new value invalidatePath invalidate path } } isClosed closed { isClosed closed } clone { BezierPath bezier path that = BezierPath bezier path super clone for i=0 = this size < i++ { that set node this get clone } that } transform AffineTransform affine transform tx { Point2D point2 = new Point2D point2 for node cp this { for i=0 < 3 i++ { = cp = cp tx transform cp = cp = } } invalidatePath invalidate path } setTo set to BezierPath bezier path that { while that size < size { remove size 1 } for i=0 = size < i++ { get setTo set to that get } while size < that size { add node that get size clone } } Point2D point2 getCenter get center { sx = 0 = 0 for node this { sx += 0 += 0 } = size new Point2D point2 sx / / } Point2D point2 chop Point2D point2 { validatePath validate path geom chop generalPath general path } indexOfOutermostNode index of outermost node { if outer == 1 { Point2D point2 ctr = getCenter get center outer = 0 dist = 0 for = 0 = size < i++ { node cp = get = geom length2 ctr ctr cp 0 cp 0 if > dist { dist = outer = } } } outer } Point2D point2 getPointOnPath get point path relative flatness { if size == 0 { } else if size == 1 { get 0 getControlPoint get control point 0 } if relative <= 0 { get 0 getControlPoint get control point 0 } else if relative >= 1 { get size 1 getControlPoint get control point 0 } validatePath validate path len = 0 PathIterator path iterator = generalPath general path getPathIterator get path iterator new AffineTransform affine transform flatness coords = new 6 type = currentSegment current segment coords prevX prev = coords 0 prevY prev = coords 1 next for ! isDone done next { currentSegment current segment coords len += geom length prevX prev prevY prev coords 0 coords 1 prevX prev = coords 0 prevY prev = coords 1 } relativeLen relative len = len * relative pos = 0 = generalPath general path getPathIterator get path iterator new AffineTransform affine transform flatness type = currentSegment current segment coords prevX prev = coords 0 prevY prev = coords 1 next for ! isDone done next { currentSegment current segment coords segLen seg len = geom length prevX prev prevY prev coords 0 coords 1 if pos + segLen seg len >= relativeLen relative len { factor = relativeLen relative len pos / segLen seg len new Point2D point2 prevX prev * 1 factor + coords 0 * factor prevY prev * 1 factor + coords 1 * factor } pos += segLen seg len prevX prev = coords 0 prevY prev = coords 1 } new InternalError internal we should never get here } findSegment find segment Point2D point2 find float tolerance { node v1 v2 BezierPath bezier path tempPath temp path = new BezierPath bezier path node t1 t2 tempPath temp path add t1 = new node tempPath temp path add t2 = new node for = 0 = size 1 < i++ { v1 = get v2 = get i+1 if v1 mask == 0 v2 mask == 0 { if geom lineContainsPoint line contains point v1 0 v1 0 v2 0 v2 0 find find tolerance { } } else { t1 setTo set to v1 t2 setTo set to v2 tempPath temp path invalidatePath invalidate path if tempPath temp path outlineContains outline contains find tolerance { } } } if isClosed closed size > 1 { v1 = get size 1 v2 = get 0 if v1 mask == 0 v2 mask == 0 { if geom lineContainsPoint line contains point v1 0 v1 0 v2 0 v2 0 find find tolerance { size 1 } } else { t1 setTo set to v1 t2 setTo set to v2 tempPath temp path invalidatePath invalidate path if tempPath temp path outlineContains outline contains find tolerance { size 1 } } } 1 } joinSegments join segments Point2D point2 join float tolerance { for i=0 < size i++ { node = get if geom length 0 0 join join < tolerance { remove } } 1 } splitSegment split segment Point2D point2 split float tolerance { = findSegment find segment split tolerance nextI next = + 1 % size if != 1 { if get mask C2_MASK == C2_MASK get nextI next mask C1_MASK == 0 { add + 1 new node C2_MASK split split split } else if get mask C2_MASK == 0 get nextI next mask C1_MASK == C1_MASK { add + 1 new node C2_MASK split split split } else if get mask C2_MASK == C2_MASK get nextI next mask C1_MASK == C2_MASK { add + 1 new node C1_MASK | C2_MASK split split split } else { add + 1 new node split } } i+1 } moveTo move to x1 y1 { if size != 0 { new IllegalPathStateException illegal path state moveTo move to only allowed when empty } add new node x1 y1 } lineTo line to x1 y1 { if size == 0 { new IllegalPathStateException illegal path state lineTo line to only allowed when not empty } add new node x1 y1 } quadTo quad to x1 y1 x2 y2 { if size == 0 { new IllegalPathStateException illegal path state quadTo quad to only allowed when not empty } add new node C1_MASK x2 y2 x1 y1 x2 y2 } curveTo curve to x1 y1 x2 y2 x3 y3 { if size == 0 { new IllegalPathStateException illegal path state curveTo curve to only allowed when not empty } node lastPoint last point = get size 1 lastPoint last point mask |= C2_MASK lastPoint last point 2 = x1 lastPoint last point 2 = y1 add new node C1_MASK x3 y3 x2 y2 x3 y3 } Point2D point2 toPolygonArray to polygon { Point2D point2 points = new Point2D point2 size for i=0 = size < i++ { points = new Point2D point2 get 0 get 0 } points } } 