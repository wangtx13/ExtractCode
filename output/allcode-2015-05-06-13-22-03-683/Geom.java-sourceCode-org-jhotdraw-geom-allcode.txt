org jhotdraw geom import awt * import awt geom * geom { private geom {} lineContainsPoint line contains point x1 y1 x2 y2 px py { lineContainsPoint line contains point x1 y1 x2 y2 px py 3d } lineContainsPoint line contains point x1 y1 x2 y2 px py tolerance { rectangle = new rectangle new point x1 y1 add x2 y2 grow math max 2 math ceil tolerance math max 2 math ceil tolerance if ! contains px py { } if x1 == x2 { math px x1 <= tolerance } if y1 == y2 { math py y1 <= tolerance } = y1 y2 / x1 x2 = y1 * x1 = py / = * px + math min math px math py <= tolerance } lineContainsPoint line contains point x1 y1 x2 y2 px py tolerance { Rectangle2D rectangle2 = new Rectangle2D rectangle2 x1 y1 0 0 add x2 y2 grow = math max 2 math ceil tolerance = grow = grow width += grow * 2 height += grow * 2 if ! contains px py { } if x1 == x2 { math px x1 <= tolerance } if y1 == y2 { math py y1 <= tolerance } = y1 y2 / x1 x2 = y1 * x1 = py / = * px + math min math px math py <= tolerance } OUT_TOP = Rectangle2D rectangle2 OUT_TOP OUT_BOTTOM = Rectangle2D rectangle2 OUT_BOTTOM OUT_LEFT = Rectangle2D rectangle2 OUT_LEFT OUT_RIGHT = Rectangle2D rectangle2 OUT_RIGHT direction x1 y1 x2 y2 { direction = 0 vx = x2 x1 vy = y2 y1 if vy < vx vx > vy { direction = OUT_RIGHT } else if vy > vx vy > vx { direction = OUT_TOP } else if vx < vy vx < vy { direction = OUT_LEFT } else { direction = OUT_BOTTOM } direction } direction x1 y1 x2 y2 { direction = 0 vx = x2 x1 vy = y2 y1 if vy < vx vx > vy { direction = OUT_RIGHT } else if vy > vx vy > vx { direction = OUT_TOP } else if vx < vy vx < vy { direction = OUT_LEFT } else { direction = OUT_BOTTOM } direction } outcode rectangle r1 rectangle r2 { outcode = 0 if r2 > r1 + r1 width outcode = OUT_RIGHT else if r2 + r2 width < r1 outcode = OUT_LEFT if r2 > r1 + r1 height outcode |= OUT_BOTTOM else if r2 + r2 height < r1 outcode |= OUT_TOP outcode } outcode Rectangle2D rectangle2 r1 Rectangle2D rectangle2 r2 { outcode = 0 if r2 > r1 + r1 width outcode = OUT_RIGHT else if r2 + r2 width < r1 outcode = OUT_LEFT if r2 > r1 + r1 height outcode |= OUT_BOTTOM else if r2 + r2 height < r1 outcode |= OUT_TOP outcode } point south rectangle { new point + width /2 + height } Point2D point2 south Rectangle2D rectangle2 { new Point2D point2 + width /2 + height } point center rectangle { new point + width /2 + height/2 } Point2D point2 center Rectangle2D rectangle2 { new Point2D point2 + width /2 + height/2 } Point2D point2 chop shape shape Point2D point2 { Rectangle2D rectangle2 bounds = shape getBounds2D get bounds2 Point2D point2 ctr = new Point2D point2 bounds getCenterX get center bounds getCenterY get center cx = 1 cy = 1 len = MAX_VALUE PathIterator path iterator = shape getPathIterator get path iterator new AffineTransform affine transform 1 coords = new 6 type = currentSegment current segment coords prevX prev = coords 0 prevY prev = coords 1 moveToX move to = prevX prev moveToY move to = prevY prev next for ! isDone done next { switch currentSegment current segment coords { case PathIterator path iterator SEG_MOVETO moveToX move to = coords 0 moveToY move to = coords 1 break case PathIterator path iterator SEG_CLOSE coords 0 = moveToX move to coords 1 = moveToY move to break } Point2D point2 chop = geom intersect prevX prev prevY prev coords 0 coords 1 ctr ctr if chop != { = geom length2 chop chop if < len { len = cx = chop cy = chop } } prevX prev = coords 0 prevY prev = coords 1 } if len == MAX_VALUE { = shape getPathIterator get path iterator new AffineTransform affine transform 1 for ! isDone done next { currentSegment current segment coords = geom length2 ctr ctr coords 0 coords 1 if < len { len = cx = coords 0 cy = coords 1 } } } new Point2D point2 cx cy } point west rectangle { new point + height/ 2 } Point2D point2 west Rectangle2D rectangle2 { new Point2D point2 + height/ 2 } point east rectangle { new point x+r width + height/ 2 } Point2D point2 east Rectangle2D rectangle2 { new Point2D point2 x+r width + height/ 2 } point north rectangle { new point x+r width/2 } Point2D point2 north Rectangle2D rectangle2 { new Point2D point2 x+r width/2 } range min max value { if value < min { value = min } if value > max { value = max } value } range min max value { if value < min { value = min } if value > max { value = max } value } long length2 x1 y1 x2 y2 { x2 x1 * x2 x1 + y2 y1 * y2 y1 } long length x1 y1 x2 y2 { long math sqrt length2 x1 y1 x2 y2 } length2 x1 y1 x2 y2 { x2 x1 * x2 x1 + y2 y1 * y2 y1 } length x1 y1 x2 y2 { math sqrt length2 x1 y1 x2 y2 } length Point2D point2 p1 Point2D point2 p2 { math sqrt length2 p1 p1 p2 p2 } Point2D point2 cap Point2D point2 p1 Point2D point2 p2 radius { angle = math PI/2 i/2 math atan2 p2 p1 p2 p1 Point2D point2 p3 = new Point2D point2 p2 + radius * math cos angle p2 + radius * math sin angle p3 } pointToAngle point to angle rectangle point { px = + width/2 py = + height/2 math atan2 py*r width px*r height } pointToAngle point to angle Rectangle2D rectangle2 Point2D point2 { px = + width/2 py = + height/2 math atan2 py*r width px*r height } angle x1 y1 x2 y2 { math atan2 y2 y1 x2 x1 } point angleToPoint angle to point rectangle angle { = math sin angle = math cos angle = 0 0001 x= 0 y= 0 if math > { x= 1 0 + co/Math co/ math /2 0 * width x= range 0 width } else if >= 0 0 { x= width } if math > { y= 1 0 + si/Math si/ math /2 0 * height y= range 0 height } else if >= 0 0 { y= height } new point + + } Point2D point2 angleToPoint angle to point Rectangle2D rectangle2 angle { = math sin angle = math cos angle = 0 0001 x= 0 = 0 if math > { x= 1 0 + co/Math co/ math /2 0 * width = range 0 width } else if >= 0 0 { = width } if math > { = 1 0 + si/Math si/ math /2 0 * height = range 0 height } else if >= 0 0 { = height } new Point2D point2 + + } point polarToPoint polar to point angle fx fy { = math sin angle = math cos angle new point fx*co+0 5 fy*si+0 5 } Point2D point2 polarToPoint2D polar to point2 angle fx fy { = math sin angle = math cos angle new Point2D point2 fx*co+0 5 fy*si+0 5 } point ovalAngleToPoint oval angle to point rectangle angle { point center = geom center point = geom polarToPoint polar to point angle width/2 height/2 new point center + center + } Point2D point2 ovalAngleToPoint oval angle to point Rectangle2D rectangle2 angle { Point2D point2 center = geom center Point2D point2 = geom polarToPoint2D polar to point2 angle width/2 height/2 new Point2D point2 center + center + } point intersect xa ya xb yb yc xd yd { denom = xb xa * yd yc yb ya * xd rnum = ya yc * xd xa * yd yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < || xb < xd || xa > xb xb > || xb > xd { new point xb yb } else { new point xa ya } } else { } } = rnum / denom snum = ya yc * xb xa xa * yb ya = snum / denom if 0 0 <= <= 1 0 0 0 <= <= 1 0 { px = xa + xb xa * py = ya + yb ya * new point px py } else { } } Point2D point2 intersect xa ya xb yb yc xd yd { denom = xb xa * yd yc yb ya * xd rnum = ya yc * xd xa * yd yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < || xb < xd || xa > xb xb > || xb > xd { new Point2D point2 xb yb } else { new Point2D point2 xa ya } } else { } } = rnum / denom snum = ya yc * xb xa xa * yb ya = snum / denom if 0 0 <= <= 1 0 0 0 <= <= 1 0 { px = xa + xb xa * py = ya + yb ya * new Point2D point2 px py } else { } } Point2D point2 intersect xa ya xb yb yc xd yd limit { denom = xb xa * yd yc yb ya * xd rnum = ya yc * xd xa * yd yc if denom == 0 0 { if rnum == 0 0 { if xa < xb xb < || xb < xd || xa > xb xb > || xb > xd { new Point2D point2 xb yb } else { new Point2D point2 xa ya } } else { } } = rnum / denom snum = ya yc * xb xa xa * yb ya = snum / denom if 0 0 <= <= 1 0 0 0 <= <= 1 0 { px = xa + xb xa * py = ya + yb ya * new Point2D point2 px py } else { px = xa + xb xa * py = ya + yb ya * if length xa ya px py <= limit || length xb yb px py <= limit || length yc px py <= limit || length xd yd px py <= limit { new Point2D point2 px py } } } distanceFromLine distance from line xa ya xb yb yc { xdiff = xb xa ydiff = yb ya long l2 = xdiff * xdiff + ydiff * ydiff if l2 == 0 { geom length xa ya yc } rnum = ya yc * ya yb xa * xb xa = rnum / l2 if < 0 0 || > 1 0 { MAX_VALUE } = xa + * xdiff yi = ya + * ydiff xd = yd = yc yi math sqrt xd * xd + yd * yd } grow Rectangle2D rectangle2 { = = width += * 2d height += * 2d } } 