org jhotdraw draw import org jhotdraw util ReversedList reversed list import awt * import awt geom * import javax swing * import javax swing event * import javax swing undo * import org jhotdraw util * import util * DefaultDrawing default drawing AbstractDrawing drawing implements FigureListener figure listener UndoableEditListener undoable edit listener { private ArrayList<Figure> list< figure> figures = new ArrayList<Figure> list< figure> private needsSorting needs sorting = DefaultDrawing default drawing { } indexOf index of figure figure { figures indexOf index of figure } basicAdd basic add index figure figure { figures add index figure figure addFigureListener add figure listener this figure addUndoableEditListener add undoable edit listener this invalidateSortOrder invalidate sort order } basicRemove basic remove figure figure { figures remove figure figure removeFigureListener remove figure listener this figure removeUndoableEditListener remove undoable edit listener this invalidateSortOrder invalidate sort order } draw Graphics2D graphics2 { synchronized getLock get lock { ensureSorted ensure sorted ArrayList<Figure> list< figure> toDraw to draw = new ArrayList<Figure> list< figure> figures size rectangle clipRect clip rect = getClipBounds get clip bounds for figure figures { if getDrawBounds get draw bounds intersects clipRect clip rect { toDraw to draw add } } draw toDraw to draw } } draw Graphics2D graphics2 Collection<Figure> collection< figure> figures { for figure figures { if isVisible visible { draw } } } Collection<Figure> collection< figure> sort Collection<Figure> collection< figure> { HashSet<Figure> hash set< figure> unsorted = new HashSet<Figure> hash set< figure> unsorted addAll add all ArrayList<Figure> list< figure> sorted = new ArrayList<Figure> list< figure> size for figure figures { if unsorted contains { sorted add unsorted remove } } for figure { if unsorted contains { sorted add unsorted remove } } sorted } figureAreaInvalidated figure area invalidated FigureEvent figure event { fireAreaInvalidated fire area invalidated getInvalidatedArea get invalidated area } figureChanged figure changed FigureEvent figure event { invalidateSortOrder invalidate sort order fireAreaInvalidated fire area invalidated getInvalidatedArea get invalidated area } figureAdded figure added FigureEvent figure event { } figureRemoved figure removed FigureEvent figure event { } figureRequestRemove figure request remove FigureEvent figure event { remove getFigure get figure } figure findFigure find figure Point2D point2 { for figure getFiguresFrontToBack get figures front to back { if isVisible visible contains { } } } figure findFigureExcept find figure Point2D point2 figure ignore { for figure getFiguresFrontToBack get figures front to back { if != ignore isVisible visible contains { } } } figure findFigureExcept find figure Point2D point2 Collection<Figure> collection< figure> ignore { for figure getFiguresFrontToBack get figures front to back { if ! ignore contains isVisible visible contains { } } } Collection<Figure> collection< figure> findFigures find figures Rectangle2D rectangle2 bounds { ArrayList<Figure> list< figure> intersection = new ArrayList<Figure> list< figure> for figure figures { if isVisible visible getBounds get bounds intersects bounds { intersection add } } intersection } Collection<Figure> collection< figure> findFiguresWithin find figures within Rectangle2D rectangle2 bounds { ArrayList<Figure> list< figure> contained = new ArrayList<Figure> list< figure> for figure figures { if isVisible visible bounds contains getBounds get bounds { contained add } } contained } Collection<Figure> collection< figure> getFigures get figures { collections unmodifiableCollection unmodifiable collection figures } figure findFigureInside find figure inside Point2D point2 { figure = findFigure find figure == ? findFigureInside find figure inside } util List<Figure> list< figure> getFiguresFrontToBack get figures front to back { ensureSorted ensure sorted new ReversedList<Figure> reversed list< figure> figures } bringToFront bring to front figure figure { if figures remove figure { figures add figure invalidateSortOrder invalidate sort order fireAreaInvalidated fire area invalidated figure getDrawBounds get draw bounds } } sendToBack send to back figure figure { if figures remove figure { figures add 0 figure invalidateSortOrder invalidate sort order fireAreaInvalidated fire area invalidated figure getDrawBounds get draw bounds } } undoableEditHappened undoable edit happened UndoableEditEvent undoable edit event { fireUndoableEditHappened fire undoable edit happened getEdit get edit } figureAttributeChanged figure attribute changed FigureEvent figure event { } contains figure { figures contains } private invalidateSortOrder invalidate sort order { needsSorting needs sorting = } private ensureSorted ensure sorted { if needsSorting needs sorting { collections sort figures FigureLayerComparator figure layer comparator INSTANCE needsSorting needs sorting = } } } 