org jhotdraw geom import org jhotdraw util * import awt * import awt geom * bezier { private MAXPOINTS = 1000 private bezier { } args { Point2D point2 = {	 new Point2D point2 0 0 0 0 new Point2D point2 0 0 0 5 new Point2D point2 1 1 1 4 new Point2D point2 2 1 1 6 new Point2D point2 3 2 1 1 new Point2D point2 4 0 0 2 new Point2D point2 4 0 0 0 } double	error = 4 0 		 GeneralPath general path path = fitCurve fit curve 	 out path } GeneralPath general path fitCurve fit curve polygon { Point2D point2 = new Point2D point2 npoints for i=0 < length i++ { = new Point2D point2 xpoints ypoints } fitCurve fit curve } GeneralPath general path fitCurve fit curve Point2D point2 { Point2D point2 tHat1 hat1 = new Point2D point2 Point2D point2 tHat2 hat2 = new Point2D point2 GeneralPath general path bezierPath bezier path = new GeneralPath general path bezierPath bezier path moveTo move to float 0 float 0 tHat1 hat1 = computeLeftTangent compute left tangent 0 tHat2 hat2 = computeRightTangent compute right tangent length 1 fitCubic fit cubic 0 length 1 tHat1 hat1 tHat2 hat2 bezierPath bezier path bezierPath bezier path } BezierPath bezier path fitBezierCurve fit bezier curve BezierPath bezier path path { Point2D point2 = path toPolygonArray to polygon Point2D point2 tHat1 hat1 = new Point2D point2 Point2D point2 tHat2 hat2 = new Point2D point2 BezierPath bezier path bezierPath bezier path = new BezierPath bezier path bezierPath bezier path add new BezierPath bezier path node 0 tHat1 hat1 = computeLeftTangent compute left tangent 0 tHat2 hat2 = computeRightTangent compute right tangent length 1 fitCubic fit cubic 0 length 1 tHat1 hat1 tHat2 hat2 bezierPath bezier path bezierPath bezier path setClosed set closed path isClosed closed bezierPath bezier path } private fitCubic fit cubic Point2D point2 first last Point2D point2 tHat1 hat1 Point2D point2 tHat2 hat2 GeneralPath general path bezierPath bezier path { Point2D point2 bezCurve bez curve 		 uPrime prime 	 double	maxError double	max 	 	splitPoint 	split point = new 1 int	nPts int	n pts 		 double	iterationError double	iteration int	maxIterations int	max iterations = 4 Point2D point2 Double	tHatCenter double	t hat center = new Point2D point2 int	i iterationError iteration = * nPts pts = last first + 1 if nPts pts == 2 { dist = v2DistanceBetween2Points v2 distance between2 points last first / 3 0 bezCurve bez curve = new Point2D point2 4 for i=0 < bezCurve bez curve length i++ { bezCurve bez curve = new Point2D point2 } bezCurve bez curve 0 = first bezCurve bez curve 3 = last v2Add v2 add bezCurve bez curve 0 v2Scale v2 scale tHat1 hat1 dist bezCurve bez curve 1 v2Add v2 add bezCurve bez curve 3 v2Scale v2 scale tHat2 hat2 dist bezCurve bez curve 2 bezierPath bezier path curveTo curve to float bezCurve bez curve 1 float bezCurve bez curve 1 float bezCurve bez curve 2 float bezCurve bez curve 2 float bezCurve bez curve 3 float bezCurve bez curve 3 } = chordLengthParameterize chord length parameterize first last bezCurve bez curve = generateBezier generate bezier first last tHat1 hat1 tHat2 hat2 maxError max = computeMaxError compute max first last bezCurve bez curve splitPoint split point if maxError max < { bezierPath bezier path curveTo curve to float bezCurve bez curve 1 float bezCurve bez curve 1 float bezCurve bez curve 2 float bezCurve bez curve 2 float bezCurve bez curve 3 float bezCurve bez curve 3 } if maxError max < iterationError iteration { for = 0 < maxIterations max iterations i++ { uPrime prime = reparameterize first last bezCurve bez curve bezCurve bez curve = generateBezier generate bezier first last uPrime prime tHat1 hat1 tHat2 hat2 maxError max = computeMaxError compute max first last bezCurve bez curve uPrime prime splitPoint split point if maxError max < { bezierPath bezier path curveTo curve to float bezCurve bez curve 1 float bezCurve bez curve 1 float bezCurve bez curve 2 float bezCurve bez curve 2 float bezCurve bez curve 3 float bezCurve bez curve 3 } = uPrime prime } } tHatCenter hat center = computeCenterTangent compute center tangent splitPoint split point 0 fitCubic fit cubic first splitPoint split point 0 tHat1 hat1 tHatCenter hat center bezierPath bezier path v2Negate v2 negate tHatCenter hat center fitCubic fit cubic splitPoint split point 0 last tHatCenter hat center tHat2 hat2 bezierPath bezier path } private fitCubic fit cubic Point2D point2 first last Point2D point2 tHat1 hat1 Point2D point2 tHat2 hat2 BezierPath bezier path bezierPath bezier path { Point2D point2 bezCurve bez curve 		 uPrime prime 	 double	maxError double	max 	 	splitPoint 	split point = new 1 int	nPts int	n pts 		 double	iterationError double	iteration int	maxIterations int	max iterations = 4 Point2D point2 Double	tHatCenter double	t hat center = new Point2D point2 int	i iterationError iteration = * nPts pts = last first + 1 if nPts pts == 2 { dist = v2DistanceBetween2Points v2 distance between2 points last first / 3 0 bezCurve bez curve = new Point2D point2 4 for i=0 < bezCurve bez curve length i++ { bezCurve bez curve = new Point2D point2 } bezCurve bez curve 0 = first bezCurve bez curve 3 = last v2Add v2 add bezCurve bez curve 0 v2Scale v2 scale tHat1 hat1 dist bezCurve bez curve 1 v2Add v2 add bezCurve bez curve 3 v2Scale v2 scale tHat2 hat2 dist bezCurve bez curve 2 bezierPath bezier path curveTo curve to bezCurve bez curve 1 bezCurve bez curve 1 bezCurve bez curve 2 bezCurve bez curve 2 bezCurve bez curve 3 bezCurve bez curve 3 } = chordLengthParameterize chord length parameterize first last bezCurve bez curve = generateBezier generate bezier first last tHat1 hat1 tHat2 hat2 maxError max = computeMaxError compute max first last bezCurve bez curve splitPoint split point if maxError max < { bezierPath bezier path curveTo curve to bezCurve bez curve 1 bezCurve bez curve 1 bezCurve bez curve 2 bezCurve bez curve 2 bezCurve bez curve 3 bezCurve bez curve 3 } if maxError max < iterationError iteration { for = 0 < maxIterations max iterations i++ { uPrime prime = reparameterize first last bezCurve bez curve bezCurve bez curve = generateBezier generate bezier first last uPrime prime tHat1 hat1 tHat2 hat2 maxError max = computeMaxError compute max first last bezCurve bez curve uPrime prime splitPoint split point if maxError max < { bezierPath bezier path curveTo curve to bezCurve bez curve 1 bezCurve bez curve 1 bezCurve bez curve 2 bezCurve bez curve 2 bezCurve bez curve 3 bezCurve bez curve 3 } = uPrime prime } } tHatCenter hat center = computeCenterTangent compute center tangent splitPoint split point 0 fitCubic fit cubic first splitPoint split point 0 tHat1 hat1 tHatCenter hat center bezierPath bezier path v2Negate v2 negate tHatCenter hat center fitCubic fit cubic splitPoint split point 0 last tHatCenter hat center tHat2 hat2 bezierPath bezier path } private Point2D point2 generateBezier generate bezier Point2D point2 first last uPrime prime Point2D point2 tHat1 hat1 Point2D point2 tHat2 hat2 { 	i Point2D point2 = new Point2D point2 MAXPOINTS 2 	nPts 	n pts 			 = new 2 2 = new 2 	 	det_C0_C1 		 det_C0_X det_X_C1 	alpha_l 		 alpha_r Point2D point2 	tmp = new Point2D point2 Point2D point2 bezCurve bez curve 	 bezCurve bez curve = new Point2D point2 4 for i=0 < bezCurve bez curve length i++ { bezCurve bez curve = new Point2D point2 } nPts pts = last first + 1 for = 0 < nPts pts i++ { Point2D point2 v1 v2 v1 = Point2D point2 tHat1 hat1 clone v2 = Point2D point2 tHat2 hat2 clone v2Scale v2 scale v1 b1 uPrime prime v2Scale v2 scale v2 b2 uPrime prime 0 = v1 1 = v2 } 0 0 = 0 0 0 1 = 0 0 1 0 = 0 0 1 1 = 0 0 0 = 0 0 1 = 0 0 for = 0 < nPts pts i++ { 0 0 += v2Dot v2 dot 0 0 0 1 += v2Dot v2 dot 0 1 1 0 = 0 1 1 1 += v2Dot v2 dot 1 1 tmp = v2SubII v2 sub first + v2AddII v2 add v2ScaleIII v2 scale first b0 uPrime prime v2AddII v2 add v2ScaleIII v2 scale first b1 uPrime prime v2AddII v2 add v2ScaleIII v2 scale last b2 uPrime prime v2ScaleIII v2 scale last b3 uPrime prime 0 += v2Dot v2 dot 0 tmp 1 += v2Dot v2 dot 1 tmp } det_C0_C1 = 0 0 * 1 1 1 0 * 0 1 det_C0_X = 0 0 * 1 0 1 * 0 det_X_C1 = 0 * 1 1 1 * 0 1 if det_C0_C1 == 0 0 { det_C0_C1 = 0 0 * 1 1 * 10e 12 } alpha_l = det_X_C1 / det_C0_C1 alpha_r = det_C0_X / det_C0_C1 if alpha_l < 1 0e 6 || alpha_r < 1 0e 6 { dist = v2DistanceBetween2Points v2 distance between2 points last first / 3 0 bezCurve bez curve 0 = first bezCurve bez curve 3 = last v2Add v2 add bezCurve bez curve 0 v2Scale v2 scale tHat1 hat1 dist bezCurve bez curve 1 v2Add v2 add bezCurve bez curve 3 v2Scale v2 scale tHat2 hat2 dist bezCurve bez curve 2 bezCurve bez curve } bezCurve bez curve 0 = first bezCurve bez curve 3 = last v2Add v2 add bezCurve bez curve 0 v2Scale v2 scale tHat1 hat1 alpha_l bezCurve bez curve 1 v2Add v2 add bezCurve bez curve 3 v2Scale v2 scale tHat2 hat2 alpha_r bezCurve bez curve 2 bezCurve bez curve } private reparameterize Point2D point2 first last Point2D point2 bezCurve bez curve { 	nPts 	n pts = last first+1 	i uPrime prime uPrime prime = new nPts pts for = first <= last i++ { uPrime prime first = newtonRaphsonRootFind newton raphson root find bezCurve bez curve first } uPrime prime } private newtonRaphsonRootFind newton raphson root find Point2D point2 Point2D point2 { 		numerator denominator Point2D point2 q1 = new Point2D point2 3 q2 = new Point2D point2 2 	 Point2D point2 Double	Q_u = new Point2D point2 Q1_u = new Point2D point2 Q2_u = new Point2D point2 		uPrime 		u prime 		 		i Q_u = bezierII bezier 3 for = 0 <= 2 i++ { q1 = new Point2D point2 i+1 * 3 0 i+1 * 3 0 } for = 0 <= 1 i++ { q2 = new Point2D point2 q1 i+1 q1 * 2 0 q1 i+1 q1 * 2 0 } Q1_u = bezierII bezier 2 q1 Q2_u = bezierII bezier 1 q2 numerator = Q_u * Q1_u + Q_u * Q1_u denominator = Q1_u * Q1_u + Q1_u * Q1_u + Q_u * Q2_u + Q_u * Q2_u uPrime prime = numerator/denominator uPrime prime } private Point2D point2 bezierII bezier degree Point2D point2 { 	i Point2D point2 Point2D point2 vtemp vtemp = new Point2D point2 degree+1 for = 0 <= degree i++ { vtemp = Point2D point2 clone } for = 1 <= degree i++ { for = 0 <= degree j++ { vtemp = 1 0 * vtemp + * vtemp j+1 vtemp = 1 0 * vtemp + * vtemp j+1 } } = vtemp 0 } private b0 { tmp = 1 0 tmp * tmp * tmp } private b1 { tmp = 1 0 3 * * tmp * tmp } private b2 { tmp = 1 0 3 * * * tmp } private b3 { * * } private Point2D point2 computeLeftTangent compute left tangent Point2D point2 { Point2D point2 Double	tHat1 double	t hat1 = new Point2D point2 tHat1 hat1 = v2SubII v2 sub end+1 tHat1 hat1 = v2Normalize v2 normalize tHat1 hat1 tHat1 hat1 } private Point2D point2 computeRightTangent compute right tangent Point2D point2 { Point2D point2 tHat2 hat2 = new Point2D point2 tHat2 hat2 = v2SubII v2 sub 1 tHat2 hat2 = v2Normalize v2 normalize tHat2 hat2 tHat2 hat2 } private Point2D point2 computeCenterTangent compute center tangent Point2D point2 center { Point2D point2 v1 = new Point2D point2 v2 = new Point2D point2 tHatCenter hat center = new Point2D point2 v1 = v2SubII v2 sub center 1 center v2 = v2SubII v2 sub center center+1 tHatCenter hat center = v1 + v2 /2 0 tHatCenter hat center = v1 + v2 /2 0 tHatCenter hat center = v2Normalize v2 normalize tHatCenter hat center tHatCenter hat center } private chordLengthParameterize chord length parameterize Point2D point2 first last { int	i 	 = new last first+1 0 = 0 0 for = first+1 <= last i++ { first = first 1 + v2DistanceBetween2Points v2 distance between2 points 1 } for = first + 1 <= last i++ { first = first / last first } } private computeMaxError compute max Point2D point2 first last Point2D point2 bezCurve bez curve splitPoint split point { int		i double	maxDist double	max dist 		 double	dist 		 Point2D point2 Double	P double	 = new Point2D point2 Point2D point2 double	v = new Point2D point2 splitPoint split point 0 = last first + 1 /2 maxDist max dist = 0 0 for = first + 1 < last i++ { = bezierII bezier 3 bezCurve bez curve first = v2SubII v2 sub dist = v2SquaredLength v2 squared length if dist >= maxDist max dist { maxDist max dist = dist splitPoint split point 0 = } } maxDist max dist } private Point2D point2 v2AddII v2 add Point2D point2 Point2D point2 { Point2D point2 = new Point2D point2 = + = + } private Point2D point2 v2ScaleIII v2 scale Point2D point2 { Point2D point2 result = new Point2D point2 result = * result = * result } private Point2D point2 v2SubII v2 sub Point2D point2 Point2D point2 { Point2D point2 = new Point2D point2 = = } private v2DistanceBetween2Points v2 distance between2 points Point2D point2 Point2D point2 { dx = dy = math sqrt dx*dx + dy*dy } private Point2D point2 v2Scale v2 scale Point2D point2 newlen { len = v2Length v2 length if len != 0 0 { *= newlen/len *= newlen/len } } private v2Length v2 length Point2D point2 { math sqrt v2SquaredLength v2 squared length } private v2SquaredLength v2 squared length Point2D point2 { * + * } private Point2D point2 v2Add v2 add Point2D point2 Point2D point2 Point2D point2 { = x+b = y+b } private Point2D point2 v2Negate v2 negate Point2D point2 { = = } private v2Dot v2 dot Point2D point2 Point2D point2 { x*b + y*b } private Point2D point2 v2Normalize v2 normalize Point2D point2 { len = v2Length v2 length if len != 0 0 { /= len /= len } } } 